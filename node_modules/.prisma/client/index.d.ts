
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model RFP
 * 
 */
export type RFP = $Result.DefaultSelection<Prisma.$RFPPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model PartnerCapability
 * 
 */
export type PartnerCapability = $Result.DefaultSelection<Prisma.$PartnerCapabilityPayload>
/**
 * Model CreativeSpec
 * 
 */
export type CreativeSpec = $Result.DefaultSelection<Prisma.$CreativeSpecPayload>
/**
 * Model PartnerHealthMetric
 * 
 */
export type PartnerHealthMetric = $Result.DefaultSelection<Prisma.$PartnerHealthMetricPayload>
/**
 * Model CampaignPartner
 * 
 */
export type CampaignPartner = $Result.DefaultSelection<Prisma.$CampaignPartnerPayload>
/**
 * Model CapabilityMatrix
 * 
 */
export type CapabilityMatrix = $Result.DefaultSelection<Prisma.$CapabilityMatrixPayload>
/**
 * Model Dataset
 * 
 */
export type Dataset = $Result.DefaultSelection<Prisma.$DatasetPayload>
/**
 * Model DatasetVersion
 * 
 */
export type DatasetVersion = $Result.DefaultSelection<Prisma.$DatasetVersionPayload>
/**
 * Model DataQualityReport
 * 
 */
export type DataQualityReport = $Result.DefaultSelection<Prisma.$DataQualityReportPayload>
/**
 * Model IngestionJob
 * 
 */
export type IngestionJob = $Result.DefaultSelection<Prisma.$IngestionJobPayload>
/**
 * Model DatasetLineage
 * 
 */
export type DatasetLineage = $Result.DefaultSelection<Prisma.$DatasetLineagePayload>
/**
 * Model DataConnector
 * 
 */
export type DataConnector = $Result.DefaultSelection<Prisma.$DataConnectorPayload>
/**
 * Model SchemaMapping
 * 
 */
export type SchemaMapping = $Result.DefaultSelection<Prisma.$SchemaMappingPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model DistributionSession
 * 
 */
export type DistributionSession = $Result.DefaultSelection<Prisma.$DistributionSessionPayload>
/**
 * Model DistributionScenario
 * 
 */
export type DistributionScenario = $Result.DefaultSelection<Prisma.$DistributionScenarioPayload>
/**
 * Model DistributionChange
 * 
 */
export type DistributionChange = $Result.DefaultSelection<Prisma.$DistributionChangePayload>
/**
 * Model DistributionCache
 * 
 */
export type DistributionCache = $Result.DefaultSelection<Prisma.$DistributionCachePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PartnerType: {
  DSP: 'DSP',
  SOCIAL: 'SOCIAL',
  SEARCH: 'SEARCH',
  RETAIL: 'RETAIL',
  VIDEO: 'VIDEO',
  NATIVE: 'NATIVE',
  EMAIL: 'EMAIL',
  AFFILIATE: 'AFFILIATE',
  OTHER: 'OTHER'
};

export type PartnerType = (typeof PartnerType)[keyof typeof PartnerType]


export const PartnerStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  ARCHIVED: 'ARCHIVED'
};

export type PartnerStatus = (typeof PartnerStatus)[keyof typeof PartnerStatus]


export const OnboardingStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type OnboardingStatus = (typeof OnboardingStatus)[keyof typeof OnboardingStatus]


export const CapabilitySourceType: {
  MANUAL: 'MANUAL',
  API_DISCOVERY: 'API_DISCOVERY',
  DOCUMENTATION: 'DOCUMENTATION',
  RATE_CARD: 'RATE_CARD',
  FORM_SUBMISSION: 'FORM_SUBMISSION'
};

export type CapabilitySourceType = (typeof CapabilitySourceType)[keyof typeof CapabilitySourceType]


export const ApiStatus: {
  HEALTHY: 'HEALTHY',
  DEGRADED: 'DEGRADED',
  DOWN: 'DOWN',
  UNKNOWN: 'UNKNOWN'
};

export type ApiStatus = (typeof ApiStatus)[keyof typeof ApiStatus]


export const CampaignPartnerStatus: {
  ASSOCIATED: 'ASSOCIATED',
  CONFIGURED: 'CONFIGURED',
  LAUNCHED: 'LAUNCHED',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type CampaignPartnerStatus = (typeof CampaignPartnerStatus)[keyof typeof CampaignPartnerStatus]


export const DatasetCategory: {
  MEASUREMENT: 'MEASUREMENT',
  TRANSACTION: 'TRANSACTION',
  SOCIAL: 'SOCIAL',
  DEMOGRAPHIC: 'DEMOGRAPHIC',
  MEDIA: 'MEDIA',
  DISTRIBUTOR: 'DISTRIBUTOR',
  EXTERNAL_API: 'EXTERNAL_API',
  INTERNAL: 'INTERNAL',
  OTHER: 'OTHER'
};

export type DatasetCategory = (typeof DatasetCategory)[keyof typeof DatasetCategory]


export const DatasetSourceType: {
  CSV_FILE: 'CSV_FILE',
  JSON_FILE: 'JSON_FILE',
  PARQUET_FILE: 'PARQUET_FILE',
  EXCEL_FILE: 'EXCEL_FILE',
  DATABASE_TABLE: 'DATABASE_TABLE',
  REST_API: 'REST_API',
  GRAPHQL_API: 'GRAPHQL_API',
  SFTP_SERVER: 'SFTP_SERVER',
  S3_BUCKET: 'S3_BUCKET',
  WEBHOOK: 'WEBHOOK',
  STREAMING: 'STREAMING',
  OTHER: 'OTHER'
};

export type DatasetSourceType = (typeof DatasetSourceType)[keyof typeof DatasetSourceType]


export const UpdateFrequency: {
  REAL_TIME: 'REAL_TIME',
  EVERY_15_MINUTES: 'EVERY_15_MINUTES',
  HOURLY: 'HOURLY',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  ANNUALLY: 'ANNUALLY',
  ON_DEMAND: 'ON_DEMAND',
  IRREGULAR: 'IRREGULAR'
};

export type UpdateFrequency = (typeof UpdateFrequency)[keyof typeof UpdateFrequency]


export const DatasetStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ARCHIVED: 'ARCHIVED',
  ERROR: 'ERROR',
  PROCESSING: 'PROCESSING'
};

export type DatasetStatus = (typeof DatasetStatus)[keyof typeof DatasetStatus]


export const IngestionJobType: {
  FULL_LOAD: 'FULL_LOAD',
  INCREMENTAL: 'INCREMENTAL',
  APPEND_ONLY: 'APPEND_ONLY',
  UPSERT: 'UPSERT',
  DELETE: 'DELETE',
  VALIDATION: 'VALIDATION'
};

export type IngestionJobType = (typeof IngestionJobType)[keyof typeof IngestionJobType]


export const JobStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  RETRYING: 'RETRYING'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const DataConnectorType: {
  FOURSQUARE_API: 'FOURSQUARE_API',
  NIELSEN_SFTP: 'NIELSEN_SFTP',
  IRI_SFTP: 'IRI_SFTP',
  ECOMMERCE_WEBHOOK: 'ECOMMERCE_WEBHOOK',
  BRANDWATCH_API: 'BRANDWATCH_API',
  SPRINKLR_API: 'SPRINKLR_API',
  DISTRIBUTOR_FTP: 'DISTRIBUTOR_FTP',
  CUSTOM_API: 'CUSTOM_API',
  FILE_SYSTEM: 'FILE_SYSTEM',
  DATABASE: 'DATABASE',
  OTHER: 'OTHER'
};

export type DataConnectorType = (typeof DataConnectorType)[keyof typeof DataConnectorType]


export const ConnectorHealthStatus: {
  HEALTHY: 'HEALTHY',
  DEGRADED: 'DEGRADED',
  DOWN: 'DOWN',
  UNKNOWN: 'UNKNOWN'
};

export type ConnectorHealthStatus = (typeof ConnectorHealthStatus)[keyof typeof ConnectorHealthStatus]

}

export type PartnerType = $Enums.PartnerType

export const PartnerType: typeof $Enums.PartnerType

export type PartnerStatus = $Enums.PartnerStatus

export const PartnerStatus: typeof $Enums.PartnerStatus

export type OnboardingStatus = $Enums.OnboardingStatus

export const OnboardingStatus: typeof $Enums.OnboardingStatus

export type CapabilitySourceType = $Enums.CapabilitySourceType

export const CapabilitySourceType: typeof $Enums.CapabilitySourceType

export type ApiStatus = $Enums.ApiStatus

export const ApiStatus: typeof $Enums.ApiStatus

export type CampaignPartnerStatus = $Enums.CampaignPartnerStatus

export const CampaignPartnerStatus: typeof $Enums.CampaignPartnerStatus

export type DatasetCategory = $Enums.DatasetCategory

export const DatasetCategory: typeof $Enums.DatasetCategory

export type DatasetSourceType = $Enums.DatasetSourceType

export const DatasetSourceType: typeof $Enums.DatasetSourceType

export type UpdateFrequency = $Enums.UpdateFrequency

export const UpdateFrequency: typeof $Enums.UpdateFrequency

export type DatasetStatus = $Enums.DatasetStatus

export const DatasetStatus: typeof $Enums.DatasetStatus

export type IngestionJobType = $Enums.IngestionJobType

export const IngestionJobType: typeof $Enums.IngestionJobType

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type DataConnectorType = $Enums.DataConnectorType

export const DataConnectorType: typeof $Enums.DataConnectorType

export type ConnectorHealthStatus = $Enums.ConnectorHealthStatus

export const ConnectorHealthStatus: typeof $Enums.ConnectorHealthStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.rFP`: Exposes CRUD operations for the **RFP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RFPS
    * const rFPS = await prisma.rFP.findMany()
    * ```
    */
  get rFP(): Prisma.RFPDelegate<ExtArgs>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs>;

  /**
   * `prisma.partnerCapability`: Exposes CRUD operations for the **PartnerCapability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerCapabilities
    * const partnerCapabilities = await prisma.partnerCapability.findMany()
    * ```
    */
  get partnerCapability(): Prisma.PartnerCapabilityDelegate<ExtArgs>;

  /**
   * `prisma.creativeSpec`: Exposes CRUD operations for the **CreativeSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreativeSpecs
    * const creativeSpecs = await prisma.creativeSpec.findMany()
    * ```
    */
  get creativeSpec(): Prisma.CreativeSpecDelegate<ExtArgs>;

  /**
   * `prisma.partnerHealthMetric`: Exposes CRUD operations for the **PartnerHealthMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerHealthMetrics
    * const partnerHealthMetrics = await prisma.partnerHealthMetric.findMany()
    * ```
    */
  get partnerHealthMetric(): Prisma.PartnerHealthMetricDelegate<ExtArgs>;

  /**
   * `prisma.campaignPartner`: Exposes CRUD operations for the **CampaignPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignPartners
    * const campaignPartners = await prisma.campaignPartner.findMany()
    * ```
    */
  get campaignPartner(): Prisma.CampaignPartnerDelegate<ExtArgs>;

  /**
   * `prisma.capabilityMatrix`: Exposes CRUD operations for the **CapabilityMatrix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapabilityMatrices
    * const capabilityMatrices = await prisma.capabilityMatrix.findMany()
    * ```
    */
  get capabilityMatrix(): Prisma.CapabilityMatrixDelegate<ExtArgs>;

  /**
   * `prisma.dataset`: Exposes CRUD operations for the **Dataset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datasets
    * const datasets = await prisma.dataset.findMany()
    * ```
    */
  get dataset(): Prisma.DatasetDelegate<ExtArgs>;

  /**
   * `prisma.datasetVersion`: Exposes CRUD operations for the **DatasetVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatasetVersions
    * const datasetVersions = await prisma.datasetVersion.findMany()
    * ```
    */
  get datasetVersion(): Prisma.DatasetVersionDelegate<ExtArgs>;

  /**
   * `prisma.dataQualityReport`: Exposes CRUD operations for the **DataQualityReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataQualityReports
    * const dataQualityReports = await prisma.dataQualityReport.findMany()
    * ```
    */
  get dataQualityReport(): Prisma.DataQualityReportDelegate<ExtArgs>;

  /**
   * `prisma.ingestionJob`: Exposes CRUD operations for the **IngestionJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngestionJobs
    * const ingestionJobs = await prisma.ingestionJob.findMany()
    * ```
    */
  get ingestionJob(): Prisma.IngestionJobDelegate<ExtArgs>;

  /**
   * `prisma.datasetLineage`: Exposes CRUD operations for the **DatasetLineage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatasetLineages
    * const datasetLineages = await prisma.datasetLineage.findMany()
    * ```
    */
  get datasetLineage(): Prisma.DatasetLineageDelegate<ExtArgs>;

  /**
   * `prisma.dataConnector`: Exposes CRUD operations for the **DataConnector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataConnectors
    * const dataConnectors = await prisma.dataConnector.findMany()
    * ```
    */
  get dataConnector(): Prisma.DataConnectorDelegate<ExtArgs>;

  /**
   * `prisma.schemaMapping`: Exposes CRUD operations for the **SchemaMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchemaMappings
    * const schemaMappings = await prisma.schemaMapping.findMany()
    * ```
    */
  get schemaMapping(): Prisma.SchemaMappingDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.distributionSession`: Exposes CRUD operations for the **DistributionSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DistributionSessions
    * const distributionSessions = await prisma.distributionSession.findMany()
    * ```
    */
  get distributionSession(): Prisma.DistributionSessionDelegate<ExtArgs>;

  /**
   * `prisma.distributionScenario`: Exposes CRUD operations for the **DistributionScenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DistributionScenarios
    * const distributionScenarios = await prisma.distributionScenario.findMany()
    * ```
    */
  get distributionScenario(): Prisma.DistributionScenarioDelegate<ExtArgs>;

  /**
   * `prisma.distributionChange`: Exposes CRUD operations for the **DistributionChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DistributionChanges
    * const distributionChanges = await prisma.distributionChange.findMany()
    * ```
    */
  get distributionChange(): Prisma.DistributionChangeDelegate<ExtArgs>;

  /**
   * `prisma.distributionCache`: Exposes CRUD operations for the **DistributionCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DistributionCaches
    * const distributionCaches = await prisma.distributionCache.findMany()
    * ```
    */
  get distributionCache(): Prisma.DistributionCacheDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Campaign: 'Campaign',
    RFP: 'RFP',
    Partner: 'Partner',
    PartnerCapability: 'PartnerCapability',
    CreativeSpec: 'CreativeSpec',
    PartnerHealthMetric: 'PartnerHealthMetric',
    CampaignPartner: 'CampaignPartner',
    CapabilityMatrix: 'CapabilityMatrix',
    Dataset: 'Dataset',
    DatasetVersion: 'DatasetVersion',
    DataQualityReport: 'DataQualityReport',
    IngestionJob: 'IngestionJob',
    DatasetLineage: 'DatasetLineage',
    DataConnector: 'DataConnector',
    SchemaMapping: 'SchemaMapping',
    AuditLog: 'AuditLog',
    DistributionSession: 'DistributionSession',
    DistributionScenario: 'DistributionScenario',
    DistributionChange: 'DistributionChange',
    DistributionCache: 'DistributionCache'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "campaign" | "rFP" | "partner" | "partnerCapability" | "creativeSpec" | "partnerHealthMetric" | "campaignPartner" | "capabilityMatrix" | "dataset" | "datasetVersion" | "dataQualityReport" | "ingestionJob" | "datasetLineage" | "dataConnector" | "schemaMapping" | "auditLog" | "distributionSession" | "distributionScenario" | "distributionChange" | "distributionCache"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      RFP: {
        payload: Prisma.$RFPPayload<ExtArgs>
        fields: Prisma.RFPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RFPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RFPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>
          }
          findFirst: {
            args: Prisma.RFPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RFPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>
          }
          findMany: {
            args: Prisma.RFPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>[]
          }
          create: {
            args: Prisma.RFPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>
          }
          createMany: {
            args: Prisma.RFPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RFPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>[]
          }
          delete: {
            args: Prisma.RFPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>
          }
          update: {
            args: Prisma.RFPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>
          }
          deleteMany: {
            args: Prisma.RFPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RFPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RFPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFPPayload>
          }
          aggregate: {
            args: Prisma.RFPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRFP>
          }
          groupBy: {
            args: Prisma.RFPGroupByArgs<ExtArgs>
            result: $Utils.Optional<RFPGroupByOutputType>[]
          }
          count: {
            args: Prisma.RFPCountArgs<ExtArgs>
            result: $Utils.Optional<RFPCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      PartnerCapability: {
        payload: Prisma.$PartnerCapabilityPayload<ExtArgs>
        fields: Prisma.PartnerCapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerCapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerCapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>
          }
          findFirst: {
            args: Prisma.PartnerCapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerCapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>
          }
          findMany: {
            args: Prisma.PartnerCapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>[]
          }
          create: {
            args: Prisma.PartnerCapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>
          }
          createMany: {
            args: Prisma.PartnerCapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCapabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>[]
          }
          delete: {
            args: Prisma.PartnerCapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>
          }
          update: {
            args: Prisma.PartnerCapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>
          }
          deleteMany: {
            args: Prisma.PartnerCapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerCapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerCapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerCapabilityPayload>
          }
          aggregate: {
            args: Prisma.PartnerCapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerCapability>
          }
          groupBy: {
            args: Prisma.PartnerCapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerCapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCapabilityCountAggregateOutputType> | number
          }
        }
      }
      CreativeSpec: {
        payload: Prisma.$CreativeSpecPayload<ExtArgs>
        fields: Prisma.CreativeSpecFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreativeSpecFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreativeSpecFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>
          }
          findFirst: {
            args: Prisma.CreativeSpecFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreativeSpecFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>
          }
          findMany: {
            args: Prisma.CreativeSpecFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>[]
          }
          create: {
            args: Prisma.CreativeSpecCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>
          }
          createMany: {
            args: Prisma.CreativeSpecCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreativeSpecCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>[]
          }
          delete: {
            args: Prisma.CreativeSpecDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>
          }
          update: {
            args: Prisma.CreativeSpecUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>
          }
          deleteMany: {
            args: Prisma.CreativeSpecDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreativeSpecUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreativeSpecUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeSpecPayload>
          }
          aggregate: {
            args: Prisma.CreativeSpecAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreativeSpec>
          }
          groupBy: {
            args: Prisma.CreativeSpecGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreativeSpecGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreativeSpecCountArgs<ExtArgs>
            result: $Utils.Optional<CreativeSpecCountAggregateOutputType> | number
          }
        }
      }
      PartnerHealthMetric: {
        payload: Prisma.$PartnerHealthMetricPayload<ExtArgs>
        fields: Prisma.PartnerHealthMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerHealthMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerHealthMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>
          }
          findFirst: {
            args: Prisma.PartnerHealthMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerHealthMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>
          }
          findMany: {
            args: Prisma.PartnerHealthMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>[]
          }
          create: {
            args: Prisma.PartnerHealthMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>
          }
          createMany: {
            args: Prisma.PartnerHealthMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerHealthMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>[]
          }
          delete: {
            args: Prisma.PartnerHealthMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>
          }
          update: {
            args: Prisma.PartnerHealthMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>
          }
          deleteMany: {
            args: Prisma.PartnerHealthMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerHealthMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerHealthMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerHealthMetricPayload>
          }
          aggregate: {
            args: Prisma.PartnerHealthMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerHealthMetric>
          }
          groupBy: {
            args: Prisma.PartnerHealthMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerHealthMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerHealthMetricCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerHealthMetricCountAggregateOutputType> | number
          }
        }
      }
      CampaignPartner: {
        payload: Prisma.$CampaignPartnerPayload<ExtArgs>
        fields: Prisma.CampaignPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>
          }
          findFirst: {
            args: Prisma.CampaignPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>
          }
          findMany: {
            args: Prisma.CampaignPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>[]
          }
          create: {
            args: Prisma.CampaignPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>
          }
          createMany: {
            args: Prisma.CampaignPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>[]
          }
          delete: {
            args: Prisma.CampaignPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>
          }
          update: {
            args: Prisma.CampaignPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>
          }
          deleteMany: {
            args: Prisma.CampaignPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPartnerPayload>
          }
          aggregate: {
            args: Prisma.CampaignPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignPartner>
          }
          groupBy: {
            args: Prisma.CampaignPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignPartnerCountAggregateOutputType> | number
          }
        }
      }
      CapabilityMatrix: {
        payload: Prisma.$CapabilityMatrixPayload<ExtArgs>
        fields: Prisma.CapabilityMatrixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapabilityMatrixFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapabilityMatrixFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>
          }
          findFirst: {
            args: Prisma.CapabilityMatrixFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapabilityMatrixFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>
          }
          findMany: {
            args: Prisma.CapabilityMatrixFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>[]
          }
          create: {
            args: Prisma.CapabilityMatrixCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>
          }
          createMany: {
            args: Prisma.CapabilityMatrixCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapabilityMatrixCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>[]
          }
          delete: {
            args: Prisma.CapabilityMatrixDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>
          }
          update: {
            args: Prisma.CapabilityMatrixUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>
          }
          deleteMany: {
            args: Prisma.CapabilityMatrixDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapabilityMatrixUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CapabilityMatrixUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityMatrixPayload>
          }
          aggregate: {
            args: Prisma.CapabilityMatrixAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapabilityMatrix>
          }
          groupBy: {
            args: Prisma.CapabilityMatrixGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapabilityMatrixGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapabilityMatrixCountArgs<ExtArgs>
            result: $Utils.Optional<CapabilityMatrixCountAggregateOutputType> | number
          }
        }
      }
      Dataset: {
        payload: Prisma.$DatasetPayload<ExtArgs>
        fields: Prisma.DatasetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          findFirst: {
            args: Prisma.DatasetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          findMany: {
            args: Prisma.DatasetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          create: {
            args: Prisma.DatasetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          createMany: {
            args: Prisma.DatasetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          delete: {
            args: Prisma.DatasetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          update: {
            args: Prisma.DatasetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          deleteMany: {
            args: Prisma.DatasetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          aggregate: {
            args: Prisma.DatasetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataset>
          }
          groupBy: {
            args: Prisma.DatasetGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetCountAggregateOutputType> | number
          }
        }
      }
      DatasetVersion: {
        payload: Prisma.$DatasetVersionPayload<ExtArgs>
        fields: Prisma.DatasetVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>
          }
          findFirst: {
            args: Prisma.DatasetVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>
          }
          findMany: {
            args: Prisma.DatasetVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>[]
          }
          create: {
            args: Prisma.DatasetVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>
          }
          createMany: {
            args: Prisma.DatasetVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>[]
          }
          delete: {
            args: Prisma.DatasetVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>
          }
          update: {
            args: Prisma.DatasetVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>
          }
          deleteMany: {
            args: Prisma.DatasetVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetVersionPayload>
          }
          aggregate: {
            args: Prisma.DatasetVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatasetVersion>
          }
          groupBy: {
            args: Prisma.DatasetVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetVersionCountAggregateOutputType> | number
          }
        }
      }
      DataQualityReport: {
        payload: Prisma.$DataQualityReportPayload<ExtArgs>
        fields: Prisma.DataQualityReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataQualityReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataQualityReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>
          }
          findFirst: {
            args: Prisma.DataQualityReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataQualityReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>
          }
          findMany: {
            args: Prisma.DataQualityReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>[]
          }
          create: {
            args: Prisma.DataQualityReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>
          }
          createMany: {
            args: Prisma.DataQualityReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataQualityReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>[]
          }
          delete: {
            args: Prisma.DataQualityReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>
          }
          update: {
            args: Prisma.DataQualityReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>
          }
          deleteMany: {
            args: Prisma.DataQualityReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataQualityReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataQualityReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityReportPayload>
          }
          aggregate: {
            args: Prisma.DataQualityReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataQualityReport>
          }
          groupBy: {
            args: Prisma.DataQualityReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataQualityReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataQualityReportCountArgs<ExtArgs>
            result: $Utils.Optional<DataQualityReportCountAggregateOutputType> | number
          }
        }
      }
      IngestionJob: {
        payload: Prisma.$IngestionJobPayload<ExtArgs>
        fields: Prisma.IngestionJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngestionJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngestionJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          findFirst: {
            args: Prisma.IngestionJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngestionJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          findMany: {
            args: Prisma.IngestionJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>[]
          }
          create: {
            args: Prisma.IngestionJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          createMany: {
            args: Prisma.IngestionJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngestionJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>[]
          }
          delete: {
            args: Prisma.IngestionJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          update: {
            args: Prisma.IngestionJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          deleteMany: {
            args: Prisma.IngestionJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngestionJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IngestionJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          aggregate: {
            args: Prisma.IngestionJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngestionJob>
          }
          groupBy: {
            args: Prisma.IngestionJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngestionJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngestionJobCountArgs<ExtArgs>
            result: $Utils.Optional<IngestionJobCountAggregateOutputType> | number
          }
        }
      }
      DatasetLineage: {
        payload: Prisma.$DatasetLineagePayload<ExtArgs>
        fields: Prisma.DatasetLineageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetLineageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetLineageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>
          }
          findFirst: {
            args: Prisma.DatasetLineageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetLineageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>
          }
          findMany: {
            args: Prisma.DatasetLineageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>[]
          }
          create: {
            args: Prisma.DatasetLineageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>
          }
          createMany: {
            args: Prisma.DatasetLineageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetLineageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>[]
          }
          delete: {
            args: Prisma.DatasetLineageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>
          }
          update: {
            args: Prisma.DatasetLineageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>
          }
          deleteMany: {
            args: Prisma.DatasetLineageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetLineageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatasetLineageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetLineagePayload>
          }
          aggregate: {
            args: Prisma.DatasetLineageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatasetLineage>
          }
          groupBy: {
            args: Prisma.DatasetLineageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetLineageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetLineageCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetLineageCountAggregateOutputType> | number
          }
        }
      }
      DataConnector: {
        payload: Prisma.$DataConnectorPayload<ExtArgs>
        fields: Prisma.DataConnectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataConnectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataConnectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>
          }
          findFirst: {
            args: Prisma.DataConnectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataConnectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>
          }
          findMany: {
            args: Prisma.DataConnectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>[]
          }
          create: {
            args: Prisma.DataConnectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>
          }
          createMany: {
            args: Prisma.DataConnectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataConnectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>[]
          }
          delete: {
            args: Prisma.DataConnectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>
          }
          update: {
            args: Prisma.DataConnectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>
          }
          deleteMany: {
            args: Prisma.DataConnectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataConnectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataConnectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataConnectorPayload>
          }
          aggregate: {
            args: Prisma.DataConnectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataConnector>
          }
          groupBy: {
            args: Prisma.DataConnectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataConnectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataConnectorCountArgs<ExtArgs>
            result: $Utils.Optional<DataConnectorCountAggregateOutputType> | number
          }
        }
      }
      SchemaMapping: {
        payload: Prisma.$SchemaMappingPayload<ExtArgs>
        fields: Prisma.SchemaMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchemaMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchemaMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>
          }
          findFirst: {
            args: Prisma.SchemaMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchemaMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>
          }
          findMany: {
            args: Prisma.SchemaMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>[]
          }
          create: {
            args: Prisma.SchemaMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>
          }
          createMany: {
            args: Prisma.SchemaMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchemaMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>[]
          }
          delete: {
            args: Prisma.SchemaMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>
          }
          update: {
            args: Prisma.SchemaMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>
          }
          deleteMany: {
            args: Prisma.SchemaMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchemaMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchemaMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchemaMappingPayload>
          }
          aggregate: {
            args: Prisma.SchemaMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchemaMapping>
          }
          groupBy: {
            args: Prisma.SchemaMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchemaMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchemaMappingCountArgs<ExtArgs>
            result: $Utils.Optional<SchemaMappingCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      DistributionSession: {
        payload: Prisma.$DistributionSessionPayload<ExtArgs>
        fields: Prisma.DistributionSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributionSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributionSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>
          }
          findFirst: {
            args: Prisma.DistributionSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributionSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>
          }
          findMany: {
            args: Prisma.DistributionSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>[]
          }
          create: {
            args: Prisma.DistributionSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>
          }
          createMany: {
            args: Prisma.DistributionSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistributionSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>[]
          }
          delete: {
            args: Prisma.DistributionSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>
          }
          update: {
            args: Prisma.DistributionSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>
          }
          deleteMany: {
            args: Prisma.DistributionSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributionSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributionSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionSessionPayload>
          }
          aggregate: {
            args: Prisma.DistributionSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributionSession>
          }
          groupBy: {
            args: Prisma.DistributionSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributionSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributionSessionCountArgs<ExtArgs>
            result: $Utils.Optional<DistributionSessionCountAggregateOutputType> | number
          }
        }
      }
      DistributionScenario: {
        payload: Prisma.$DistributionScenarioPayload<ExtArgs>
        fields: Prisma.DistributionScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributionScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributionScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>
          }
          findFirst: {
            args: Prisma.DistributionScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributionScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>
          }
          findMany: {
            args: Prisma.DistributionScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>[]
          }
          create: {
            args: Prisma.DistributionScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>
          }
          createMany: {
            args: Prisma.DistributionScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistributionScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>[]
          }
          delete: {
            args: Prisma.DistributionScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>
          }
          update: {
            args: Prisma.DistributionScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>
          }
          deleteMany: {
            args: Prisma.DistributionScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributionScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributionScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionScenarioPayload>
          }
          aggregate: {
            args: Prisma.DistributionScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributionScenario>
          }
          groupBy: {
            args: Prisma.DistributionScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributionScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributionScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<DistributionScenarioCountAggregateOutputType> | number
          }
        }
      }
      DistributionChange: {
        payload: Prisma.$DistributionChangePayload<ExtArgs>
        fields: Prisma.DistributionChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributionChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributionChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>
          }
          findFirst: {
            args: Prisma.DistributionChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributionChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>
          }
          findMany: {
            args: Prisma.DistributionChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>[]
          }
          create: {
            args: Prisma.DistributionChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>
          }
          createMany: {
            args: Prisma.DistributionChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistributionChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>[]
          }
          delete: {
            args: Prisma.DistributionChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>
          }
          update: {
            args: Prisma.DistributionChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>
          }
          deleteMany: {
            args: Prisma.DistributionChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributionChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributionChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionChangePayload>
          }
          aggregate: {
            args: Prisma.DistributionChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributionChange>
          }
          groupBy: {
            args: Prisma.DistributionChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributionChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributionChangeCountArgs<ExtArgs>
            result: $Utils.Optional<DistributionChangeCountAggregateOutputType> | number
          }
        }
      }
      DistributionCache: {
        payload: Prisma.$DistributionCachePayload<ExtArgs>
        fields: Prisma.DistributionCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistributionCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributionCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>
          }
          findFirst: {
            args: Prisma.DistributionCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributionCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>
          }
          findMany: {
            args: Prisma.DistributionCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>[]
          }
          create: {
            args: Prisma.DistributionCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>
          }
          createMany: {
            args: Prisma.DistributionCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistributionCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>[]
          }
          delete: {
            args: Prisma.DistributionCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>
          }
          update: {
            args: Prisma.DistributionCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>
          }
          deleteMany: {
            args: Prisma.DistributionCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistributionCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistributionCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistributionCachePayload>
          }
          aggregate: {
            args: Prisma.DistributionCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistributionCache>
          }
          groupBy: {
            args: Prisma.DistributionCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistributionCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributionCacheCountArgs<ExtArgs>
            result: $Utils.Optional<DistributionCacheCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    campaigns: number
    auditLogs: number
    distributionChanges: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    distributionChanges?: boolean | UserCountOutputTypeCountDistributionChangesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDistributionChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionChangeWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    rfps: number
    partnerAssociations: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfps?: boolean | CampaignCountOutputTypeCountRfpsArgs
    partnerAssociations?: boolean | CampaignCountOutputTypeCountPartnerAssociationsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRfpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFPWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountPartnerAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignPartnerWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    capabilities: number
    creativeSpecs: number
    healthMetrics: number
    campaignAssociations: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capabilities?: boolean | PartnerCountOutputTypeCountCapabilitiesArgs
    creativeSpecs?: boolean | PartnerCountOutputTypeCountCreativeSpecsArgs
    healthMetrics?: boolean | PartnerCountOutputTypeCountHealthMetricsArgs
    campaignAssociations?: boolean | PartnerCountOutputTypeCountCampaignAssociationsArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerCapabilityWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountCreativeSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeSpecWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountHealthMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerHealthMetricWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountCampaignAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignPartnerWhereInput
  }


  /**
   * Count Type DatasetCountOutputType
   */

  export type DatasetCountOutputType = {
    versions: number
    qualityReports: number
    ingestionJobs: number
    lineageUpstream: number
    lineageDownstream: number
  }

  export type DatasetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | DatasetCountOutputTypeCountVersionsArgs
    qualityReports?: boolean | DatasetCountOutputTypeCountQualityReportsArgs
    ingestionJobs?: boolean | DatasetCountOutputTypeCountIngestionJobsArgs
    lineageUpstream?: boolean | DatasetCountOutputTypeCountLineageUpstreamArgs
    lineageDownstream?: boolean | DatasetCountOutputTypeCountLineageDownstreamArgs
  }

  // Custom InputTypes
  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetCountOutputType
     */
    select?: DatasetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetVersionWhereInput
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountQualityReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataQualityReportWhereInput
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountIngestionJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestionJobWhereInput
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountLineageUpstreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetLineageWhereInput
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountLineageDownstreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetLineageWhereInput
  }


  /**
   * Count Type DistributionSessionCountOutputType
   */

  export type DistributionSessionCountOutputType = {
    scenarios: number
  }

  export type DistributionSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenarios?: boolean | DistributionSessionCountOutputTypeCountScenariosArgs
  }

  // Custom InputTypes
  /**
   * DistributionSessionCountOutputType without action
   */
  export type DistributionSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSessionCountOutputType
     */
    select?: DistributionSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistributionSessionCountOutputType without action
   */
  export type DistributionSessionCountOutputTypeCountScenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionScenarioWhereInput
  }


  /**
   * Count Type DistributionScenarioCountOutputType
   */

  export type DistributionScenarioCountOutputType = {
    changes: number
  }

  export type DistributionScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changes?: boolean | DistributionScenarioCountOutputTypeCountChangesArgs
  }

  // Custom InputTypes
  /**
   * DistributionScenarioCountOutputType without action
   */
  export type DistributionScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenarioCountOutputType
     */
    select?: DistributionScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistributionScenarioCountOutputType without action
   */
  export type DistributionScenarioCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionChangeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    organizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    organizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: string
    organizationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    distributionChanges?: boolean | User$distributionChangesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    distributionChanges?: boolean | User$distributionChangesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      distributionChanges: Prisma.$DistributionChangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: string
      organizationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    distributionChanges<T extends User$distributionChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$distributionChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.distributionChanges
   */
  export type User$distributionChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    where?: DistributionChangeWhereInput
    orderBy?: DistributionChangeOrderByWithRelationInput | DistributionChangeOrderByWithRelationInput[]
    cursor?: DistributionChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistributionChangeScalarFieldEnum | DistributionChangeScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    brandId: string | null
    status: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brandId: string | null
    status: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    brandId: number
    objectives: number
    budget: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    objectives?: true
    budget?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    brandId: string
    objectives: JsonValue
    budget: JsonValue
    status: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brandId?: boolean
    objectives?: boolean
    budget?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    rfps?: boolean | Campaign$rfpsArgs<ExtArgs>
    partnerAssociations?: boolean | Campaign$partnerAssociationsArgs<ExtArgs>
    distributionSession?: boolean | Campaign$distributionSessionArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brandId?: boolean
    objectives?: boolean
    budget?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    brandId?: boolean
    objectives?: boolean
    budget?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    rfps?: boolean | Campaign$rfpsArgs<ExtArgs>
    partnerAssociations?: boolean | Campaign$partnerAssociationsArgs<ExtArgs>
    distributionSession?: boolean | Campaign$distributionSessionArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      rfps: Prisma.$RFPPayload<ExtArgs>[]
      partnerAssociations: Prisma.$CampaignPartnerPayload<ExtArgs>[]
      distributionSession: Prisma.$DistributionSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brandId: string
      objectives: Prisma.JsonValue
      budget: Prisma.JsonValue
      status: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rfps<T extends Campaign$rfpsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$rfpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "findMany"> | Null>
    partnerAssociations<T extends Campaign$partnerAssociationsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$partnerAssociationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findMany"> | Null>
    distributionSession<T extends Campaign$distributionSessionArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$distributionSessionArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly brandId: FieldRef<"Campaign", 'String'>
    readonly objectives: FieldRef<"Campaign", 'Json'>
    readonly budget: FieldRef<"Campaign", 'Json'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.rfps
   */
  export type Campaign$rfpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    where?: RFPWhereInput
    orderBy?: RFPOrderByWithRelationInput | RFPOrderByWithRelationInput[]
    cursor?: RFPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFPScalarFieldEnum | RFPScalarFieldEnum[]
  }

  /**
   * Campaign.partnerAssociations
   */
  export type Campaign$partnerAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    where?: CampaignPartnerWhereInput
    orderBy?: CampaignPartnerOrderByWithRelationInput | CampaignPartnerOrderByWithRelationInput[]
    cursor?: CampaignPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignPartnerScalarFieldEnum | CampaignPartnerScalarFieldEnum[]
  }

  /**
   * Campaign.distributionSession
   */
  export type Campaign$distributionSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    where?: DistributionSessionWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model RFP
   */

  export type AggregateRFP = {
    _count: RFPCountAggregateOutputType | null
    _min: RFPMinAggregateOutputType | null
    _max: RFPMaxAggregateOutputType | null
  }

  export type RFPMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    status: string | null
    requestedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RFPMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    status: string | null
    requestedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RFPCountAggregateOutputType = {
    id: number
    campaignId: number
    partners: number
    status: number
    requestedAt: number
    responses: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RFPMinAggregateInputType = {
    id?: true
    campaignId?: true
    status?: true
    requestedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RFPMaxAggregateInputType = {
    id?: true
    campaignId?: true
    status?: true
    requestedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RFPCountAggregateInputType = {
    id?: true
    campaignId?: true
    partners?: true
    status?: true
    requestedAt?: true
    responses?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RFPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFP to aggregate.
     */
    where?: RFPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFPS to fetch.
     */
    orderBy?: RFPOrderByWithRelationInput | RFPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RFPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RFPS
    **/
    _count?: true | RFPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RFPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RFPMaxAggregateInputType
  }

  export type GetRFPAggregateType<T extends RFPAggregateArgs> = {
        [P in keyof T & keyof AggregateRFP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRFP[P]>
      : GetScalarType<T[P], AggregateRFP[P]>
  }




  export type RFPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFPWhereInput
    orderBy?: RFPOrderByWithAggregationInput | RFPOrderByWithAggregationInput[]
    by: RFPScalarFieldEnum[] | RFPScalarFieldEnum
    having?: RFPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RFPCountAggregateInputType | true
    _min?: RFPMinAggregateInputType
    _max?: RFPMaxAggregateInputType
  }

  export type RFPGroupByOutputType = {
    id: string
    campaignId: string
    partners: JsonValue
    status: string
    requestedAt: Date
    responses: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: RFPCountAggregateOutputType | null
    _min: RFPMinAggregateOutputType | null
    _max: RFPMaxAggregateOutputType | null
  }

  type GetRFPGroupByPayload<T extends RFPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RFPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RFPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RFPGroupByOutputType[P]>
            : GetScalarType<T[P], RFPGroupByOutputType[P]>
        }
      >
    >


  export type RFPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    partners?: boolean
    status?: boolean
    requestedAt?: boolean
    responses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFP"]>

  export type RFPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    partners?: boolean
    status?: boolean
    requestedAt?: boolean
    responses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFP"]>

  export type RFPSelectScalar = {
    id?: boolean
    campaignId?: boolean
    partners?: boolean
    status?: boolean
    requestedAt?: boolean
    responses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RFPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type RFPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $RFPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RFP"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      partners: Prisma.JsonValue
      status: string
      requestedAt: Date
      responses: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rFP"]>
    composites: {}
  }

  type RFPGetPayload<S extends boolean | null | undefined | RFPDefaultArgs> = $Result.GetResult<Prisma.$RFPPayload, S>

  type RFPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RFPFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RFPCountAggregateInputType | true
    }

  export interface RFPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RFP'], meta: { name: 'RFP' } }
    /**
     * Find zero or one RFP that matches the filter.
     * @param {RFPFindUniqueArgs} args - Arguments to find a RFP
     * @example
     * // Get one RFP
     * const rFP = await prisma.rFP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RFPFindUniqueArgs>(args: SelectSubset<T, RFPFindUniqueArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RFP that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RFPFindUniqueOrThrowArgs} args - Arguments to find a RFP
     * @example
     * // Get one RFP
     * const rFP = await prisma.rFP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RFPFindUniqueOrThrowArgs>(args: SelectSubset<T, RFPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RFP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPFindFirstArgs} args - Arguments to find a RFP
     * @example
     * // Get one RFP
     * const rFP = await prisma.rFP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RFPFindFirstArgs>(args?: SelectSubset<T, RFPFindFirstArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RFP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPFindFirstOrThrowArgs} args - Arguments to find a RFP
     * @example
     * // Get one RFP
     * const rFP = await prisma.rFP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RFPFindFirstOrThrowArgs>(args?: SelectSubset<T, RFPFindFirstOrThrowArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RFPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RFPS
     * const rFPS = await prisma.rFP.findMany()
     * 
     * // Get first 10 RFPS
     * const rFPS = await prisma.rFP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rFPWithIdOnly = await prisma.rFP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RFPFindManyArgs>(args?: SelectSubset<T, RFPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RFP.
     * @param {RFPCreateArgs} args - Arguments to create a RFP.
     * @example
     * // Create one RFP
     * const RFP = await prisma.rFP.create({
     *   data: {
     *     // ... data to create a RFP
     *   }
     * })
     * 
     */
    create<T extends RFPCreateArgs>(args: SelectSubset<T, RFPCreateArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RFPS.
     * @param {RFPCreateManyArgs} args - Arguments to create many RFPS.
     * @example
     * // Create many RFPS
     * const rFP = await prisma.rFP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RFPCreateManyArgs>(args?: SelectSubset<T, RFPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RFPS and returns the data saved in the database.
     * @param {RFPCreateManyAndReturnArgs} args - Arguments to create many RFPS.
     * @example
     * // Create many RFPS
     * const rFP = await prisma.rFP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RFPS and only return the `id`
     * const rFPWithIdOnly = await prisma.rFP.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RFPCreateManyAndReturnArgs>(args?: SelectSubset<T, RFPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RFP.
     * @param {RFPDeleteArgs} args - Arguments to delete one RFP.
     * @example
     * // Delete one RFP
     * const RFP = await prisma.rFP.delete({
     *   where: {
     *     // ... filter to delete one RFP
     *   }
     * })
     * 
     */
    delete<T extends RFPDeleteArgs>(args: SelectSubset<T, RFPDeleteArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RFP.
     * @param {RFPUpdateArgs} args - Arguments to update one RFP.
     * @example
     * // Update one RFP
     * const rFP = await prisma.rFP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RFPUpdateArgs>(args: SelectSubset<T, RFPUpdateArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RFPS.
     * @param {RFPDeleteManyArgs} args - Arguments to filter RFPS to delete.
     * @example
     * // Delete a few RFPS
     * const { count } = await prisma.rFP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RFPDeleteManyArgs>(args?: SelectSubset<T, RFPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RFPS
     * const rFP = await prisma.rFP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RFPUpdateManyArgs>(args: SelectSubset<T, RFPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RFP.
     * @param {RFPUpsertArgs} args - Arguments to update or create a RFP.
     * @example
     * // Update or create a RFP
     * const rFP = await prisma.rFP.upsert({
     *   create: {
     *     // ... data to create a RFP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RFP we want to update
     *   }
     * })
     */
    upsert<T extends RFPUpsertArgs>(args: SelectSubset<T, RFPUpsertArgs<ExtArgs>>): Prisma__RFPClient<$Result.GetResult<Prisma.$RFPPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RFPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPCountArgs} args - Arguments to filter RFPS to count.
     * @example
     * // Count the number of RFPS
     * const count = await prisma.rFP.count({
     *   where: {
     *     // ... the filter for the RFPS we want to count
     *   }
     * })
    **/
    count<T extends RFPCountArgs>(
      args?: Subset<T, RFPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RFPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RFP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RFPAggregateArgs>(args: Subset<T, RFPAggregateArgs>): Prisma.PrismaPromise<GetRFPAggregateType<T>>

    /**
     * Group by RFP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RFPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RFPGroupByArgs['orderBy'] }
        : { orderBy?: RFPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RFPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRFPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RFP model
   */
  readonly fields: RFPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RFP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RFPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RFP model
   */ 
  interface RFPFieldRefs {
    readonly id: FieldRef<"RFP", 'String'>
    readonly campaignId: FieldRef<"RFP", 'String'>
    readonly partners: FieldRef<"RFP", 'Json'>
    readonly status: FieldRef<"RFP", 'String'>
    readonly requestedAt: FieldRef<"RFP", 'DateTime'>
    readonly responses: FieldRef<"RFP", 'Json'>
    readonly createdAt: FieldRef<"RFP", 'DateTime'>
    readonly updatedAt: FieldRef<"RFP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RFP findUnique
   */
  export type RFPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * Filter, which RFP to fetch.
     */
    where: RFPWhereUniqueInput
  }

  /**
   * RFP findUniqueOrThrow
   */
  export type RFPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * Filter, which RFP to fetch.
     */
    where: RFPWhereUniqueInput
  }

  /**
   * RFP findFirst
   */
  export type RFPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * Filter, which RFP to fetch.
     */
    where?: RFPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFPS to fetch.
     */
    orderBy?: RFPOrderByWithRelationInput | RFPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFPS.
     */
    cursor?: RFPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFPS.
     */
    distinct?: RFPScalarFieldEnum | RFPScalarFieldEnum[]
  }

  /**
   * RFP findFirstOrThrow
   */
  export type RFPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * Filter, which RFP to fetch.
     */
    where?: RFPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFPS to fetch.
     */
    orderBy?: RFPOrderByWithRelationInput | RFPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFPS.
     */
    cursor?: RFPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFPS.
     */
    distinct?: RFPScalarFieldEnum | RFPScalarFieldEnum[]
  }

  /**
   * RFP findMany
   */
  export type RFPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * Filter, which RFPS to fetch.
     */
    where?: RFPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFPS to fetch.
     */
    orderBy?: RFPOrderByWithRelationInput | RFPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RFPS.
     */
    cursor?: RFPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFPS.
     */
    skip?: number
    distinct?: RFPScalarFieldEnum | RFPScalarFieldEnum[]
  }

  /**
   * RFP create
   */
  export type RFPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * The data needed to create a RFP.
     */
    data: XOR<RFPCreateInput, RFPUncheckedCreateInput>
  }

  /**
   * RFP createMany
   */
  export type RFPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RFPS.
     */
    data: RFPCreateManyInput | RFPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RFP createManyAndReturn
   */
  export type RFPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RFPS.
     */
    data: RFPCreateManyInput | RFPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RFP update
   */
  export type RFPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * The data needed to update a RFP.
     */
    data: XOR<RFPUpdateInput, RFPUncheckedUpdateInput>
    /**
     * Choose, which RFP to update.
     */
    where: RFPWhereUniqueInput
  }

  /**
   * RFP updateMany
   */
  export type RFPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RFPS.
     */
    data: XOR<RFPUpdateManyMutationInput, RFPUncheckedUpdateManyInput>
    /**
     * Filter which RFPS to update
     */
    where?: RFPWhereInput
  }

  /**
   * RFP upsert
   */
  export type RFPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * The filter to search for the RFP to update in case it exists.
     */
    where: RFPWhereUniqueInput
    /**
     * In case the RFP found by the `where` argument doesn't exist, create a new RFP with this data.
     */
    create: XOR<RFPCreateInput, RFPUncheckedCreateInput>
    /**
     * In case the RFP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RFPUpdateInput, RFPUncheckedUpdateInput>
  }

  /**
   * RFP delete
   */
  export type RFPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
    /**
     * Filter which RFP to delete.
     */
    where: RFPWhereUniqueInput
  }

  /**
   * RFP deleteMany
   */
  export type RFPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFPS to delete
     */
    where?: RFPWhereInput
  }

  /**
   * RFP without action
   */
  export type RFPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFP
     */
    select?: RFPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFPInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    type: $Enums.PartnerType | null
    status: $Enums.PartnerStatus | null
    onboardingStatus: $Enums.OnboardingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    type: $Enums.PartnerType | null
    status: $Enums.PartnerStatus | null
    onboardingStatus: $Enums.OnboardingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    type: number
    status: number
    companyInfo: number
    contactInfo: number
    apiCredentials: number
    targetingOptions: number
    measurementCapabilities: number
    onboardingStatus: number
    onboardingSteps: number
    pricingInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    type?: true
    status?: true
    onboardingStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    type?: true
    status?: true
    onboardingStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    type?: true
    status?: true
    companyInfo?: true
    contactInfo?: true
    apiCredentials?: true
    targetingOptions?: true
    measurementCapabilities?: true
    onboardingStatus?: true
    onboardingSteps?: true
    pricingInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status: $Enums.PartnerStatus
    companyInfo: JsonValue
    contactInfo: JsonValue
    apiCredentials: JsonValue | null
    targetingOptions: JsonValue
    measurementCapabilities: JsonValue
    onboardingStatus: $Enums.OnboardingStatus
    onboardingSteps: JsonValue
    pricingInfo: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    type?: boolean
    status?: boolean
    companyInfo?: boolean
    contactInfo?: boolean
    apiCredentials?: boolean
    targetingOptions?: boolean
    measurementCapabilities?: boolean
    onboardingStatus?: boolean
    onboardingSteps?: boolean
    pricingInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capabilities?: boolean | Partner$capabilitiesArgs<ExtArgs>
    creativeSpecs?: boolean | Partner$creativeSpecsArgs<ExtArgs>
    healthMetrics?: boolean | Partner$healthMetricsArgs<ExtArgs>
    campaignAssociations?: boolean | Partner$campaignAssociationsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    type?: boolean
    status?: boolean
    companyInfo?: boolean
    contactInfo?: boolean
    apiCredentials?: boolean
    targetingOptions?: boolean
    measurementCapabilities?: boolean
    onboardingStatus?: boolean
    onboardingSteps?: boolean
    pricingInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    type?: boolean
    status?: boolean
    companyInfo?: boolean
    contactInfo?: boolean
    apiCredentials?: boolean
    targetingOptions?: boolean
    measurementCapabilities?: boolean
    onboardingStatus?: boolean
    onboardingSteps?: boolean
    pricingInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capabilities?: boolean | Partner$capabilitiesArgs<ExtArgs>
    creativeSpecs?: boolean | Partner$creativeSpecsArgs<ExtArgs>
    healthMetrics?: boolean | Partner$healthMetricsArgs<ExtArgs>
    campaignAssociations?: boolean | Partner$campaignAssociationsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      capabilities: Prisma.$PartnerCapabilityPayload<ExtArgs>[]
      creativeSpecs: Prisma.$CreativeSpecPayload<ExtArgs>[]
      healthMetrics: Prisma.$PartnerHealthMetricPayload<ExtArgs>[]
      campaignAssociations: Prisma.$CampaignPartnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      type: $Enums.PartnerType
      status: $Enums.PartnerStatus
      companyInfo: Prisma.JsonValue
      contactInfo: Prisma.JsonValue
      apiCredentials: Prisma.JsonValue | null
      targetingOptions: Prisma.JsonValue
      measurementCapabilities: Prisma.JsonValue
      onboardingStatus: $Enums.OnboardingStatus
      onboardingSteps: Prisma.JsonValue
      pricingInfo: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capabilities<T extends Partner$capabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$capabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "findMany"> | Null>
    creativeSpecs<T extends Partner$creativeSpecsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$creativeSpecsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "findMany"> | Null>
    healthMetrics<T extends Partner$healthMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$healthMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "findMany"> | Null>
    campaignAssociations<T extends Partner$campaignAssociationsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$campaignAssociationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */ 
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly displayName: FieldRef<"Partner", 'String'>
    readonly type: FieldRef<"Partner", 'PartnerType'>
    readonly status: FieldRef<"Partner", 'PartnerStatus'>
    readonly companyInfo: FieldRef<"Partner", 'Json'>
    readonly contactInfo: FieldRef<"Partner", 'Json'>
    readonly apiCredentials: FieldRef<"Partner", 'Json'>
    readonly targetingOptions: FieldRef<"Partner", 'Json'>
    readonly measurementCapabilities: FieldRef<"Partner", 'Json'>
    readonly onboardingStatus: FieldRef<"Partner", 'OnboardingStatus'>
    readonly onboardingSteps: FieldRef<"Partner", 'Json'>
    readonly pricingInfo: FieldRef<"Partner", 'Json'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner.capabilities
   */
  export type Partner$capabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    where?: PartnerCapabilityWhereInput
    orderBy?: PartnerCapabilityOrderByWithRelationInput | PartnerCapabilityOrderByWithRelationInput[]
    cursor?: PartnerCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerCapabilityScalarFieldEnum | PartnerCapabilityScalarFieldEnum[]
  }

  /**
   * Partner.creativeSpecs
   */
  export type Partner$creativeSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    where?: CreativeSpecWhereInput
    orderBy?: CreativeSpecOrderByWithRelationInput | CreativeSpecOrderByWithRelationInput[]
    cursor?: CreativeSpecWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreativeSpecScalarFieldEnum | CreativeSpecScalarFieldEnum[]
  }

  /**
   * Partner.healthMetrics
   */
  export type Partner$healthMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    where?: PartnerHealthMetricWhereInput
    orderBy?: PartnerHealthMetricOrderByWithRelationInput | PartnerHealthMetricOrderByWithRelationInput[]
    cursor?: PartnerHealthMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerHealthMetricScalarFieldEnum | PartnerHealthMetricScalarFieldEnum[]
  }

  /**
   * Partner.campaignAssociations
   */
  export type Partner$campaignAssociationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    where?: CampaignPartnerWhereInput
    orderBy?: CampaignPartnerOrderByWithRelationInput | CampaignPartnerOrderByWithRelationInput[]
    cursor?: CampaignPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignPartnerScalarFieldEnum | CampaignPartnerScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model PartnerCapability
   */

  export type AggregatePartnerCapability = {
    _count: PartnerCapabilityCountAggregateOutputType | null
    _min: PartnerCapabilityMinAggregateOutputType | null
    _max: PartnerCapabilityMaxAggregateOutputType | null
  }

  export type PartnerCapabilityMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    name: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    lastUpdated: Date | null
    sourceType: $Enums.CapabilitySourceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCapabilityMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    name: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    lastUpdated: Date | null
    sourceType: $Enums.CapabilitySourceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCapabilityCountAggregateOutputType = {
    id: number
    partnerId: number
    name: number
    description: number
    category: number
    details: number
    isActive: number
    lastUpdated: number
    sourceType: number
    sourceData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerCapabilityMinAggregateInputType = {
    id?: true
    partnerId?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    lastUpdated?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCapabilityMaxAggregateInputType = {
    id?: true
    partnerId?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    lastUpdated?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCapabilityCountAggregateInputType = {
    id?: true
    partnerId?: true
    name?: true
    description?: true
    category?: true
    details?: true
    isActive?: true
    lastUpdated?: true
    sourceType?: true
    sourceData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerCapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerCapability to aggregate.
     */
    where?: PartnerCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerCapabilities to fetch.
     */
    orderBy?: PartnerCapabilityOrderByWithRelationInput | PartnerCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerCapabilities
    **/
    _count?: true | PartnerCapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerCapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerCapabilityMaxAggregateInputType
  }

  export type GetPartnerCapabilityAggregateType<T extends PartnerCapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerCapability[P]>
      : GetScalarType<T[P], AggregatePartnerCapability[P]>
  }




  export type PartnerCapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerCapabilityWhereInput
    orderBy?: PartnerCapabilityOrderByWithAggregationInput | PartnerCapabilityOrderByWithAggregationInput[]
    by: PartnerCapabilityScalarFieldEnum[] | PartnerCapabilityScalarFieldEnum
    having?: PartnerCapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCapabilityCountAggregateInputType | true
    _min?: PartnerCapabilityMinAggregateInputType
    _max?: PartnerCapabilityMaxAggregateInputType
  }

  export type PartnerCapabilityGroupByOutputType = {
    id: string
    partnerId: string
    name: string
    description: string | null
    category: string
    details: JsonValue
    isActive: boolean
    lastUpdated: Date
    sourceType: $Enums.CapabilitySourceType
    sourceData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PartnerCapabilityCountAggregateOutputType | null
    _min: PartnerCapabilityMinAggregateOutputType | null
    _max: PartnerCapabilityMaxAggregateOutputType | null
  }

  type GetPartnerCapabilityGroupByPayload<T extends PartnerCapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerCapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerCapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerCapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerCapabilityGroupByOutputType[P]>
        }
      >
    >


  export type PartnerCapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    details?: boolean
    isActive?: boolean
    lastUpdated?: boolean
    sourceType?: boolean
    sourceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerCapability"]>

  export type PartnerCapabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    details?: boolean
    isActive?: boolean
    lastUpdated?: boolean
    sourceType?: boolean
    sourceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerCapability"]>

  export type PartnerCapabilitySelectScalar = {
    id?: boolean
    partnerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    details?: boolean
    isActive?: boolean
    lastUpdated?: boolean
    sourceType?: boolean
    sourceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerCapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerCapabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerCapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerCapability"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      name: string
      description: string | null
      category: string
      details: Prisma.JsonValue
      isActive: boolean
      lastUpdated: Date
      sourceType: $Enums.CapabilitySourceType
      sourceData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partnerCapability"]>
    composites: {}
  }

  type PartnerCapabilityGetPayload<S extends boolean | null | undefined | PartnerCapabilityDefaultArgs> = $Result.GetResult<Prisma.$PartnerCapabilityPayload, S>

  type PartnerCapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartnerCapabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartnerCapabilityCountAggregateInputType | true
    }

  export interface PartnerCapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerCapability'], meta: { name: 'PartnerCapability' } }
    /**
     * Find zero or one PartnerCapability that matches the filter.
     * @param {PartnerCapabilityFindUniqueArgs} args - Arguments to find a PartnerCapability
     * @example
     * // Get one PartnerCapability
     * const partnerCapability = await prisma.partnerCapability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerCapabilityFindUniqueArgs>(args: SelectSubset<T, PartnerCapabilityFindUniqueArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PartnerCapability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartnerCapabilityFindUniqueOrThrowArgs} args - Arguments to find a PartnerCapability
     * @example
     * // Get one PartnerCapability
     * const partnerCapability = await prisma.partnerCapability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerCapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerCapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PartnerCapability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityFindFirstArgs} args - Arguments to find a PartnerCapability
     * @example
     * // Get one PartnerCapability
     * const partnerCapability = await prisma.partnerCapability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerCapabilityFindFirstArgs>(args?: SelectSubset<T, PartnerCapabilityFindFirstArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PartnerCapability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityFindFirstOrThrowArgs} args - Arguments to find a PartnerCapability
     * @example
     * // Get one PartnerCapability
     * const partnerCapability = await prisma.partnerCapability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerCapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerCapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PartnerCapabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerCapabilities
     * const partnerCapabilities = await prisma.partnerCapability.findMany()
     * 
     * // Get first 10 PartnerCapabilities
     * const partnerCapabilities = await prisma.partnerCapability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerCapabilityWithIdOnly = await prisma.partnerCapability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerCapabilityFindManyArgs>(args?: SelectSubset<T, PartnerCapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PartnerCapability.
     * @param {PartnerCapabilityCreateArgs} args - Arguments to create a PartnerCapability.
     * @example
     * // Create one PartnerCapability
     * const PartnerCapability = await prisma.partnerCapability.create({
     *   data: {
     *     // ... data to create a PartnerCapability
     *   }
     * })
     * 
     */
    create<T extends PartnerCapabilityCreateArgs>(args: SelectSubset<T, PartnerCapabilityCreateArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PartnerCapabilities.
     * @param {PartnerCapabilityCreateManyArgs} args - Arguments to create many PartnerCapabilities.
     * @example
     * // Create many PartnerCapabilities
     * const partnerCapability = await prisma.partnerCapability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCapabilityCreateManyArgs>(args?: SelectSubset<T, PartnerCapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerCapabilities and returns the data saved in the database.
     * @param {PartnerCapabilityCreateManyAndReturnArgs} args - Arguments to create many PartnerCapabilities.
     * @example
     * // Create many PartnerCapabilities
     * const partnerCapability = await prisma.partnerCapability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerCapabilities and only return the `id`
     * const partnerCapabilityWithIdOnly = await prisma.partnerCapability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCapabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCapabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PartnerCapability.
     * @param {PartnerCapabilityDeleteArgs} args - Arguments to delete one PartnerCapability.
     * @example
     * // Delete one PartnerCapability
     * const PartnerCapability = await prisma.partnerCapability.delete({
     *   where: {
     *     // ... filter to delete one PartnerCapability
     *   }
     * })
     * 
     */
    delete<T extends PartnerCapabilityDeleteArgs>(args: SelectSubset<T, PartnerCapabilityDeleteArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PartnerCapability.
     * @param {PartnerCapabilityUpdateArgs} args - Arguments to update one PartnerCapability.
     * @example
     * // Update one PartnerCapability
     * const partnerCapability = await prisma.partnerCapability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerCapabilityUpdateArgs>(args: SelectSubset<T, PartnerCapabilityUpdateArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PartnerCapabilities.
     * @param {PartnerCapabilityDeleteManyArgs} args - Arguments to filter PartnerCapabilities to delete.
     * @example
     * // Delete a few PartnerCapabilities
     * const { count } = await prisma.partnerCapability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerCapabilityDeleteManyArgs>(args?: SelectSubset<T, PartnerCapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerCapabilities
     * const partnerCapability = await prisma.partnerCapability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerCapabilityUpdateManyArgs>(args: SelectSubset<T, PartnerCapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartnerCapability.
     * @param {PartnerCapabilityUpsertArgs} args - Arguments to update or create a PartnerCapability.
     * @example
     * // Update or create a PartnerCapability
     * const partnerCapability = await prisma.partnerCapability.upsert({
     *   create: {
     *     // ... data to create a PartnerCapability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerCapability we want to update
     *   }
     * })
     */
    upsert<T extends PartnerCapabilityUpsertArgs>(args: SelectSubset<T, PartnerCapabilityUpsertArgs<ExtArgs>>): Prisma__PartnerCapabilityClient<$Result.GetResult<Prisma.$PartnerCapabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PartnerCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityCountArgs} args - Arguments to filter PartnerCapabilities to count.
     * @example
     * // Count the number of PartnerCapabilities
     * const count = await prisma.partnerCapability.count({
     *   where: {
     *     // ... the filter for the PartnerCapabilities we want to count
     *   }
     * })
    **/
    count<T extends PartnerCapabilityCountArgs>(
      args?: Subset<T, PartnerCapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerCapabilityAggregateArgs>(args: Subset<T, PartnerCapabilityAggregateArgs>): Prisma.PrismaPromise<GetPartnerCapabilityAggregateType<T>>

    /**
     * Group by PartnerCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerCapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerCapabilityGroupByArgs['orderBy'] }
        : { orderBy?: PartnerCapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerCapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerCapability model
   */
  readonly fields: PartnerCapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerCapability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerCapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerCapability model
   */ 
  interface PartnerCapabilityFieldRefs {
    readonly id: FieldRef<"PartnerCapability", 'String'>
    readonly partnerId: FieldRef<"PartnerCapability", 'String'>
    readonly name: FieldRef<"PartnerCapability", 'String'>
    readonly description: FieldRef<"PartnerCapability", 'String'>
    readonly category: FieldRef<"PartnerCapability", 'String'>
    readonly details: FieldRef<"PartnerCapability", 'Json'>
    readonly isActive: FieldRef<"PartnerCapability", 'Boolean'>
    readonly lastUpdated: FieldRef<"PartnerCapability", 'DateTime'>
    readonly sourceType: FieldRef<"PartnerCapability", 'CapabilitySourceType'>
    readonly sourceData: FieldRef<"PartnerCapability", 'Json'>
    readonly createdAt: FieldRef<"PartnerCapability", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerCapability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerCapability findUnique
   */
  export type PartnerCapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PartnerCapability to fetch.
     */
    where: PartnerCapabilityWhereUniqueInput
  }

  /**
   * PartnerCapability findUniqueOrThrow
   */
  export type PartnerCapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PartnerCapability to fetch.
     */
    where: PartnerCapabilityWhereUniqueInput
  }

  /**
   * PartnerCapability findFirst
   */
  export type PartnerCapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PartnerCapability to fetch.
     */
    where?: PartnerCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerCapabilities to fetch.
     */
    orderBy?: PartnerCapabilityOrderByWithRelationInput | PartnerCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerCapabilities.
     */
    cursor?: PartnerCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerCapabilities.
     */
    distinct?: PartnerCapabilityScalarFieldEnum | PartnerCapabilityScalarFieldEnum[]
  }

  /**
   * PartnerCapability findFirstOrThrow
   */
  export type PartnerCapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PartnerCapability to fetch.
     */
    where?: PartnerCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerCapabilities to fetch.
     */
    orderBy?: PartnerCapabilityOrderByWithRelationInput | PartnerCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerCapabilities.
     */
    cursor?: PartnerCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerCapabilities.
     */
    distinct?: PartnerCapabilityScalarFieldEnum | PartnerCapabilityScalarFieldEnum[]
  }

  /**
   * PartnerCapability findMany
   */
  export type PartnerCapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which PartnerCapabilities to fetch.
     */
    where?: PartnerCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerCapabilities to fetch.
     */
    orderBy?: PartnerCapabilityOrderByWithRelationInput | PartnerCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerCapabilities.
     */
    cursor?: PartnerCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerCapabilities.
     */
    skip?: number
    distinct?: PartnerCapabilityScalarFieldEnum | PartnerCapabilityScalarFieldEnum[]
  }

  /**
   * PartnerCapability create
   */
  export type PartnerCapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerCapability.
     */
    data: XOR<PartnerCapabilityCreateInput, PartnerCapabilityUncheckedCreateInput>
  }

  /**
   * PartnerCapability createMany
   */
  export type PartnerCapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerCapabilities.
     */
    data: PartnerCapabilityCreateManyInput | PartnerCapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartnerCapability createManyAndReturn
   */
  export type PartnerCapabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PartnerCapabilities.
     */
    data: PartnerCapabilityCreateManyInput | PartnerCapabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerCapability update
   */
  export type PartnerCapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerCapability.
     */
    data: XOR<PartnerCapabilityUpdateInput, PartnerCapabilityUncheckedUpdateInput>
    /**
     * Choose, which PartnerCapability to update.
     */
    where: PartnerCapabilityWhereUniqueInput
  }

  /**
   * PartnerCapability updateMany
   */
  export type PartnerCapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerCapabilities.
     */
    data: XOR<PartnerCapabilityUpdateManyMutationInput, PartnerCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which PartnerCapabilities to update
     */
    where?: PartnerCapabilityWhereInput
  }

  /**
   * PartnerCapability upsert
   */
  export type PartnerCapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerCapability to update in case it exists.
     */
    where: PartnerCapabilityWhereUniqueInput
    /**
     * In case the PartnerCapability found by the `where` argument doesn't exist, create a new PartnerCapability with this data.
     */
    create: XOR<PartnerCapabilityCreateInput, PartnerCapabilityUncheckedCreateInput>
    /**
     * In case the PartnerCapability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerCapabilityUpdateInput, PartnerCapabilityUncheckedUpdateInput>
  }

  /**
   * PartnerCapability delete
   */
  export type PartnerCapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
    /**
     * Filter which PartnerCapability to delete.
     */
    where: PartnerCapabilityWhereUniqueInput
  }

  /**
   * PartnerCapability deleteMany
   */
  export type PartnerCapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerCapabilities to delete
     */
    where?: PartnerCapabilityWhereInput
  }

  /**
   * PartnerCapability without action
   */
  export type PartnerCapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCapability
     */
    select?: PartnerCapabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerCapabilityInclude<ExtArgs> | null
  }


  /**
   * Model CreativeSpec
   */

  export type AggregateCreativeSpec = {
    _count: CreativeSpecCountAggregateOutputType | null
    _avg: CreativeSpecAvgAggregateOutputType | null
    _sum: CreativeSpecSumAggregateOutputType | null
    _min: CreativeSpecMinAggregateOutputType | null
    _max: CreativeSpecMaxAggregateOutputType | null
  }

  export type CreativeSpecAvgAggregateOutputType = {
    maxFileSize: number | null
  }

  export type CreativeSpecSumAggregateOutputType = {
    maxFileSize: number | null
  }

  export type CreativeSpecMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    format: string | null
    fileType: string | null
    maxFileSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreativeSpecMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    format: string | null
    fileType: string | null
    maxFileSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreativeSpecCountAggregateOutputType = {
    id: number
    partnerId: number
    format: number
    dimensions: number
    fileType: number
    maxFileSize: number
    requirements: number
    examples: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreativeSpecAvgAggregateInputType = {
    maxFileSize?: true
  }

  export type CreativeSpecSumAggregateInputType = {
    maxFileSize?: true
  }

  export type CreativeSpecMinAggregateInputType = {
    id?: true
    partnerId?: true
    format?: true
    fileType?: true
    maxFileSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreativeSpecMaxAggregateInputType = {
    id?: true
    partnerId?: true
    format?: true
    fileType?: true
    maxFileSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreativeSpecCountAggregateInputType = {
    id?: true
    partnerId?: true
    format?: true
    dimensions?: true
    fileType?: true
    maxFileSize?: true
    requirements?: true
    examples?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreativeSpecAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreativeSpec to aggregate.
     */
    where?: CreativeSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeSpecs to fetch.
     */
    orderBy?: CreativeSpecOrderByWithRelationInput | CreativeSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreativeSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreativeSpecs
    **/
    _count?: true | CreativeSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreativeSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreativeSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreativeSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreativeSpecMaxAggregateInputType
  }

  export type GetCreativeSpecAggregateType<T extends CreativeSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateCreativeSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreativeSpec[P]>
      : GetScalarType<T[P], AggregateCreativeSpec[P]>
  }




  export type CreativeSpecGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeSpecWhereInput
    orderBy?: CreativeSpecOrderByWithAggregationInput | CreativeSpecOrderByWithAggregationInput[]
    by: CreativeSpecScalarFieldEnum[] | CreativeSpecScalarFieldEnum
    having?: CreativeSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreativeSpecCountAggregateInputType | true
    _avg?: CreativeSpecAvgAggregateInputType
    _sum?: CreativeSpecSumAggregateInputType
    _min?: CreativeSpecMinAggregateInputType
    _max?: CreativeSpecMaxAggregateInputType
  }

  export type CreativeSpecGroupByOutputType = {
    id: string
    partnerId: string
    format: string
    dimensions: JsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonValue
    examples: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CreativeSpecCountAggregateOutputType | null
    _avg: CreativeSpecAvgAggregateOutputType | null
    _sum: CreativeSpecSumAggregateOutputType | null
    _min: CreativeSpecMinAggregateOutputType | null
    _max: CreativeSpecMaxAggregateOutputType | null
  }

  type GetCreativeSpecGroupByPayload<T extends CreativeSpecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreativeSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreativeSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreativeSpecGroupByOutputType[P]>
            : GetScalarType<T[P], CreativeSpecGroupByOutputType[P]>
        }
      >
    >


  export type CreativeSpecSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    format?: boolean
    dimensions?: boolean
    fileType?: boolean
    maxFileSize?: boolean
    requirements?: boolean
    examples?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creativeSpec"]>

  export type CreativeSpecSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    format?: boolean
    dimensions?: boolean
    fileType?: boolean
    maxFileSize?: boolean
    requirements?: boolean
    examples?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creativeSpec"]>

  export type CreativeSpecSelectScalar = {
    id?: boolean
    partnerId?: boolean
    format?: boolean
    dimensions?: boolean
    fileType?: boolean
    maxFileSize?: boolean
    requirements?: boolean
    examples?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreativeSpecInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type CreativeSpecIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $CreativeSpecPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreativeSpec"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      format: string
      dimensions: Prisma.JsonValue
      fileType: string
      maxFileSize: number
      requirements: Prisma.JsonValue
      examples: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creativeSpec"]>
    composites: {}
  }

  type CreativeSpecGetPayload<S extends boolean | null | undefined | CreativeSpecDefaultArgs> = $Result.GetResult<Prisma.$CreativeSpecPayload, S>

  type CreativeSpecCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreativeSpecFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreativeSpecCountAggregateInputType | true
    }

  export interface CreativeSpecDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreativeSpec'], meta: { name: 'CreativeSpec' } }
    /**
     * Find zero or one CreativeSpec that matches the filter.
     * @param {CreativeSpecFindUniqueArgs} args - Arguments to find a CreativeSpec
     * @example
     * // Get one CreativeSpec
     * const creativeSpec = await prisma.creativeSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreativeSpecFindUniqueArgs>(args: SelectSubset<T, CreativeSpecFindUniqueArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreativeSpec that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreativeSpecFindUniqueOrThrowArgs} args - Arguments to find a CreativeSpec
     * @example
     * // Get one CreativeSpec
     * const creativeSpec = await prisma.creativeSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreativeSpecFindUniqueOrThrowArgs>(args: SelectSubset<T, CreativeSpecFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreativeSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecFindFirstArgs} args - Arguments to find a CreativeSpec
     * @example
     * // Get one CreativeSpec
     * const creativeSpec = await prisma.creativeSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreativeSpecFindFirstArgs>(args?: SelectSubset<T, CreativeSpecFindFirstArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreativeSpec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecFindFirstOrThrowArgs} args - Arguments to find a CreativeSpec
     * @example
     * // Get one CreativeSpec
     * const creativeSpec = await prisma.creativeSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreativeSpecFindFirstOrThrowArgs>(args?: SelectSubset<T, CreativeSpecFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreativeSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreativeSpecs
     * const creativeSpecs = await prisma.creativeSpec.findMany()
     * 
     * // Get first 10 CreativeSpecs
     * const creativeSpecs = await prisma.creativeSpec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creativeSpecWithIdOnly = await prisma.creativeSpec.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreativeSpecFindManyArgs>(args?: SelectSubset<T, CreativeSpecFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreativeSpec.
     * @param {CreativeSpecCreateArgs} args - Arguments to create a CreativeSpec.
     * @example
     * // Create one CreativeSpec
     * const CreativeSpec = await prisma.creativeSpec.create({
     *   data: {
     *     // ... data to create a CreativeSpec
     *   }
     * })
     * 
     */
    create<T extends CreativeSpecCreateArgs>(args: SelectSubset<T, CreativeSpecCreateArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreativeSpecs.
     * @param {CreativeSpecCreateManyArgs} args - Arguments to create many CreativeSpecs.
     * @example
     * // Create many CreativeSpecs
     * const creativeSpec = await prisma.creativeSpec.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreativeSpecCreateManyArgs>(args?: SelectSubset<T, CreativeSpecCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreativeSpecs and returns the data saved in the database.
     * @param {CreativeSpecCreateManyAndReturnArgs} args - Arguments to create many CreativeSpecs.
     * @example
     * // Create many CreativeSpecs
     * const creativeSpec = await prisma.creativeSpec.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreativeSpecs and only return the `id`
     * const creativeSpecWithIdOnly = await prisma.creativeSpec.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreativeSpecCreateManyAndReturnArgs>(args?: SelectSubset<T, CreativeSpecCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CreativeSpec.
     * @param {CreativeSpecDeleteArgs} args - Arguments to delete one CreativeSpec.
     * @example
     * // Delete one CreativeSpec
     * const CreativeSpec = await prisma.creativeSpec.delete({
     *   where: {
     *     // ... filter to delete one CreativeSpec
     *   }
     * })
     * 
     */
    delete<T extends CreativeSpecDeleteArgs>(args: SelectSubset<T, CreativeSpecDeleteArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreativeSpec.
     * @param {CreativeSpecUpdateArgs} args - Arguments to update one CreativeSpec.
     * @example
     * // Update one CreativeSpec
     * const creativeSpec = await prisma.creativeSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreativeSpecUpdateArgs>(args: SelectSubset<T, CreativeSpecUpdateArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreativeSpecs.
     * @param {CreativeSpecDeleteManyArgs} args - Arguments to filter CreativeSpecs to delete.
     * @example
     * // Delete a few CreativeSpecs
     * const { count } = await prisma.creativeSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreativeSpecDeleteManyArgs>(args?: SelectSubset<T, CreativeSpecDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreativeSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreativeSpecs
     * const creativeSpec = await prisma.creativeSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreativeSpecUpdateManyArgs>(args: SelectSubset<T, CreativeSpecUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreativeSpec.
     * @param {CreativeSpecUpsertArgs} args - Arguments to update or create a CreativeSpec.
     * @example
     * // Update or create a CreativeSpec
     * const creativeSpec = await prisma.creativeSpec.upsert({
     *   create: {
     *     // ... data to create a CreativeSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreativeSpec we want to update
     *   }
     * })
     */
    upsert<T extends CreativeSpecUpsertArgs>(args: SelectSubset<T, CreativeSpecUpsertArgs<ExtArgs>>): Prisma__CreativeSpecClient<$Result.GetResult<Prisma.$CreativeSpecPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreativeSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecCountArgs} args - Arguments to filter CreativeSpecs to count.
     * @example
     * // Count the number of CreativeSpecs
     * const count = await prisma.creativeSpec.count({
     *   where: {
     *     // ... the filter for the CreativeSpecs we want to count
     *   }
     * })
    **/
    count<T extends CreativeSpecCountArgs>(
      args?: Subset<T, CreativeSpecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreativeSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreativeSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreativeSpecAggregateArgs>(args: Subset<T, CreativeSpecAggregateArgs>): Prisma.PrismaPromise<GetCreativeSpecAggregateType<T>>

    /**
     * Group by CreativeSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreativeSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreativeSpecGroupByArgs['orderBy'] }
        : { orderBy?: CreativeSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreativeSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreativeSpecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreativeSpec model
   */
  readonly fields: CreativeSpecFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreativeSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreativeSpecClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreativeSpec model
   */ 
  interface CreativeSpecFieldRefs {
    readonly id: FieldRef<"CreativeSpec", 'String'>
    readonly partnerId: FieldRef<"CreativeSpec", 'String'>
    readonly format: FieldRef<"CreativeSpec", 'String'>
    readonly dimensions: FieldRef<"CreativeSpec", 'Json'>
    readonly fileType: FieldRef<"CreativeSpec", 'String'>
    readonly maxFileSize: FieldRef<"CreativeSpec", 'Int'>
    readonly requirements: FieldRef<"CreativeSpec", 'Json'>
    readonly examples: FieldRef<"CreativeSpec", 'Json'>
    readonly isActive: FieldRef<"CreativeSpec", 'Boolean'>
    readonly createdAt: FieldRef<"CreativeSpec", 'DateTime'>
    readonly updatedAt: FieldRef<"CreativeSpec", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreativeSpec findUnique
   */
  export type CreativeSpecFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * Filter, which CreativeSpec to fetch.
     */
    where: CreativeSpecWhereUniqueInput
  }

  /**
   * CreativeSpec findUniqueOrThrow
   */
  export type CreativeSpecFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * Filter, which CreativeSpec to fetch.
     */
    where: CreativeSpecWhereUniqueInput
  }

  /**
   * CreativeSpec findFirst
   */
  export type CreativeSpecFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * Filter, which CreativeSpec to fetch.
     */
    where?: CreativeSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeSpecs to fetch.
     */
    orderBy?: CreativeSpecOrderByWithRelationInput | CreativeSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreativeSpecs.
     */
    cursor?: CreativeSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreativeSpecs.
     */
    distinct?: CreativeSpecScalarFieldEnum | CreativeSpecScalarFieldEnum[]
  }

  /**
   * CreativeSpec findFirstOrThrow
   */
  export type CreativeSpecFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * Filter, which CreativeSpec to fetch.
     */
    where?: CreativeSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeSpecs to fetch.
     */
    orderBy?: CreativeSpecOrderByWithRelationInput | CreativeSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreativeSpecs.
     */
    cursor?: CreativeSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreativeSpecs.
     */
    distinct?: CreativeSpecScalarFieldEnum | CreativeSpecScalarFieldEnum[]
  }

  /**
   * CreativeSpec findMany
   */
  export type CreativeSpecFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * Filter, which CreativeSpecs to fetch.
     */
    where?: CreativeSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeSpecs to fetch.
     */
    orderBy?: CreativeSpecOrderByWithRelationInput | CreativeSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreativeSpecs.
     */
    cursor?: CreativeSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeSpecs.
     */
    skip?: number
    distinct?: CreativeSpecScalarFieldEnum | CreativeSpecScalarFieldEnum[]
  }

  /**
   * CreativeSpec create
   */
  export type CreativeSpecCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * The data needed to create a CreativeSpec.
     */
    data: XOR<CreativeSpecCreateInput, CreativeSpecUncheckedCreateInput>
  }

  /**
   * CreativeSpec createMany
   */
  export type CreativeSpecCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreativeSpecs.
     */
    data: CreativeSpecCreateManyInput | CreativeSpecCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreativeSpec createManyAndReturn
   */
  export type CreativeSpecCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CreativeSpecs.
     */
    data: CreativeSpecCreateManyInput | CreativeSpecCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreativeSpec update
   */
  export type CreativeSpecUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * The data needed to update a CreativeSpec.
     */
    data: XOR<CreativeSpecUpdateInput, CreativeSpecUncheckedUpdateInput>
    /**
     * Choose, which CreativeSpec to update.
     */
    where: CreativeSpecWhereUniqueInput
  }

  /**
   * CreativeSpec updateMany
   */
  export type CreativeSpecUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreativeSpecs.
     */
    data: XOR<CreativeSpecUpdateManyMutationInput, CreativeSpecUncheckedUpdateManyInput>
    /**
     * Filter which CreativeSpecs to update
     */
    where?: CreativeSpecWhereInput
  }

  /**
   * CreativeSpec upsert
   */
  export type CreativeSpecUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * The filter to search for the CreativeSpec to update in case it exists.
     */
    where: CreativeSpecWhereUniqueInput
    /**
     * In case the CreativeSpec found by the `where` argument doesn't exist, create a new CreativeSpec with this data.
     */
    create: XOR<CreativeSpecCreateInput, CreativeSpecUncheckedCreateInput>
    /**
     * In case the CreativeSpec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreativeSpecUpdateInput, CreativeSpecUncheckedUpdateInput>
  }

  /**
   * CreativeSpec delete
   */
  export type CreativeSpecDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
    /**
     * Filter which CreativeSpec to delete.
     */
    where: CreativeSpecWhereUniqueInput
  }

  /**
   * CreativeSpec deleteMany
   */
  export type CreativeSpecDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreativeSpecs to delete
     */
    where?: CreativeSpecWhereInput
  }

  /**
   * CreativeSpec without action
   */
  export type CreativeSpecDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeSpec
     */
    select?: CreativeSpecSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeSpecInclude<ExtArgs> | null
  }


  /**
   * Model PartnerHealthMetric
   */

  export type AggregatePartnerHealthMetric = {
    _count: PartnerHealthMetricCountAggregateOutputType | null
    _avg: PartnerHealthMetricAvgAggregateOutputType | null
    _sum: PartnerHealthMetricSumAggregateOutputType | null
    _min: PartnerHealthMetricMinAggregateOutputType | null
    _max: PartnerHealthMetricMaxAggregateOutputType | null
  }

  export type PartnerHealthMetricAvgAggregateOutputType = {
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    healthScore: number | null
  }

  export type PartnerHealthMetricSumAggregateOutputType = {
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    healthScore: number | null
  }

  export type PartnerHealthMetricMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    timestamp: Date | null
    apiStatus: $Enums.ApiStatus | null
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    lastError: string | null
    healthScore: number | null
  }

  export type PartnerHealthMetricMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    timestamp: Date | null
    apiStatus: $Enums.ApiStatus | null
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    lastError: string | null
    healthScore: number | null
  }

  export type PartnerHealthMetricCountAggregateOutputType = {
    id: number
    partnerId: number
    timestamp: number
    apiStatus: number
    responseTime: number
    errorRate: number
    uptime: number
    lastError: number
    healthScore: number
    details: number
    _all: number
  }


  export type PartnerHealthMetricAvgAggregateInputType = {
    responseTime?: true
    errorRate?: true
    uptime?: true
    healthScore?: true
  }

  export type PartnerHealthMetricSumAggregateInputType = {
    responseTime?: true
    errorRate?: true
    uptime?: true
    healthScore?: true
  }

  export type PartnerHealthMetricMinAggregateInputType = {
    id?: true
    partnerId?: true
    timestamp?: true
    apiStatus?: true
    responseTime?: true
    errorRate?: true
    uptime?: true
    lastError?: true
    healthScore?: true
  }

  export type PartnerHealthMetricMaxAggregateInputType = {
    id?: true
    partnerId?: true
    timestamp?: true
    apiStatus?: true
    responseTime?: true
    errorRate?: true
    uptime?: true
    lastError?: true
    healthScore?: true
  }

  export type PartnerHealthMetricCountAggregateInputType = {
    id?: true
    partnerId?: true
    timestamp?: true
    apiStatus?: true
    responseTime?: true
    errorRate?: true
    uptime?: true
    lastError?: true
    healthScore?: true
    details?: true
    _all?: true
  }

  export type PartnerHealthMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerHealthMetric to aggregate.
     */
    where?: PartnerHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerHealthMetrics to fetch.
     */
    orderBy?: PartnerHealthMetricOrderByWithRelationInput | PartnerHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerHealthMetrics
    **/
    _count?: true | PartnerHealthMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerHealthMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerHealthMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerHealthMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerHealthMetricMaxAggregateInputType
  }

  export type GetPartnerHealthMetricAggregateType<T extends PartnerHealthMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerHealthMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerHealthMetric[P]>
      : GetScalarType<T[P], AggregatePartnerHealthMetric[P]>
  }




  export type PartnerHealthMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerHealthMetricWhereInput
    orderBy?: PartnerHealthMetricOrderByWithAggregationInput | PartnerHealthMetricOrderByWithAggregationInput[]
    by: PartnerHealthMetricScalarFieldEnum[] | PartnerHealthMetricScalarFieldEnum
    having?: PartnerHealthMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerHealthMetricCountAggregateInputType | true
    _avg?: PartnerHealthMetricAvgAggregateInputType
    _sum?: PartnerHealthMetricSumAggregateInputType
    _min?: PartnerHealthMetricMinAggregateInputType
    _max?: PartnerHealthMetricMaxAggregateInputType
  }

  export type PartnerHealthMetricGroupByOutputType = {
    id: string
    partnerId: string
    timestamp: Date
    apiStatus: $Enums.ApiStatus
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    lastError: string | null
    healthScore: number | null
    details: JsonValue | null
    _count: PartnerHealthMetricCountAggregateOutputType | null
    _avg: PartnerHealthMetricAvgAggregateOutputType | null
    _sum: PartnerHealthMetricSumAggregateOutputType | null
    _min: PartnerHealthMetricMinAggregateOutputType | null
    _max: PartnerHealthMetricMaxAggregateOutputType | null
  }

  type GetPartnerHealthMetricGroupByPayload<T extends PartnerHealthMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerHealthMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerHealthMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerHealthMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerHealthMetricGroupByOutputType[P]>
        }
      >
    >


  export type PartnerHealthMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    timestamp?: boolean
    apiStatus?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    lastError?: boolean
    healthScore?: boolean
    details?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerHealthMetric"]>

  export type PartnerHealthMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    timestamp?: boolean
    apiStatus?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    lastError?: boolean
    healthScore?: boolean
    details?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerHealthMetric"]>

  export type PartnerHealthMetricSelectScalar = {
    id?: boolean
    partnerId?: boolean
    timestamp?: boolean
    apiStatus?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    lastError?: boolean
    healthScore?: boolean
    details?: boolean
  }

  export type PartnerHealthMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerHealthMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerHealthMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerHealthMetric"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      timestamp: Date
      apiStatus: $Enums.ApiStatus
      responseTime: number | null
      errorRate: number | null
      uptime: number | null
      lastError: string | null
      healthScore: number | null
      details: Prisma.JsonValue | null
    }, ExtArgs["result"]["partnerHealthMetric"]>
    composites: {}
  }

  type PartnerHealthMetricGetPayload<S extends boolean | null | undefined | PartnerHealthMetricDefaultArgs> = $Result.GetResult<Prisma.$PartnerHealthMetricPayload, S>

  type PartnerHealthMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartnerHealthMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartnerHealthMetricCountAggregateInputType | true
    }

  export interface PartnerHealthMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerHealthMetric'], meta: { name: 'PartnerHealthMetric' } }
    /**
     * Find zero or one PartnerHealthMetric that matches the filter.
     * @param {PartnerHealthMetricFindUniqueArgs} args - Arguments to find a PartnerHealthMetric
     * @example
     * // Get one PartnerHealthMetric
     * const partnerHealthMetric = await prisma.partnerHealthMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerHealthMetricFindUniqueArgs>(args: SelectSubset<T, PartnerHealthMetricFindUniqueArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PartnerHealthMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartnerHealthMetricFindUniqueOrThrowArgs} args - Arguments to find a PartnerHealthMetric
     * @example
     * // Get one PartnerHealthMetric
     * const partnerHealthMetric = await prisma.partnerHealthMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerHealthMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerHealthMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PartnerHealthMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricFindFirstArgs} args - Arguments to find a PartnerHealthMetric
     * @example
     * // Get one PartnerHealthMetric
     * const partnerHealthMetric = await prisma.partnerHealthMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerHealthMetricFindFirstArgs>(args?: SelectSubset<T, PartnerHealthMetricFindFirstArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PartnerHealthMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricFindFirstOrThrowArgs} args - Arguments to find a PartnerHealthMetric
     * @example
     * // Get one PartnerHealthMetric
     * const partnerHealthMetric = await prisma.partnerHealthMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerHealthMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerHealthMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PartnerHealthMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerHealthMetrics
     * const partnerHealthMetrics = await prisma.partnerHealthMetric.findMany()
     * 
     * // Get first 10 PartnerHealthMetrics
     * const partnerHealthMetrics = await prisma.partnerHealthMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerHealthMetricWithIdOnly = await prisma.partnerHealthMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerHealthMetricFindManyArgs>(args?: SelectSubset<T, PartnerHealthMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PartnerHealthMetric.
     * @param {PartnerHealthMetricCreateArgs} args - Arguments to create a PartnerHealthMetric.
     * @example
     * // Create one PartnerHealthMetric
     * const PartnerHealthMetric = await prisma.partnerHealthMetric.create({
     *   data: {
     *     // ... data to create a PartnerHealthMetric
     *   }
     * })
     * 
     */
    create<T extends PartnerHealthMetricCreateArgs>(args: SelectSubset<T, PartnerHealthMetricCreateArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PartnerHealthMetrics.
     * @param {PartnerHealthMetricCreateManyArgs} args - Arguments to create many PartnerHealthMetrics.
     * @example
     * // Create many PartnerHealthMetrics
     * const partnerHealthMetric = await prisma.partnerHealthMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerHealthMetricCreateManyArgs>(args?: SelectSubset<T, PartnerHealthMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerHealthMetrics and returns the data saved in the database.
     * @param {PartnerHealthMetricCreateManyAndReturnArgs} args - Arguments to create many PartnerHealthMetrics.
     * @example
     * // Create many PartnerHealthMetrics
     * const partnerHealthMetric = await prisma.partnerHealthMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerHealthMetrics and only return the `id`
     * const partnerHealthMetricWithIdOnly = await prisma.partnerHealthMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerHealthMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerHealthMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PartnerHealthMetric.
     * @param {PartnerHealthMetricDeleteArgs} args - Arguments to delete one PartnerHealthMetric.
     * @example
     * // Delete one PartnerHealthMetric
     * const PartnerHealthMetric = await prisma.partnerHealthMetric.delete({
     *   where: {
     *     // ... filter to delete one PartnerHealthMetric
     *   }
     * })
     * 
     */
    delete<T extends PartnerHealthMetricDeleteArgs>(args: SelectSubset<T, PartnerHealthMetricDeleteArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PartnerHealthMetric.
     * @param {PartnerHealthMetricUpdateArgs} args - Arguments to update one PartnerHealthMetric.
     * @example
     * // Update one PartnerHealthMetric
     * const partnerHealthMetric = await prisma.partnerHealthMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerHealthMetricUpdateArgs>(args: SelectSubset<T, PartnerHealthMetricUpdateArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PartnerHealthMetrics.
     * @param {PartnerHealthMetricDeleteManyArgs} args - Arguments to filter PartnerHealthMetrics to delete.
     * @example
     * // Delete a few PartnerHealthMetrics
     * const { count } = await prisma.partnerHealthMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerHealthMetricDeleteManyArgs>(args?: SelectSubset<T, PartnerHealthMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerHealthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerHealthMetrics
     * const partnerHealthMetric = await prisma.partnerHealthMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerHealthMetricUpdateManyArgs>(args: SelectSubset<T, PartnerHealthMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartnerHealthMetric.
     * @param {PartnerHealthMetricUpsertArgs} args - Arguments to update or create a PartnerHealthMetric.
     * @example
     * // Update or create a PartnerHealthMetric
     * const partnerHealthMetric = await prisma.partnerHealthMetric.upsert({
     *   create: {
     *     // ... data to create a PartnerHealthMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerHealthMetric we want to update
     *   }
     * })
     */
    upsert<T extends PartnerHealthMetricUpsertArgs>(args: SelectSubset<T, PartnerHealthMetricUpsertArgs<ExtArgs>>): Prisma__PartnerHealthMetricClient<$Result.GetResult<Prisma.$PartnerHealthMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PartnerHealthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricCountArgs} args - Arguments to filter PartnerHealthMetrics to count.
     * @example
     * // Count the number of PartnerHealthMetrics
     * const count = await prisma.partnerHealthMetric.count({
     *   where: {
     *     // ... the filter for the PartnerHealthMetrics we want to count
     *   }
     * })
    **/
    count<T extends PartnerHealthMetricCountArgs>(
      args?: Subset<T, PartnerHealthMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerHealthMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerHealthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerHealthMetricAggregateArgs>(args: Subset<T, PartnerHealthMetricAggregateArgs>): Prisma.PrismaPromise<GetPartnerHealthMetricAggregateType<T>>

    /**
     * Group by PartnerHealthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerHealthMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerHealthMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerHealthMetricGroupByArgs['orderBy'] }
        : { orderBy?: PartnerHealthMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerHealthMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerHealthMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerHealthMetric model
   */
  readonly fields: PartnerHealthMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerHealthMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerHealthMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerHealthMetric model
   */ 
  interface PartnerHealthMetricFieldRefs {
    readonly id: FieldRef<"PartnerHealthMetric", 'String'>
    readonly partnerId: FieldRef<"PartnerHealthMetric", 'String'>
    readonly timestamp: FieldRef<"PartnerHealthMetric", 'DateTime'>
    readonly apiStatus: FieldRef<"PartnerHealthMetric", 'ApiStatus'>
    readonly responseTime: FieldRef<"PartnerHealthMetric", 'Float'>
    readonly errorRate: FieldRef<"PartnerHealthMetric", 'Float'>
    readonly uptime: FieldRef<"PartnerHealthMetric", 'Float'>
    readonly lastError: FieldRef<"PartnerHealthMetric", 'String'>
    readonly healthScore: FieldRef<"PartnerHealthMetric", 'Float'>
    readonly details: FieldRef<"PartnerHealthMetric", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PartnerHealthMetric findUnique
   */
  export type PartnerHealthMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * Filter, which PartnerHealthMetric to fetch.
     */
    where: PartnerHealthMetricWhereUniqueInput
  }

  /**
   * PartnerHealthMetric findUniqueOrThrow
   */
  export type PartnerHealthMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * Filter, which PartnerHealthMetric to fetch.
     */
    where: PartnerHealthMetricWhereUniqueInput
  }

  /**
   * PartnerHealthMetric findFirst
   */
  export type PartnerHealthMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * Filter, which PartnerHealthMetric to fetch.
     */
    where?: PartnerHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerHealthMetrics to fetch.
     */
    orderBy?: PartnerHealthMetricOrderByWithRelationInput | PartnerHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerHealthMetrics.
     */
    cursor?: PartnerHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerHealthMetrics.
     */
    distinct?: PartnerHealthMetricScalarFieldEnum | PartnerHealthMetricScalarFieldEnum[]
  }

  /**
   * PartnerHealthMetric findFirstOrThrow
   */
  export type PartnerHealthMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * Filter, which PartnerHealthMetric to fetch.
     */
    where?: PartnerHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerHealthMetrics to fetch.
     */
    orderBy?: PartnerHealthMetricOrderByWithRelationInput | PartnerHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerHealthMetrics.
     */
    cursor?: PartnerHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerHealthMetrics.
     */
    distinct?: PartnerHealthMetricScalarFieldEnum | PartnerHealthMetricScalarFieldEnum[]
  }

  /**
   * PartnerHealthMetric findMany
   */
  export type PartnerHealthMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * Filter, which PartnerHealthMetrics to fetch.
     */
    where?: PartnerHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerHealthMetrics to fetch.
     */
    orderBy?: PartnerHealthMetricOrderByWithRelationInput | PartnerHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerHealthMetrics.
     */
    cursor?: PartnerHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerHealthMetrics.
     */
    skip?: number
    distinct?: PartnerHealthMetricScalarFieldEnum | PartnerHealthMetricScalarFieldEnum[]
  }

  /**
   * PartnerHealthMetric create
   */
  export type PartnerHealthMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerHealthMetric.
     */
    data: XOR<PartnerHealthMetricCreateInput, PartnerHealthMetricUncheckedCreateInput>
  }

  /**
   * PartnerHealthMetric createMany
   */
  export type PartnerHealthMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerHealthMetrics.
     */
    data: PartnerHealthMetricCreateManyInput | PartnerHealthMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartnerHealthMetric createManyAndReturn
   */
  export type PartnerHealthMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PartnerHealthMetrics.
     */
    data: PartnerHealthMetricCreateManyInput | PartnerHealthMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerHealthMetric update
   */
  export type PartnerHealthMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerHealthMetric.
     */
    data: XOR<PartnerHealthMetricUpdateInput, PartnerHealthMetricUncheckedUpdateInput>
    /**
     * Choose, which PartnerHealthMetric to update.
     */
    where: PartnerHealthMetricWhereUniqueInput
  }

  /**
   * PartnerHealthMetric updateMany
   */
  export type PartnerHealthMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerHealthMetrics.
     */
    data: XOR<PartnerHealthMetricUpdateManyMutationInput, PartnerHealthMetricUncheckedUpdateManyInput>
    /**
     * Filter which PartnerHealthMetrics to update
     */
    where?: PartnerHealthMetricWhereInput
  }

  /**
   * PartnerHealthMetric upsert
   */
  export type PartnerHealthMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerHealthMetric to update in case it exists.
     */
    where: PartnerHealthMetricWhereUniqueInput
    /**
     * In case the PartnerHealthMetric found by the `where` argument doesn't exist, create a new PartnerHealthMetric with this data.
     */
    create: XOR<PartnerHealthMetricCreateInput, PartnerHealthMetricUncheckedCreateInput>
    /**
     * In case the PartnerHealthMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerHealthMetricUpdateInput, PartnerHealthMetricUncheckedUpdateInput>
  }

  /**
   * PartnerHealthMetric delete
   */
  export type PartnerHealthMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
    /**
     * Filter which PartnerHealthMetric to delete.
     */
    where: PartnerHealthMetricWhereUniqueInput
  }

  /**
   * PartnerHealthMetric deleteMany
   */
  export type PartnerHealthMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerHealthMetrics to delete
     */
    where?: PartnerHealthMetricWhereInput
  }

  /**
   * PartnerHealthMetric without action
   */
  export type PartnerHealthMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerHealthMetric
     */
    select?: PartnerHealthMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerHealthMetricInclude<ExtArgs> | null
  }


  /**
   * Model CampaignPartner
   */

  export type AggregateCampaignPartner = {
    _count: CampaignPartnerCountAggregateOutputType | null
    _min: CampaignPartnerMinAggregateOutputType | null
    _max: CampaignPartnerMaxAggregateOutputType | null
  }

  export type CampaignPartnerMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    partnerId: string | null
    status: $Enums.CampaignPartnerStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignPartnerMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    partnerId: string | null
    status: $Enums.CampaignPartnerStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignPartnerCountAggregateOutputType = {
    id: number
    campaignId: number
    partnerId: number
    status: number
    budget: number
    targeting: number
    creative: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignPartnerMinAggregateInputType = {
    id?: true
    campaignId?: true
    partnerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignPartnerMaxAggregateInputType = {
    id?: true
    campaignId?: true
    partnerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignPartnerCountAggregateInputType = {
    id?: true
    campaignId?: true
    partnerId?: true
    status?: true
    budget?: true
    targeting?: true
    creative?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignPartner to aggregate.
     */
    where?: CampaignPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPartners to fetch.
     */
    orderBy?: CampaignPartnerOrderByWithRelationInput | CampaignPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignPartners
    **/
    _count?: true | CampaignPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignPartnerMaxAggregateInputType
  }

  export type GetCampaignPartnerAggregateType<T extends CampaignPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignPartner[P]>
      : GetScalarType<T[P], AggregateCampaignPartner[P]>
  }




  export type CampaignPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignPartnerWhereInput
    orderBy?: CampaignPartnerOrderByWithAggregationInput | CampaignPartnerOrderByWithAggregationInput[]
    by: CampaignPartnerScalarFieldEnum[] | CampaignPartnerScalarFieldEnum
    having?: CampaignPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignPartnerCountAggregateInputType | true
    _min?: CampaignPartnerMinAggregateInputType
    _max?: CampaignPartnerMaxAggregateInputType
  }

  export type CampaignPartnerGroupByOutputType = {
    id: string
    campaignId: string
    partnerId: string
    status: $Enums.CampaignPartnerStatus
    budget: JsonValue | null
    targeting: JsonValue | null
    creative: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignPartnerCountAggregateOutputType | null
    _min: CampaignPartnerMinAggregateOutputType | null
    _max: CampaignPartnerMaxAggregateOutputType | null
  }

  type GetCampaignPartnerGroupByPayload<T extends CampaignPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignPartnerGroupByOutputType[P]>
        }
      >
    >


  export type CampaignPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    partnerId?: boolean
    status?: boolean
    budget?: boolean
    targeting?: boolean
    creative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignPartner"]>

  export type CampaignPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    partnerId?: boolean
    status?: boolean
    budget?: boolean
    targeting?: boolean
    creative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignPartner"]>

  export type CampaignPartnerSelectScalar = {
    id?: boolean
    campaignId?: boolean
    partnerId?: boolean
    status?: boolean
    budget?: boolean
    targeting?: boolean
    creative?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type CampaignPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $CampaignPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignPartner"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      partnerId: string
      status: $Enums.CampaignPartnerStatus
      budget: Prisma.JsonValue | null
      targeting: Prisma.JsonValue | null
      creative: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignPartner"]>
    composites: {}
  }

  type CampaignPartnerGetPayload<S extends boolean | null | undefined | CampaignPartnerDefaultArgs> = $Result.GetResult<Prisma.$CampaignPartnerPayload, S>

  type CampaignPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignPartnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignPartnerCountAggregateInputType | true
    }

  export interface CampaignPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignPartner'], meta: { name: 'CampaignPartner' } }
    /**
     * Find zero or one CampaignPartner that matches the filter.
     * @param {CampaignPartnerFindUniqueArgs} args - Arguments to find a CampaignPartner
     * @example
     * // Get one CampaignPartner
     * const campaignPartner = await prisma.campaignPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignPartnerFindUniqueArgs>(args: SelectSubset<T, CampaignPartnerFindUniqueArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignPartner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignPartnerFindUniqueOrThrowArgs} args - Arguments to find a CampaignPartner
     * @example
     * // Get one CampaignPartner
     * const campaignPartner = await prisma.campaignPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerFindFirstArgs} args - Arguments to find a CampaignPartner
     * @example
     * // Get one CampaignPartner
     * const campaignPartner = await prisma.campaignPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignPartnerFindFirstArgs>(args?: SelectSubset<T, CampaignPartnerFindFirstArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerFindFirstOrThrowArgs} args - Arguments to find a CampaignPartner
     * @example
     * // Get one CampaignPartner
     * const campaignPartner = await prisma.campaignPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignPartners
     * const campaignPartners = await prisma.campaignPartner.findMany()
     * 
     * // Get first 10 CampaignPartners
     * const campaignPartners = await prisma.campaignPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignPartnerWithIdOnly = await prisma.campaignPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignPartnerFindManyArgs>(args?: SelectSubset<T, CampaignPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignPartner.
     * @param {CampaignPartnerCreateArgs} args - Arguments to create a CampaignPartner.
     * @example
     * // Create one CampaignPartner
     * const CampaignPartner = await prisma.campaignPartner.create({
     *   data: {
     *     // ... data to create a CampaignPartner
     *   }
     * })
     * 
     */
    create<T extends CampaignPartnerCreateArgs>(args: SelectSubset<T, CampaignPartnerCreateArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignPartners.
     * @param {CampaignPartnerCreateManyArgs} args - Arguments to create many CampaignPartners.
     * @example
     * // Create many CampaignPartners
     * const campaignPartner = await prisma.campaignPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignPartnerCreateManyArgs>(args?: SelectSubset<T, CampaignPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignPartners and returns the data saved in the database.
     * @param {CampaignPartnerCreateManyAndReturnArgs} args - Arguments to create many CampaignPartners.
     * @example
     * // Create many CampaignPartners
     * const campaignPartner = await prisma.campaignPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignPartners and only return the `id`
     * const campaignPartnerWithIdOnly = await prisma.campaignPartner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignPartner.
     * @param {CampaignPartnerDeleteArgs} args - Arguments to delete one CampaignPartner.
     * @example
     * // Delete one CampaignPartner
     * const CampaignPartner = await prisma.campaignPartner.delete({
     *   where: {
     *     // ... filter to delete one CampaignPartner
     *   }
     * })
     * 
     */
    delete<T extends CampaignPartnerDeleteArgs>(args: SelectSubset<T, CampaignPartnerDeleteArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignPartner.
     * @param {CampaignPartnerUpdateArgs} args - Arguments to update one CampaignPartner.
     * @example
     * // Update one CampaignPartner
     * const campaignPartner = await prisma.campaignPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignPartnerUpdateArgs>(args: SelectSubset<T, CampaignPartnerUpdateArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignPartners.
     * @param {CampaignPartnerDeleteManyArgs} args - Arguments to filter CampaignPartners to delete.
     * @example
     * // Delete a few CampaignPartners
     * const { count } = await prisma.campaignPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignPartnerDeleteManyArgs>(args?: SelectSubset<T, CampaignPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignPartners
     * const campaignPartner = await prisma.campaignPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignPartnerUpdateManyArgs>(args: SelectSubset<T, CampaignPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignPartner.
     * @param {CampaignPartnerUpsertArgs} args - Arguments to update or create a CampaignPartner.
     * @example
     * // Update or create a CampaignPartner
     * const campaignPartner = await prisma.campaignPartner.upsert({
     *   create: {
     *     // ... data to create a CampaignPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignPartner we want to update
     *   }
     * })
     */
    upsert<T extends CampaignPartnerUpsertArgs>(args: SelectSubset<T, CampaignPartnerUpsertArgs<ExtArgs>>): Prisma__CampaignPartnerClient<$Result.GetResult<Prisma.$CampaignPartnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerCountArgs} args - Arguments to filter CampaignPartners to count.
     * @example
     * // Count the number of CampaignPartners
     * const count = await prisma.campaignPartner.count({
     *   where: {
     *     // ... the filter for the CampaignPartners we want to count
     *   }
     * })
    **/
    count<T extends CampaignPartnerCountArgs>(
      args?: Subset<T, CampaignPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignPartnerAggregateArgs>(args: Subset<T, CampaignPartnerAggregateArgs>): Prisma.PrismaPromise<GetCampaignPartnerAggregateType<T>>

    /**
     * Group by CampaignPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignPartnerGroupByArgs['orderBy'] }
        : { orderBy?: CampaignPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignPartner model
   */
  readonly fields: CampaignPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignPartner model
   */ 
  interface CampaignPartnerFieldRefs {
    readonly id: FieldRef<"CampaignPartner", 'String'>
    readonly campaignId: FieldRef<"CampaignPartner", 'String'>
    readonly partnerId: FieldRef<"CampaignPartner", 'String'>
    readonly status: FieldRef<"CampaignPartner", 'CampaignPartnerStatus'>
    readonly budget: FieldRef<"CampaignPartner", 'Json'>
    readonly targeting: FieldRef<"CampaignPartner", 'Json'>
    readonly creative: FieldRef<"CampaignPartner", 'Json'>
    readonly createdAt: FieldRef<"CampaignPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignPartner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignPartner findUnique
   */
  export type CampaignPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CampaignPartner to fetch.
     */
    where: CampaignPartnerWhereUniqueInput
  }

  /**
   * CampaignPartner findUniqueOrThrow
   */
  export type CampaignPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CampaignPartner to fetch.
     */
    where: CampaignPartnerWhereUniqueInput
  }

  /**
   * CampaignPartner findFirst
   */
  export type CampaignPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CampaignPartner to fetch.
     */
    where?: CampaignPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPartners to fetch.
     */
    orderBy?: CampaignPartnerOrderByWithRelationInput | CampaignPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignPartners.
     */
    cursor?: CampaignPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignPartners.
     */
    distinct?: CampaignPartnerScalarFieldEnum | CampaignPartnerScalarFieldEnum[]
  }

  /**
   * CampaignPartner findFirstOrThrow
   */
  export type CampaignPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CampaignPartner to fetch.
     */
    where?: CampaignPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPartners to fetch.
     */
    orderBy?: CampaignPartnerOrderByWithRelationInput | CampaignPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignPartners.
     */
    cursor?: CampaignPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignPartners.
     */
    distinct?: CampaignPartnerScalarFieldEnum | CampaignPartnerScalarFieldEnum[]
  }

  /**
   * CampaignPartner findMany
   */
  export type CampaignPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CampaignPartners to fetch.
     */
    where?: CampaignPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPartners to fetch.
     */
    orderBy?: CampaignPartnerOrderByWithRelationInput | CampaignPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignPartners.
     */
    cursor?: CampaignPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPartners.
     */
    skip?: number
    distinct?: CampaignPartnerScalarFieldEnum | CampaignPartnerScalarFieldEnum[]
  }

  /**
   * CampaignPartner create
   */
  export type CampaignPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignPartner.
     */
    data: XOR<CampaignPartnerCreateInput, CampaignPartnerUncheckedCreateInput>
  }

  /**
   * CampaignPartner createMany
   */
  export type CampaignPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignPartners.
     */
    data: CampaignPartnerCreateManyInput | CampaignPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignPartner createManyAndReturn
   */
  export type CampaignPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignPartners.
     */
    data: CampaignPartnerCreateManyInput | CampaignPartnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignPartner update
   */
  export type CampaignPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignPartner.
     */
    data: XOR<CampaignPartnerUpdateInput, CampaignPartnerUncheckedUpdateInput>
    /**
     * Choose, which CampaignPartner to update.
     */
    where: CampaignPartnerWhereUniqueInput
  }

  /**
   * CampaignPartner updateMany
   */
  export type CampaignPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignPartners.
     */
    data: XOR<CampaignPartnerUpdateManyMutationInput, CampaignPartnerUncheckedUpdateManyInput>
    /**
     * Filter which CampaignPartners to update
     */
    where?: CampaignPartnerWhereInput
  }

  /**
   * CampaignPartner upsert
   */
  export type CampaignPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignPartner to update in case it exists.
     */
    where: CampaignPartnerWhereUniqueInput
    /**
     * In case the CampaignPartner found by the `where` argument doesn't exist, create a new CampaignPartner with this data.
     */
    create: XOR<CampaignPartnerCreateInput, CampaignPartnerUncheckedCreateInput>
    /**
     * In case the CampaignPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignPartnerUpdateInput, CampaignPartnerUncheckedUpdateInput>
  }

  /**
   * CampaignPartner delete
   */
  export type CampaignPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
    /**
     * Filter which CampaignPartner to delete.
     */
    where: CampaignPartnerWhereUniqueInput
  }

  /**
   * CampaignPartner deleteMany
   */
  export type CampaignPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignPartners to delete
     */
    where?: CampaignPartnerWhereInput
  }

  /**
   * CampaignPartner without action
   */
  export type CampaignPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignPartner
     */
    select?: CampaignPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignPartnerInclude<ExtArgs> | null
  }


  /**
   * Model CapabilityMatrix
   */

  export type AggregateCapabilityMatrix = {
    _count: CapabilityMatrixCountAggregateOutputType | null
    _min: CapabilityMatrixMinAggregateOutputType | null
    _max: CapabilityMatrixMaxAggregateOutputType | null
  }

  export type CapabilityMatrixMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapabilityMatrixMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapabilityMatrixCountAggregateOutputType = {
    id: number
    name: number
    description: number
    capabilities: number
    comparison: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CapabilityMatrixMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapabilityMatrixMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapabilityMatrixCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    capabilities?: true
    comparison?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CapabilityMatrixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapabilityMatrix to aggregate.
     */
    where?: CapabilityMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityMatrices to fetch.
     */
    orderBy?: CapabilityMatrixOrderByWithRelationInput | CapabilityMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapabilityMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapabilityMatrices
    **/
    _count?: true | CapabilityMatrixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapabilityMatrixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapabilityMatrixMaxAggregateInputType
  }

  export type GetCapabilityMatrixAggregateType<T extends CapabilityMatrixAggregateArgs> = {
        [P in keyof T & keyof AggregateCapabilityMatrix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapabilityMatrix[P]>
      : GetScalarType<T[P], AggregateCapabilityMatrix[P]>
  }




  export type CapabilityMatrixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityMatrixWhereInput
    orderBy?: CapabilityMatrixOrderByWithAggregationInput | CapabilityMatrixOrderByWithAggregationInput[]
    by: CapabilityMatrixScalarFieldEnum[] | CapabilityMatrixScalarFieldEnum
    having?: CapabilityMatrixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapabilityMatrixCountAggregateInputType | true
    _min?: CapabilityMatrixMinAggregateInputType
    _max?: CapabilityMatrixMaxAggregateInputType
  }

  export type CapabilityMatrixGroupByOutputType = {
    id: string
    name: string
    description: string | null
    capabilities: JsonValue
    comparison: JsonValue
    lastUpdated: Date
    createdAt: Date
    updatedAt: Date
    _count: CapabilityMatrixCountAggregateOutputType | null
    _min: CapabilityMatrixMinAggregateOutputType | null
    _max: CapabilityMatrixMaxAggregateOutputType | null
  }

  type GetCapabilityMatrixGroupByPayload<T extends CapabilityMatrixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapabilityMatrixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapabilityMatrixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapabilityMatrixGroupByOutputType[P]>
            : GetScalarType<T[P], CapabilityMatrixGroupByOutputType[P]>
        }
      >
    >


  export type CapabilityMatrixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    capabilities?: boolean
    comparison?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["capabilityMatrix"]>

  export type CapabilityMatrixSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    capabilities?: boolean
    comparison?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["capabilityMatrix"]>

  export type CapabilityMatrixSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    capabilities?: boolean
    comparison?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CapabilityMatrixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapabilityMatrix"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      capabilities: Prisma.JsonValue
      comparison: Prisma.JsonValue
      lastUpdated: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["capabilityMatrix"]>
    composites: {}
  }

  type CapabilityMatrixGetPayload<S extends boolean | null | undefined | CapabilityMatrixDefaultArgs> = $Result.GetResult<Prisma.$CapabilityMatrixPayload, S>

  type CapabilityMatrixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CapabilityMatrixFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CapabilityMatrixCountAggregateInputType | true
    }

  export interface CapabilityMatrixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapabilityMatrix'], meta: { name: 'CapabilityMatrix' } }
    /**
     * Find zero or one CapabilityMatrix that matches the filter.
     * @param {CapabilityMatrixFindUniqueArgs} args - Arguments to find a CapabilityMatrix
     * @example
     * // Get one CapabilityMatrix
     * const capabilityMatrix = await prisma.capabilityMatrix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapabilityMatrixFindUniqueArgs>(args: SelectSubset<T, CapabilityMatrixFindUniqueArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CapabilityMatrix that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CapabilityMatrixFindUniqueOrThrowArgs} args - Arguments to find a CapabilityMatrix
     * @example
     * // Get one CapabilityMatrix
     * const capabilityMatrix = await prisma.capabilityMatrix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapabilityMatrixFindUniqueOrThrowArgs>(args: SelectSubset<T, CapabilityMatrixFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CapabilityMatrix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixFindFirstArgs} args - Arguments to find a CapabilityMatrix
     * @example
     * // Get one CapabilityMatrix
     * const capabilityMatrix = await prisma.capabilityMatrix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapabilityMatrixFindFirstArgs>(args?: SelectSubset<T, CapabilityMatrixFindFirstArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CapabilityMatrix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixFindFirstOrThrowArgs} args - Arguments to find a CapabilityMatrix
     * @example
     * // Get one CapabilityMatrix
     * const capabilityMatrix = await prisma.capabilityMatrix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapabilityMatrixFindFirstOrThrowArgs>(args?: SelectSubset<T, CapabilityMatrixFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CapabilityMatrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapabilityMatrices
     * const capabilityMatrices = await prisma.capabilityMatrix.findMany()
     * 
     * // Get first 10 CapabilityMatrices
     * const capabilityMatrices = await prisma.capabilityMatrix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capabilityMatrixWithIdOnly = await prisma.capabilityMatrix.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapabilityMatrixFindManyArgs>(args?: SelectSubset<T, CapabilityMatrixFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CapabilityMatrix.
     * @param {CapabilityMatrixCreateArgs} args - Arguments to create a CapabilityMatrix.
     * @example
     * // Create one CapabilityMatrix
     * const CapabilityMatrix = await prisma.capabilityMatrix.create({
     *   data: {
     *     // ... data to create a CapabilityMatrix
     *   }
     * })
     * 
     */
    create<T extends CapabilityMatrixCreateArgs>(args: SelectSubset<T, CapabilityMatrixCreateArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CapabilityMatrices.
     * @param {CapabilityMatrixCreateManyArgs} args - Arguments to create many CapabilityMatrices.
     * @example
     * // Create many CapabilityMatrices
     * const capabilityMatrix = await prisma.capabilityMatrix.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapabilityMatrixCreateManyArgs>(args?: SelectSubset<T, CapabilityMatrixCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CapabilityMatrices and returns the data saved in the database.
     * @param {CapabilityMatrixCreateManyAndReturnArgs} args - Arguments to create many CapabilityMatrices.
     * @example
     * // Create many CapabilityMatrices
     * const capabilityMatrix = await prisma.capabilityMatrix.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CapabilityMatrices and only return the `id`
     * const capabilityMatrixWithIdOnly = await prisma.capabilityMatrix.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapabilityMatrixCreateManyAndReturnArgs>(args?: SelectSubset<T, CapabilityMatrixCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CapabilityMatrix.
     * @param {CapabilityMatrixDeleteArgs} args - Arguments to delete one CapabilityMatrix.
     * @example
     * // Delete one CapabilityMatrix
     * const CapabilityMatrix = await prisma.capabilityMatrix.delete({
     *   where: {
     *     // ... filter to delete one CapabilityMatrix
     *   }
     * })
     * 
     */
    delete<T extends CapabilityMatrixDeleteArgs>(args: SelectSubset<T, CapabilityMatrixDeleteArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CapabilityMatrix.
     * @param {CapabilityMatrixUpdateArgs} args - Arguments to update one CapabilityMatrix.
     * @example
     * // Update one CapabilityMatrix
     * const capabilityMatrix = await prisma.capabilityMatrix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapabilityMatrixUpdateArgs>(args: SelectSubset<T, CapabilityMatrixUpdateArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CapabilityMatrices.
     * @param {CapabilityMatrixDeleteManyArgs} args - Arguments to filter CapabilityMatrices to delete.
     * @example
     * // Delete a few CapabilityMatrices
     * const { count } = await prisma.capabilityMatrix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapabilityMatrixDeleteManyArgs>(args?: SelectSubset<T, CapabilityMatrixDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapabilityMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapabilityMatrices
     * const capabilityMatrix = await prisma.capabilityMatrix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapabilityMatrixUpdateManyArgs>(args: SelectSubset<T, CapabilityMatrixUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CapabilityMatrix.
     * @param {CapabilityMatrixUpsertArgs} args - Arguments to update or create a CapabilityMatrix.
     * @example
     * // Update or create a CapabilityMatrix
     * const capabilityMatrix = await prisma.capabilityMatrix.upsert({
     *   create: {
     *     // ... data to create a CapabilityMatrix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapabilityMatrix we want to update
     *   }
     * })
     */
    upsert<T extends CapabilityMatrixUpsertArgs>(args: SelectSubset<T, CapabilityMatrixUpsertArgs<ExtArgs>>): Prisma__CapabilityMatrixClient<$Result.GetResult<Prisma.$CapabilityMatrixPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CapabilityMatrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixCountArgs} args - Arguments to filter CapabilityMatrices to count.
     * @example
     * // Count the number of CapabilityMatrices
     * const count = await prisma.capabilityMatrix.count({
     *   where: {
     *     // ... the filter for the CapabilityMatrices we want to count
     *   }
     * })
    **/
    count<T extends CapabilityMatrixCountArgs>(
      args?: Subset<T, CapabilityMatrixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapabilityMatrixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapabilityMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapabilityMatrixAggregateArgs>(args: Subset<T, CapabilityMatrixAggregateArgs>): Prisma.PrismaPromise<GetCapabilityMatrixAggregateType<T>>

    /**
     * Group by CapabilityMatrix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityMatrixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapabilityMatrixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapabilityMatrixGroupByArgs['orderBy'] }
        : { orderBy?: CapabilityMatrixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapabilityMatrixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapabilityMatrixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapabilityMatrix model
   */
  readonly fields: CapabilityMatrixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapabilityMatrix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapabilityMatrixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapabilityMatrix model
   */ 
  interface CapabilityMatrixFieldRefs {
    readonly id: FieldRef<"CapabilityMatrix", 'String'>
    readonly name: FieldRef<"CapabilityMatrix", 'String'>
    readonly description: FieldRef<"CapabilityMatrix", 'String'>
    readonly capabilities: FieldRef<"CapabilityMatrix", 'Json'>
    readonly comparison: FieldRef<"CapabilityMatrix", 'Json'>
    readonly lastUpdated: FieldRef<"CapabilityMatrix", 'DateTime'>
    readonly createdAt: FieldRef<"CapabilityMatrix", 'DateTime'>
    readonly updatedAt: FieldRef<"CapabilityMatrix", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CapabilityMatrix findUnique
   */
  export type CapabilityMatrixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * Filter, which CapabilityMatrix to fetch.
     */
    where: CapabilityMatrixWhereUniqueInput
  }

  /**
   * CapabilityMatrix findUniqueOrThrow
   */
  export type CapabilityMatrixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * Filter, which CapabilityMatrix to fetch.
     */
    where: CapabilityMatrixWhereUniqueInput
  }

  /**
   * CapabilityMatrix findFirst
   */
  export type CapabilityMatrixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * Filter, which CapabilityMatrix to fetch.
     */
    where?: CapabilityMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityMatrices to fetch.
     */
    orderBy?: CapabilityMatrixOrderByWithRelationInput | CapabilityMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapabilityMatrices.
     */
    cursor?: CapabilityMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapabilityMatrices.
     */
    distinct?: CapabilityMatrixScalarFieldEnum | CapabilityMatrixScalarFieldEnum[]
  }

  /**
   * CapabilityMatrix findFirstOrThrow
   */
  export type CapabilityMatrixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * Filter, which CapabilityMatrix to fetch.
     */
    where?: CapabilityMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityMatrices to fetch.
     */
    orderBy?: CapabilityMatrixOrderByWithRelationInput | CapabilityMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapabilityMatrices.
     */
    cursor?: CapabilityMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityMatrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapabilityMatrices.
     */
    distinct?: CapabilityMatrixScalarFieldEnum | CapabilityMatrixScalarFieldEnum[]
  }

  /**
   * CapabilityMatrix findMany
   */
  export type CapabilityMatrixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * Filter, which CapabilityMatrices to fetch.
     */
    where?: CapabilityMatrixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityMatrices to fetch.
     */
    orderBy?: CapabilityMatrixOrderByWithRelationInput | CapabilityMatrixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapabilityMatrices.
     */
    cursor?: CapabilityMatrixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityMatrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityMatrices.
     */
    skip?: number
    distinct?: CapabilityMatrixScalarFieldEnum | CapabilityMatrixScalarFieldEnum[]
  }

  /**
   * CapabilityMatrix create
   */
  export type CapabilityMatrixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * The data needed to create a CapabilityMatrix.
     */
    data: XOR<CapabilityMatrixCreateInput, CapabilityMatrixUncheckedCreateInput>
  }

  /**
   * CapabilityMatrix createMany
   */
  export type CapabilityMatrixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapabilityMatrices.
     */
    data: CapabilityMatrixCreateManyInput | CapabilityMatrixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapabilityMatrix createManyAndReturn
   */
  export type CapabilityMatrixCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CapabilityMatrices.
     */
    data: CapabilityMatrixCreateManyInput | CapabilityMatrixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapabilityMatrix update
   */
  export type CapabilityMatrixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * The data needed to update a CapabilityMatrix.
     */
    data: XOR<CapabilityMatrixUpdateInput, CapabilityMatrixUncheckedUpdateInput>
    /**
     * Choose, which CapabilityMatrix to update.
     */
    where: CapabilityMatrixWhereUniqueInput
  }

  /**
   * CapabilityMatrix updateMany
   */
  export type CapabilityMatrixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapabilityMatrices.
     */
    data: XOR<CapabilityMatrixUpdateManyMutationInput, CapabilityMatrixUncheckedUpdateManyInput>
    /**
     * Filter which CapabilityMatrices to update
     */
    where?: CapabilityMatrixWhereInput
  }

  /**
   * CapabilityMatrix upsert
   */
  export type CapabilityMatrixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * The filter to search for the CapabilityMatrix to update in case it exists.
     */
    where: CapabilityMatrixWhereUniqueInput
    /**
     * In case the CapabilityMatrix found by the `where` argument doesn't exist, create a new CapabilityMatrix with this data.
     */
    create: XOR<CapabilityMatrixCreateInput, CapabilityMatrixUncheckedCreateInput>
    /**
     * In case the CapabilityMatrix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapabilityMatrixUpdateInput, CapabilityMatrixUncheckedUpdateInput>
  }

  /**
   * CapabilityMatrix delete
   */
  export type CapabilityMatrixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
    /**
     * Filter which CapabilityMatrix to delete.
     */
    where: CapabilityMatrixWhereUniqueInput
  }

  /**
   * CapabilityMatrix deleteMany
   */
  export type CapabilityMatrixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapabilityMatrices to delete
     */
    where?: CapabilityMatrixWhereInput
  }

  /**
   * CapabilityMatrix without action
   */
  export type CapabilityMatrixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityMatrix
     */
    select?: CapabilityMatrixSelect<ExtArgs> | null
  }


  /**
   * Model Dataset
   */

  export type AggregateDataset = {
    _count: DatasetCountAggregateOutputType | null
    _avg: DatasetAvgAggregateOutputType | null
    _sum: DatasetSumAggregateOutputType | null
    _min: DatasetMinAggregateOutputType | null
    _max: DatasetMaxAggregateOutputType | null
  }

  export type DatasetAvgAggregateOutputType = {
    qualityScore: number | null
  }

  export type DatasetSumAggregateOutputType = {
    qualityScore: number | null
  }

  export type DatasetMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: $Enums.DatasetCategory | null
    sourceType: $Enums.DatasetSourceType | null
    updateFrequency: $Enums.UpdateFrequency | null
    qualityScore: number | null
    status: $Enums.DatasetStatus | null
    lastIngestion: Date | null
    nextIngestion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    category: $Enums.DatasetCategory | null
    sourceType: $Enums.DatasetSourceType | null
    updateFrequency: $Enums.UpdateFrequency | null
    qualityScore: number | null
    status: $Enums.DatasetStatus | null
    lastIngestion: Date | null
    nextIngestion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    sourceType: number
    updateFrequency: number
    schema: number
    metadata: number
    qualityScore: number
    status: number
    tags: number
    sourceConfig: number
    lastIngestion: number
    nextIngestion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatasetAvgAggregateInputType = {
    qualityScore?: true
  }

  export type DatasetSumAggregateInputType = {
    qualityScore?: true
  }

  export type DatasetMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    sourceType?: true
    updateFrequency?: true
    qualityScore?: true
    status?: true
    lastIngestion?: true
    nextIngestion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    sourceType?: true
    updateFrequency?: true
    qualityScore?: true
    status?: true
    lastIngestion?: true
    nextIngestion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    sourceType?: true
    updateFrequency?: true
    schema?: true
    metadata?: true
    qualityScore?: true
    status?: true
    tags?: true
    sourceConfig?: true
    lastIngestion?: true
    nextIngestion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatasetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dataset to aggregate.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Datasets
    **/
    _count?: true | DatasetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatasetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatasetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetMaxAggregateInputType
  }

  export type GetDatasetAggregateType<T extends DatasetAggregateArgs> = {
        [P in keyof T & keyof AggregateDataset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataset[P]>
      : GetScalarType<T[P], AggregateDataset[P]>
  }




  export type DatasetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetWhereInput
    orderBy?: DatasetOrderByWithAggregationInput | DatasetOrderByWithAggregationInput[]
    by: DatasetScalarFieldEnum[] | DatasetScalarFieldEnum
    having?: DatasetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetCountAggregateInputType | true
    _avg?: DatasetAvgAggregateInputType
    _sum?: DatasetSumAggregateInputType
    _min?: DatasetMinAggregateInputType
    _max?: DatasetMaxAggregateInputType
  }

  export type DatasetGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonValue
    metadata: JsonValue
    qualityScore: number | null
    status: $Enums.DatasetStatus
    tags: string[]
    sourceConfig: JsonValue
    lastIngestion: Date | null
    nextIngestion: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DatasetCountAggregateOutputType | null
    _avg: DatasetAvgAggregateOutputType | null
    _sum: DatasetSumAggregateOutputType | null
    _min: DatasetMinAggregateOutputType | null
    _max: DatasetMaxAggregateOutputType | null
  }

  type GetDatasetGroupByPayload<T extends DatasetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetGroupByOutputType[P]>
        }
      >
    >


  export type DatasetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    sourceType?: boolean
    updateFrequency?: boolean
    schema?: boolean
    metadata?: boolean
    qualityScore?: boolean
    status?: boolean
    tags?: boolean
    sourceConfig?: boolean
    lastIngestion?: boolean
    nextIngestion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | Dataset$versionsArgs<ExtArgs>
    qualityReports?: boolean | Dataset$qualityReportsArgs<ExtArgs>
    ingestionJobs?: boolean | Dataset$ingestionJobsArgs<ExtArgs>
    lineageUpstream?: boolean | Dataset$lineageUpstreamArgs<ExtArgs>
    lineageDownstream?: boolean | Dataset$lineageDownstreamArgs<ExtArgs>
    _count?: boolean | DatasetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    sourceType?: boolean
    updateFrequency?: boolean
    schema?: boolean
    metadata?: boolean
    qualityScore?: boolean
    status?: boolean
    tags?: boolean
    sourceConfig?: boolean
    lastIngestion?: boolean
    nextIngestion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    sourceType?: boolean
    updateFrequency?: boolean
    schema?: boolean
    metadata?: boolean
    qualityScore?: boolean
    status?: boolean
    tags?: boolean
    sourceConfig?: boolean
    lastIngestion?: boolean
    nextIngestion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatasetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | Dataset$versionsArgs<ExtArgs>
    qualityReports?: boolean | Dataset$qualityReportsArgs<ExtArgs>
    ingestionJobs?: boolean | Dataset$ingestionJobsArgs<ExtArgs>
    lineageUpstream?: boolean | Dataset$lineageUpstreamArgs<ExtArgs>
    lineageDownstream?: boolean | Dataset$lineageDownstreamArgs<ExtArgs>
    _count?: boolean | DatasetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatasetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DatasetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dataset"
    objects: {
      versions: Prisma.$DatasetVersionPayload<ExtArgs>[]
      qualityReports: Prisma.$DataQualityReportPayload<ExtArgs>[]
      ingestionJobs: Prisma.$IngestionJobPayload<ExtArgs>[]
      lineageUpstream: Prisma.$DatasetLineagePayload<ExtArgs>[]
      lineageDownstream: Prisma.$DatasetLineagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      category: $Enums.DatasetCategory
      sourceType: $Enums.DatasetSourceType
      updateFrequency: $Enums.UpdateFrequency
      schema: Prisma.JsonValue
      metadata: Prisma.JsonValue
      qualityScore: number | null
      status: $Enums.DatasetStatus
      tags: string[]
      sourceConfig: Prisma.JsonValue
      lastIngestion: Date | null
      nextIngestion: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataset"]>
    composites: {}
  }

  type DatasetGetPayload<S extends boolean | null | undefined | DatasetDefaultArgs> = $Result.GetResult<Prisma.$DatasetPayload, S>

  type DatasetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DatasetCountAggregateInputType | true
    }

  export interface DatasetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dataset'], meta: { name: 'Dataset' } }
    /**
     * Find zero or one Dataset that matches the filter.
     * @param {DatasetFindUniqueArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetFindUniqueArgs>(args: SelectSubset<T, DatasetFindUniqueArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dataset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetFindUniqueOrThrowArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dataset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindFirstArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetFindFirstArgs>(args?: SelectSubset<T, DatasetFindFirstArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dataset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindFirstOrThrowArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Datasets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datasets
     * const datasets = await prisma.dataset.findMany()
     * 
     * // Get first 10 Datasets
     * const datasets = await prisma.dataset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetWithIdOnly = await prisma.dataset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetFindManyArgs>(args?: SelectSubset<T, DatasetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dataset.
     * @param {DatasetCreateArgs} args - Arguments to create a Dataset.
     * @example
     * // Create one Dataset
     * const Dataset = await prisma.dataset.create({
     *   data: {
     *     // ... data to create a Dataset
     *   }
     * })
     * 
     */
    create<T extends DatasetCreateArgs>(args: SelectSubset<T, DatasetCreateArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Datasets.
     * @param {DatasetCreateManyArgs} args - Arguments to create many Datasets.
     * @example
     * // Create many Datasets
     * const dataset = await prisma.dataset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetCreateManyArgs>(args?: SelectSubset<T, DatasetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Datasets and returns the data saved in the database.
     * @param {DatasetCreateManyAndReturnArgs} args - Arguments to create many Datasets.
     * @example
     * // Create many Datasets
     * const dataset = await prisma.dataset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Datasets and only return the `id`
     * const datasetWithIdOnly = await prisma.dataset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dataset.
     * @param {DatasetDeleteArgs} args - Arguments to delete one Dataset.
     * @example
     * // Delete one Dataset
     * const Dataset = await prisma.dataset.delete({
     *   where: {
     *     // ... filter to delete one Dataset
     *   }
     * })
     * 
     */
    delete<T extends DatasetDeleteArgs>(args: SelectSubset<T, DatasetDeleteArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dataset.
     * @param {DatasetUpdateArgs} args - Arguments to update one Dataset.
     * @example
     * // Update one Dataset
     * const dataset = await prisma.dataset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetUpdateArgs>(args: SelectSubset<T, DatasetUpdateArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Datasets.
     * @param {DatasetDeleteManyArgs} args - Arguments to filter Datasets to delete.
     * @example
     * // Delete a few Datasets
     * const { count } = await prisma.dataset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetDeleteManyArgs>(args?: SelectSubset<T, DatasetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datasets
     * const dataset = await prisma.dataset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetUpdateManyArgs>(args: SelectSubset<T, DatasetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dataset.
     * @param {DatasetUpsertArgs} args - Arguments to update or create a Dataset.
     * @example
     * // Update or create a Dataset
     * const dataset = await prisma.dataset.upsert({
     *   create: {
     *     // ... data to create a Dataset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dataset we want to update
     *   }
     * })
     */
    upsert<T extends DatasetUpsertArgs>(args: SelectSubset<T, DatasetUpsertArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Datasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetCountArgs} args - Arguments to filter Datasets to count.
     * @example
     * // Count the number of Datasets
     * const count = await prisma.dataset.count({
     *   where: {
     *     // ... the filter for the Datasets we want to count
     *   }
     * })
    **/
    count<T extends DatasetCountArgs>(
      args?: Subset<T, DatasetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetAggregateArgs>(args: Subset<T, DatasetAggregateArgs>): Prisma.PrismaPromise<GetDatasetAggregateType<T>>

    /**
     * Group by Dataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetGroupByArgs['orderBy'] }
        : { orderBy?: DatasetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dataset model
   */
  readonly fields: DatasetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dataset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends Dataset$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "findMany"> | Null>
    qualityReports<T extends Dataset$qualityReportsArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$qualityReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "findMany"> | Null>
    ingestionJobs<T extends Dataset$ingestionJobsArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$ingestionJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findMany"> | Null>
    lineageUpstream<T extends Dataset$lineageUpstreamArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$lineageUpstreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findMany"> | Null>
    lineageDownstream<T extends Dataset$lineageDownstreamArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$lineageDownstreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dataset model
   */ 
  interface DatasetFieldRefs {
    readonly id: FieldRef<"Dataset", 'String'>
    readonly name: FieldRef<"Dataset", 'String'>
    readonly displayName: FieldRef<"Dataset", 'String'>
    readonly description: FieldRef<"Dataset", 'String'>
    readonly category: FieldRef<"Dataset", 'DatasetCategory'>
    readonly sourceType: FieldRef<"Dataset", 'DatasetSourceType'>
    readonly updateFrequency: FieldRef<"Dataset", 'UpdateFrequency'>
    readonly schema: FieldRef<"Dataset", 'Json'>
    readonly metadata: FieldRef<"Dataset", 'Json'>
    readonly qualityScore: FieldRef<"Dataset", 'Float'>
    readonly status: FieldRef<"Dataset", 'DatasetStatus'>
    readonly tags: FieldRef<"Dataset", 'String[]'>
    readonly sourceConfig: FieldRef<"Dataset", 'Json'>
    readonly lastIngestion: FieldRef<"Dataset", 'DateTime'>
    readonly nextIngestion: FieldRef<"Dataset", 'DateTime'>
    readonly createdAt: FieldRef<"Dataset", 'DateTime'>
    readonly updatedAt: FieldRef<"Dataset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dataset findUnique
   */
  export type DatasetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset findUniqueOrThrow
   */
  export type DatasetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset findFirst
   */
  export type DatasetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Datasets.
     */
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Dataset findFirstOrThrow
   */
  export type DatasetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Datasets.
     */
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Dataset findMany
   */
  export type DatasetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Datasets to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Dataset create
   */
  export type DatasetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The data needed to create a Dataset.
     */
    data: XOR<DatasetCreateInput, DatasetUncheckedCreateInput>
  }

  /**
   * Dataset createMany
   */
  export type DatasetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Datasets.
     */
    data: DatasetCreateManyInput | DatasetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dataset createManyAndReturn
   */
  export type DatasetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Datasets.
     */
    data: DatasetCreateManyInput | DatasetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dataset update
   */
  export type DatasetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The data needed to update a Dataset.
     */
    data: XOR<DatasetUpdateInput, DatasetUncheckedUpdateInput>
    /**
     * Choose, which Dataset to update.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset updateMany
   */
  export type DatasetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Datasets.
     */
    data: XOR<DatasetUpdateManyMutationInput, DatasetUncheckedUpdateManyInput>
    /**
     * Filter which Datasets to update
     */
    where?: DatasetWhereInput
  }

  /**
   * Dataset upsert
   */
  export type DatasetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The filter to search for the Dataset to update in case it exists.
     */
    where: DatasetWhereUniqueInput
    /**
     * In case the Dataset found by the `where` argument doesn't exist, create a new Dataset with this data.
     */
    create: XOR<DatasetCreateInput, DatasetUncheckedCreateInput>
    /**
     * In case the Dataset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetUpdateInput, DatasetUncheckedUpdateInput>
  }

  /**
   * Dataset delete
   */
  export type DatasetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter which Dataset to delete.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset deleteMany
   */
  export type DatasetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Datasets to delete
     */
    where?: DatasetWhereInput
  }

  /**
   * Dataset.versions
   */
  export type Dataset$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    where?: DatasetVersionWhereInput
    orderBy?: DatasetVersionOrderByWithRelationInput | DatasetVersionOrderByWithRelationInput[]
    cursor?: DatasetVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetVersionScalarFieldEnum | DatasetVersionScalarFieldEnum[]
  }

  /**
   * Dataset.qualityReports
   */
  export type Dataset$qualityReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    where?: DataQualityReportWhereInput
    orderBy?: DataQualityReportOrderByWithRelationInput | DataQualityReportOrderByWithRelationInput[]
    cursor?: DataQualityReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataQualityReportScalarFieldEnum | DataQualityReportScalarFieldEnum[]
  }

  /**
   * Dataset.ingestionJobs
   */
  export type Dataset$ingestionJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    where?: IngestionJobWhereInput
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    cursor?: IngestionJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * Dataset.lineageUpstream
   */
  export type Dataset$lineageUpstreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    where?: DatasetLineageWhereInput
    orderBy?: DatasetLineageOrderByWithRelationInput | DatasetLineageOrderByWithRelationInput[]
    cursor?: DatasetLineageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetLineageScalarFieldEnum | DatasetLineageScalarFieldEnum[]
  }

  /**
   * Dataset.lineageDownstream
   */
  export type Dataset$lineageDownstreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    where?: DatasetLineageWhereInput
    orderBy?: DatasetLineageOrderByWithRelationInput | DatasetLineageOrderByWithRelationInput[]
    cursor?: DatasetLineageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetLineageScalarFieldEnum | DatasetLineageScalarFieldEnum[]
  }

  /**
   * Dataset without action
   */
  export type DatasetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
  }


  /**
   * Model DatasetVersion
   */

  export type AggregateDatasetVersion = {
    _count: DatasetVersionCountAggregateOutputType | null
    _avg: DatasetVersionAvgAggregateOutputType | null
    _sum: DatasetVersionSumAggregateOutputType | null
    _min: DatasetVersionMinAggregateOutputType | null
    _max: DatasetVersionMaxAggregateOutputType | null
  }

  export type DatasetVersionAvgAggregateOutputType = {
    size: number | null
    recordCount: number | null
  }

  export type DatasetVersionSumAggregateOutputType = {
    size: bigint | null
    recordCount: bigint | null
  }

  export type DatasetVersionMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    version: string | null
    description: string | null
    size: bigint | null
    recordCount: bigint | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type DatasetVersionMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    version: string | null
    description: string | null
    size: bigint | null
    recordCount: bigint | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type DatasetVersionCountAggregateOutputType = {
    id: number
    datasetId: number
    version: number
    description: number
    schema: number
    metadata: number
    size: number
    recordCount: number
    checksums: number
    location: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type DatasetVersionAvgAggregateInputType = {
    size?: true
    recordCount?: true
  }

  export type DatasetVersionSumAggregateInputType = {
    size?: true
    recordCount?: true
  }

  export type DatasetVersionMinAggregateInputType = {
    id?: true
    datasetId?: true
    version?: true
    description?: true
    size?: true
    recordCount?: true
    location?: true
    isActive?: true
    createdAt?: true
  }

  export type DatasetVersionMaxAggregateInputType = {
    id?: true
    datasetId?: true
    version?: true
    description?: true
    size?: true
    recordCount?: true
    location?: true
    isActive?: true
    createdAt?: true
  }

  export type DatasetVersionCountAggregateInputType = {
    id?: true
    datasetId?: true
    version?: true
    description?: true
    schema?: true
    metadata?: true
    size?: true
    recordCount?: true
    checksums?: true
    location?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type DatasetVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetVersion to aggregate.
     */
    where?: DatasetVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetVersions to fetch.
     */
    orderBy?: DatasetVersionOrderByWithRelationInput | DatasetVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatasetVersions
    **/
    _count?: true | DatasetVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatasetVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatasetVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetVersionMaxAggregateInputType
  }

  export type GetDatasetVersionAggregateType<T extends DatasetVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasetVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasetVersion[P]>
      : GetScalarType<T[P], AggregateDatasetVersion[P]>
  }




  export type DatasetVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetVersionWhereInput
    orderBy?: DatasetVersionOrderByWithAggregationInput | DatasetVersionOrderByWithAggregationInput[]
    by: DatasetVersionScalarFieldEnum[] | DatasetVersionScalarFieldEnum
    having?: DatasetVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetVersionCountAggregateInputType | true
    _avg?: DatasetVersionAvgAggregateInputType
    _sum?: DatasetVersionSumAggregateInputType
    _min?: DatasetVersionMinAggregateInputType
    _max?: DatasetVersionMaxAggregateInputType
  }

  export type DatasetVersionGroupByOutputType = {
    id: string
    datasetId: string
    version: string
    description: string | null
    schema: JsonValue
    metadata: JsonValue
    size: bigint | null
    recordCount: bigint | null
    checksums: JsonValue
    location: string
    isActive: boolean
    createdAt: Date
    _count: DatasetVersionCountAggregateOutputType | null
    _avg: DatasetVersionAvgAggregateOutputType | null
    _sum: DatasetVersionSumAggregateOutputType | null
    _min: DatasetVersionMinAggregateOutputType | null
    _max: DatasetVersionMaxAggregateOutputType | null
  }

  type GetDatasetVersionGroupByPayload<T extends DatasetVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetVersionGroupByOutputType[P]>
        }
      >
    >


  export type DatasetVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    version?: boolean
    description?: boolean
    schema?: boolean
    metadata?: boolean
    size?: boolean
    recordCount?: boolean
    checksums?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetVersion"]>

  export type DatasetVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    version?: boolean
    description?: boolean
    schema?: boolean
    metadata?: boolean
    size?: boolean
    recordCount?: boolean
    checksums?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetVersion"]>

  export type DatasetVersionSelectScalar = {
    id?: boolean
    datasetId?: boolean
    version?: boolean
    description?: boolean
    schema?: boolean
    metadata?: boolean
    size?: boolean
    recordCount?: boolean
    checksums?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type DatasetVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type DatasetVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $DatasetVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatasetVersion"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string
      version: string
      description: string | null
      schema: Prisma.JsonValue
      metadata: Prisma.JsonValue
      size: bigint | null
      recordCount: bigint | null
      checksums: Prisma.JsonValue
      location: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["datasetVersion"]>
    composites: {}
  }

  type DatasetVersionGetPayload<S extends boolean | null | undefined | DatasetVersionDefaultArgs> = $Result.GetResult<Prisma.$DatasetVersionPayload, S>

  type DatasetVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DatasetVersionCountAggregateInputType | true
    }

  export interface DatasetVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatasetVersion'], meta: { name: 'DatasetVersion' } }
    /**
     * Find zero or one DatasetVersion that matches the filter.
     * @param {DatasetVersionFindUniqueArgs} args - Arguments to find a DatasetVersion
     * @example
     * // Get one DatasetVersion
     * const datasetVersion = await prisma.datasetVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetVersionFindUniqueArgs>(args: SelectSubset<T, DatasetVersionFindUniqueArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DatasetVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetVersionFindUniqueOrThrowArgs} args - Arguments to find a DatasetVersion
     * @example
     * // Get one DatasetVersion
     * const datasetVersion = await prisma.datasetVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DatasetVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionFindFirstArgs} args - Arguments to find a DatasetVersion
     * @example
     * // Get one DatasetVersion
     * const datasetVersion = await prisma.datasetVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetVersionFindFirstArgs>(args?: SelectSubset<T, DatasetVersionFindFirstArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DatasetVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionFindFirstOrThrowArgs} args - Arguments to find a DatasetVersion
     * @example
     * // Get one DatasetVersion
     * const datasetVersion = await prisma.datasetVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DatasetVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatasetVersions
     * const datasetVersions = await prisma.datasetVersion.findMany()
     * 
     * // Get first 10 DatasetVersions
     * const datasetVersions = await prisma.datasetVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetVersionWithIdOnly = await prisma.datasetVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetVersionFindManyArgs>(args?: SelectSubset<T, DatasetVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DatasetVersion.
     * @param {DatasetVersionCreateArgs} args - Arguments to create a DatasetVersion.
     * @example
     * // Create one DatasetVersion
     * const DatasetVersion = await prisma.datasetVersion.create({
     *   data: {
     *     // ... data to create a DatasetVersion
     *   }
     * })
     * 
     */
    create<T extends DatasetVersionCreateArgs>(args: SelectSubset<T, DatasetVersionCreateArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DatasetVersions.
     * @param {DatasetVersionCreateManyArgs} args - Arguments to create many DatasetVersions.
     * @example
     * // Create many DatasetVersions
     * const datasetVersion = await prisma.datasetVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetVersionCreateManyArgs>(args?: SelectSubset<T, DatasetVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatasetVersions and returns the data saved in the database.
     * @param {DatasetVersionCreateManyAndReturnArgs} args - Arguments to create many DatasetVersions.
     * @example
     * // Create many DatasetVersions
     * const datasetVersion = await prisma.datasetVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatasetVersions and only return the `id`
     * const datasetVersionWithIdOnly = await prisma.datasetVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DatasetVersion.
     * @param {DatasetVersionDeleteArgs} args - Arguments to delete one DatasetVersion.
     * @example
     * // Delete one DatasetVersion
     * const DatasetVersion = await prisma.datasetVersion.delete({
     *   where: {
     *     // ... filter to delete one DatasetVersion
     *   }
     * })
     * 
     */
    delete<T extends DatasetVersionDeleteArgs>(args: SelectSubset<T, DatasetVersionDeleteArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DatasetVersion.
     * @param {DatasetVersionUpdateArgs} args - Arguments to update one DatasetVersion.
     * @example
     * // Update one DatasetVersion
     * const datasetVersion = await prisma.datasetVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetVersionUpdateArgs>(args: SelectSubset<T, DatasetVersionUpdateArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DatasetVersions.
     * @param {DatasetVersionDeleteManyArgs} args - Arguments to filter DatasetVersions to delete.
     * @example
     * // Delete a few DatasetVersions
     * const { count } = await prisma.datasetVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetVersionDeleteManyArgs>(args?: SelectSubset<T, DatasetVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatasetVersions
     * const datasetVersion = await prisma.datasetVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetVersionUpdateManyArgs>(args: SelectSubset<T, DatasetVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatasetVersion.
     * @param {DatasetVersionUpsertArgs} args - Arguments to update or create a DatasetVersion.
     * @example
     * // Update or create a DatasetVersion
     * const datasetVersion = await prisma.datasetVersion.upsert({
     *   create: {
     *     // ... data to create a DatasetVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatasetVersion we want to update
     *   }
     * })
     */
    upsert<T extends DatasetVersionUpsertArgs>(args: SelectSubset<T, DatasetVersionUpsertArgs<ExtArgs>>): Prisma__DatasetVersionClient<$Result.GetResult<Prisma.$DatasetVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DatasetVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionCountArgs} args - Arguments to filter DatasetVersions to count.
     * @example
     * // Count the number of DatasetVersions
     * const count = await prisma.datasetVersion.count({
     *   where: {
     *     // ... the filter for the DatasetVersions we want to count
     *   }
     * })
    **/
    count<T extends DatasetVersionCountArgs>(
      args?: Subset<T, DatasetVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatasetVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetVersionAggregateArgs>(args: Subset<T, DatasetVersionAggregateArgs>): Prisma.PrismaPromise<GetDatasetVersionAggregateType<T>>

    /**
     * Group by DatasetVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetVersionGroupByArgs['orderBy'] }
        : { orderBy?: DatasetVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatasetVersion model
   */
  readonly fields: DatasetVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatasetVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatasetVersion model
   */ 
  interface DatasetVersionFieldRefs {
    readonly id: FieldRef<"DatasetVersion", 'String'>
    readonly datasetId: FieldRef<"DatasetVersion", 'String'>
    readonly version: FieldRef<"DatasetVersion", 'String'>
    readonly description: FieldRef<"DatasetVersion", 'String'>
    readonly schema: FieldRef<"DatasetVersion", 'Json'>
    readonly metadata: FieldRef<"DatasetVersion", 'Json'>
    readonly size: FieldRef<"DatasetVersion", 'BigInt'>
    readonly recordCount: FieldRef<"DatasetVersion", 'BigInt'>
    readonly checksums: FieldRef<"DatasetVersion", 'Json'>
    readonly location: FieldRef<"DatasetVersion", 'String'>
    readonly isActive: FieldRef<"DatasetVersion", 'Boolean'>
    readonly createdAt: FieldRef<"DatasetVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatasetVersion findUnique
   */
  export type DatasetVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * Filter, which DatasetVersion to fetch.
     */
    where: DatasetVersionWhereUniqueInput
  }

  /**
   * DatasetVersion findUniqueOrThrow
   */
  export type DatasetVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * Filter, which DatasetVersion to fetch.
     */
    where: DatasetVersionWhereUniqueInput
  }

  /**
   * DatasetVersion findFirst
   */
  export type DatasetVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * Filter, which DatasetVersion to fetch.
     */
    where?: DatasetVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetVersions to fetch.
     */
    orderBy?: DatasetVersionOrderByWithRelationInput | DatasetVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetVersions.
     */
    cursor?: DatasetVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetVersions.
     */
    distinct?: DatasetVersionScalarFieldEnum | DatasetVersionScalarFieldEnum[]
  }

  /**
   * DatasetVersion findFirstOrThrow
   */
  export type DatasetVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * Filter, which DatasetVersion to fetch.
     */
    where?: DatasetVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetVersions to fetch.
     */
    orderBy?: DatasetVersionOrderByWithRelationInput | DatasetVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetVersions.
     */
    cursor?: DatasetVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetVersions.
     */
    distinct?: DatasetVersionScalarFieldEnum | DatasetVersionScalarFieldEnum[]
  }

  /**
   * DatasetVersion findMany
   */
  export type DatasetVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * Filter, which DatasetVersions to fetch.
     */
    where?: DatasetVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetVersions to fetch.
     */
    orderBy?: DatasetVersionOrderByWithRelationInput | DatasetVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatasetVersions.
     */
    cursor?: DatasetVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetVersions.
     */
    skip?: number
    distinct?: DatasetVersionScalarFieldEnum | DatasetVersionScalarFieldEnum[]
  }

  /**
   * DatasetVersion create
   */
  export type DatasetVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DatasetVersion.
     */
    data: XOR<DatasetVersionCreateInput, DatasetVersionUncheckedCreateInput>
  }

  /**
   * DatasetVersion createMany
   */
  export type DatasetVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatasetVersions.
     */
    data: DatasetVersionCreateManyInput | DatasetVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatasetVersion createManyAndReturn
   */
  export type DatasetVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DatasetVersions.
     */
    data: DatasetVersionCreateManyInput | DatasetVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetVersion update
   */
  export type DatasetVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DatasetVersion.
     */
    data: XOR<DatasetVersionUpdateInput, DatasetVersionUncheckedUpdateInput>
    /**
     * Choose, which DatasetVersion to update.
     */
    where: DatasetVersionWhereUniqueInput
  }

  /**
   * DatasetVersion updateMany
   */
  export type DatasetVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatasetVersions.
     */
    data: XOR<DatasetVersionUpdateManyMutationInput, DatasetVersionUncheckedUpdateManyInput>
    /**
     * Filter which DatasetVersions to update
     */
    where?: DatasetVersionWhereInput
  }

  /**
   * DatasetVersion upsert
   */
  export type DatasetVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DatasetVersion to update in case it exists.
     */
    where: DatasetVersionWhereUniqueInput
    /**
     * In case the DatasetVersion found by the `where` argument doesn't exist, create a new DatasetVersion with this data.
     */
    create: XOR<DatasetVersionCreateInput, DatasetVersionUncheckedCreateInput>
    /**
     * In case the DatasetVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetVersionUpdateInput, DatasetVersionUncheckedUpdateInput>
  }

  /**
   * DatasetVersion delete
   */
  export type DatasetVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
    /**
     * Filter which DatasetVersion to delete.
     */
    where: DatasetVersionWhereUniqueInput
  }

  /**
   * DatasetVersion deleteMany
   */
  export type DatasetVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetVersions to delete
     */
    where?: DatasetVersionWhereInput
  }

  /**
   * DatasetVersion without action
   */
  export type DatasetVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetVersion
     */
    select?: DatasetVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetVersionInclude<ExtArgs> | null
  }


  /**
   * Model DataQualityReport
   */

  export type AggregateDataQualityReport = {
    _count: DataQualityReportCountAggregateOutputType | null
    _avg: DataQualityReportAvgAggregateOutputType | null
    _sum: DataQualityReportSumAggregateOutputType | null
    _min: DataQualityReportMinAggregateOutputType | null
    _max: DataQualityReportMaxAggregateOutputType | null
  }

  export type DataQualityReportAvgAggregateOutputType = {
    overallScore: number | null
    completeness: number | null
    accuracy: number | null
    consistency: number | null
    validity: number | null
    freshness: number | null
    processingTime: number | null
    recordsProcessed: number | null
  }

  export type DataQualityReportSumAggregateOutputType = {
    overallScore: number | null
    completeness: number | null
    accuracy: number | null
    consistency: number | null
    validity: number | null
    freshness: number | null
    processingTime: number | null
    recordsProcessed: bigint | null
  }

  export type DataQualityReportMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    reportDate: Date | null
    overallScore: number | null
    completeness: number | null
    accuracy: number | null
    consistency: number | null
    validity: number | null
    freshness: number | null
    processingTime: number | null
    recordsProcessed: bigint | null
    createdAt: Date | null
  }

  export type DataQualityReportMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    reportDate: Date | null
    overallScore: number | null
    completeness: number | null
    accuracy: number | null
    consistency: number | null
    validity: number | null
    freshness: number | null
    processingTime: number | null
    recordsProcessed: bigint | null
    createdAt: Date | null
  }

  export type DataQualityReportCountAggregateOutputType = {
    id: number
    datasetId: number
    reportDate: number
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: number
    anomalies: number
    issues: number
    recommendations: number
    processingTime: number
    recordsProcessed: number
    createdAt: number
    _all: number
  }


  export type DataQualityReportAvgAggregateInputType = {
    overallScore?: true
    completeness?: true
    accuracy?: true
    consistency?: true
    validity?: true
    freshness?: true
    processingTime?: true
    recordsProcessed?: true
  }

  export type DataQualityReportSumAggregateInputType = {
    overallScore?: true
    completeness?: true
    accuracy?: true
    consistency?: true
    validity?: true
    freshness?: true
    processingTime?: true
    recordsProcessed?: true
  }

  export type DataQualityReportMinAggregateInputType = {
    id?: true
    datasetId?: true
    reportDate?: true
    overallScore?: true
    completeness?: true
    accuracy?: true
    consistency?: true
    validity?: true
    freshness?: true
    processingTime?: true
    recordsProcessed?: true
    createdAt?: true
  }

  export type DataQualityReportMaxAggregateInputType = {
    id?: true
    datasetId?: true
    reportDate?: true
    overallScore?: true
    completeness?: true
    accuracy?: true
    consistency?: true
    validity?: true
    freshness?: true
    processingTime?: true
    recordsProcessed?: true
    createdAt?: true
  }

  export type DataQualityReportCountAggregateInputType = {
    id?: true
    datasetId?: true
    reportDate?: true
    overallScore?: true
    completeness?: true
    accuracy?: true
    consistency?: true
    validity?: true
    freshness?: true
    metrics?: true
    anomalies?: true
    issues?: true
    recommendations?: true
    processingTime?: true
    recordsProcessed?: true
    createdAt?: true
    _all?: true
  }

  export type DataQualityReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataQualityReport to aggregate.
     */
    where?: DataQualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityReports to fetch.
     */
    orderBy?: DataQualityReportOrderByWithRelationInput | DataQualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataQualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataQualityReports
    **/
    _count?: true | DataQualityReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataQualityReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataQualityReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataQualityReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataQualityReportMaxAggregateInputType
  }

  export type GetDataQualityReportAggregateType<T extends DataQualityReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDataQualityReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataQualityReport[P]>
      : GetScalarType<T[P], AggregateDataQualityReport[P]>
  }




  export type DataQualityReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataQualityReportWhereInput
    orderBy?: DataQualityReportOrderByWithAggregationInput | DataQualityReportOrderByWithAggregationInput[]
    by: DataQualityReportScalarFieldEnum[] | DataQualityReportScalarFieldEnum
    having?: DataQualityReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataQualityReportCountAggregateInputType | true
    _avg?: DataQualityReportAvgAggregateInputType
    _sum?: DataQualityReportSumAggregateInputType
    _min?: DataQualityReportMinAggregateInputType
    _max?: DataQualityReportMaxAggregateInputType
  }

  export type DataQualityReportGroupByOutputType = {
    id: string
    datasetId: string
    reportDate: Date
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonValue
    anomalies: JsonValue
    issues: JsonValue
    recommendations: JsonValue
    processingTime: number | null
    recordsProcessed: bigint | null
    createdAt: Date
    _count: DataQualityReportCountAggregateOutputType | null
    _avg: DataQualityReportAvgAggregateOutputType | null
    _sum: DataQualityReportSumAggregateOutputType | null
    _min: DataQualityReportMinAggregateOutputType | null
    _max: DataQualityReportMaxAggregateOutputType | null
  }

  type GetDataQualityReportGroupByPayload<T extends DataQualityReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataQualityReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataQualityReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataQualityReportGroupByOutputType[P]>
            : GetScalarType<T[P], DataQualityReportGroupByOutputType[P]>
        }
      >
    >


  export type DataQualityReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    reportDate?: boolean
    overallScore?: boolean
    completeness?: boolean
    accuracy?: boolean
    consistency?: boolean
    validity?: boolean
    freshness?: boolean
    metrics?: boolean
    anomalies?: boolean
    issues?: boolean
    recommendations?: boolean
    processingTime?: boolean
    recordsProcessed?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataQualityReport"]>

  export type DataQualityReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    reportDate?: boolean
    overallScore?: boolean
    completeness?: boolean
    accuracy?: boolean
    consistency?: boolean
    validity?: boolean
    freshness?: boolean
    metrics?: boolean
    anomalies?: boolean
    issues?: boolean
    recommendations?: boolean
    processingTime?: boolean
    recordsProcessed?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataQualityReport"]>

  export type DataQualityReportSelectScalar = {
    id?: boolean
    datasetId?: boolean
    reportDate?: boolean
    overallScore?: boolean
    completeness?: boolean
    accuracy?: boolean
    consistency?: boolean
    validity?: boolean
    freshness?: boolean
    metrics?: boolean
    anomalies?: boolean
    issues?: boolean
    recommendations?: boolean
    processingTime?: boolean
    recordsProcessed?: boolean
    createdAt?: boolean
  }

  export type DataQualityReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type DataQualityReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $DataQualityReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataQualityReport"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string
      reportDate: Date
      overallScore: number
      completeness: number
      accuracy: number
      consistency: number
      validity: number
      freshness: number
      metrics: Prisma.JsonValue
      anomalies: Prisma.JsonValue
      issues: Prisma.JsonValue
      recommendations: Prisma.JsonValue
      processingTime: number | null
      recordsProcessed: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["dataQualityReport"]>
    composites: {}
  }

  type DataQualityReportGetPayload<S extends boolean | null | undefined | DataQualityReportDefaultArgs> = $Result.GetResult<Prisma.$DataQualityReportPayload, S>

  type DataQualityReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataQualityReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataQualityReportCountAggregateInputType | true
    }

  export interface DataQualityReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataQualityReport'], meta: { name: 'DataQualityReport' } }
    /**
     * Find zero or one DataQualityReport that matches the filter.
     * @param {DataQualityReportFindUniqueArgs} args - Arguments to find a DataQualityReport
     * @example
     * // Get one DataQualityReport
     * const dataQualityReport = await prisma.dataQualityReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataQualityReportFindUniqueArgs>(args: SelectSubset<T, DataQualityReportFindUniqueArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataQualityReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataQualityReportFindUniqueOrThrowArgs} args - Arguments to find a DataQualityReport
     * @example
     * // Get one DataQualityReport
     * const dataQualityReport = await prisma.dataQualityReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataQualityReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DataQualityReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataQualityReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportFindFirstArgs} args - Arguments to find a DataQualityReport
     * @example
     * // Get one DataQualityReport
     * const dataQualityReport = await prisma.dataQualityReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataQualityReportFindFirstArgs>(args?: SelectSubset<T, DataQualityReportFindFirstArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataQualityReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportFindFirstOrThrowArgs} args - Arguments to find a DataQualityReport
     * @example
     * // Get one DataQualityReport
     * const dataQualityReport = await prisma.dataQualityReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataQualityReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DataQualityReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataQualityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataQualityReports
     * const dataQualityReports = await prisma.dataQualityReport.findMany()
     * 
     * // Get first 10 DataQualityReports
     * const dataQualityReports = await prisma.dataQualityReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataQualityReportWithIdOnly = await prisma.dataQualityReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataQualityReportFindManyArgs>(args?: SelectSubset<T, DataQualityReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataQualityReport.
     * @param {DataQualityReportCreateArgs} args - Arguments to create a DataQualityReport.
     * @example
     * // Create one DataQualityReport
     * const DataQualityReport = await prisma.dataQualityReport.create({
     *   data: {
     *     // ... data to create a DataQualityReport
     *   }
     * })
     * 
     */
    create<T extends DataQualityReportCreateArgs>(args: SelectSubset<T, DataQualityReportCreateArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataQualityReports.
     * @param {DataQualityReportCreateManyArgs} args - Arguments to create many DataQualityReports.
     * @example
     * // Create many DataQualityReports
     * const dataQualityReport = await prisma.dataQualityReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataQualityReportCreateManyArgs>(args?: SelectSubset<T, DataQualityReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataQualityReports and returns the data saved in the database.
     * @param {DataQualityReportCreateManyAndReturnArgs} args - Arguments to create many DataQualityReports.
     * @example
     * // Create many DataQualityReports
     * const dataQualityReport = await prisma.dataQualityReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataQualityReports and only return the `id`
     * const dataQualityReportWithIdOnly = await prisma.dataQualityReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataQualityReportCreateManyAndReturnArgs>(args?: SelectSubset<T, DataQualityReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataQualityReport.
     * @param {DataQualityReportDeleteArgs} args - Arguments to delete one DataQualityReport.
     * @example
     * // Delete one DataQualityReport
     * const DataQualityReport = await prisma.dataQualityReport.delete({
     *   where: {
     *     // ... filter to delete one DataQualityReport
     *   }
     * })
     * 
     */
    delete<T extends DataQualityReportDeleteArgs>(args: SelectSubset<T, DataQualityReportDeleteArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataQualityReport.
     * @param {DataQualityReportUpdateArgs} args - Arguments to update one DataQualityReport.
     * @example
     * // Update one DataQualityReport
     * const dataQualityReport = await prisma.dataQualityReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataQualityReportUpdateArgs>(args: SelectSubset<T, DataQualityReportUpdateArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataQualityReports.
     * @param {DataQualityReportDeleteManyArgs} args - Arguments to filter DataQualityReports to delete.
     * @example
     * // Delete a few DataQualityReports
     * const { count } = await prisma.dataQualityReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataQualityReportDeleteManyArgs>(args?: SelectSubset<T, DataQualityReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataQualityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataQualityReports
     * const dataQualityReport = await prisma.dataQualityReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataQualityReportUpdateManyArgs>(args: SelectSubset<T, DataQualityReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataQualityReport.
     * @param {DataQualityReportUpsertArgs} args - Arguments to update or create a DataQualityReport.
     * @example
     * // Update or create a DataQualityReport
     * const dataQualityReport = await prisma.dataQualityReport.upsert({
     *   create: {
     *     // ... data to create a DataQualityReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataQualityReport we want to update
     *   }
     * })
     */
    upsert<T extends DataQualityReportUpsertArgs>(args: SelectSubset<T, DataQualityReportUpsertArgs<ExtArgs>>): Prisma__DataQualityReportClient<$Result.GetResult<Prisma.$DataQualityReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataQualityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportCountArgs} args - Arguments to filter DataQualityReports to count.
     * @example
     * // Count the number of DataQualityReports
     * const count = await prisma.dataQualityReport.count({
     *   where: {
     *     // ... the filter for the DataQualityReports we want to count
     *   }
     * })
    **/
    count<T extends DataQualityReportCountArgs>(
      args?: Subset<T, DataQualityReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataQualityReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataQualityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataQualityReportAggregateArgs>(args: Subset<T, DataQualityReportAggregateArgs>): Prisma.PrismaPromise<GetDataQualityReportAggregateType<T>>

    /**
     * Group by DataQualityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataQualityReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataQualityReportGroupByArgs['orderBy'] }
        : { orderBy?: DataQualityReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataQualityReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataQualityReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataQualityReport model
   */
  readonly fields: DataQualityReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataQualityReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataQualityReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataQualityReport model
   */ 
  interface DataQualityReportFieldRefs {
    readonly id: FieldRef<"DataQualityReport", 'String'>
    readonly datasetId: FieldRef<"DataQualityReport", 'String'>
    readonly reportDate: FieldRef<"DataQualityReport", 'DateTime'>
    readonly overallScore: FieldRef<"DataQualityReport", 'Float'>
    readonly completeness: FieldRef<"DataQualityReport", 'Float'>
    readonly accuracy: FieldRef<"DataQualityReport", 'Float'>
    readonly consistency: FieldRef<"DataQualityReport", 'Float'>
    readonly validity: FieldRef<"DataQualityReport", 'Float'>
    readonly freshness: FieldRef<"DataQualityReport", 'Float'>
    readonly metrics: FieldRef<"DataQualityReport", 'Json'>
    readonly anomalies: FieldRef<"DataQualityReport", 'Json'>
    readonly issues: FieldRef<"DataQualityReport", 'Json'>
    readonly recommendations: FieldRef<"DataQualityReport", 'Json'>
    readonly processingTime: FieldRef<"DataQualityReport", 'Int'>
    readonly recordsProcessed: FieldRef<"DataQualityReport", 'BigInt'>
    readonly createdAt: FieldRef<"DataQualityReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataQualityReport findUnique
   */
  export type DataQualityReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * Filter, which DataQualityReport to fetch.
     */
    where: DataQualityReportWhereUniqueInput
  }

  /**
   * DataQualityReport findUniqueOrThrow
   */
  export type DataQualityReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * Filter, which DataQualityReport to fetch.
     */
    where: DataQualityReportWhereUniqueInput
  }

  /**
   * DataQualityReport findFirst
   */
  export type DataQualityReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * Filter, which DataQualityReport to fetch.
     */
    where?: DataQualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityReports to fetch.
     */
    orderBy?: DataQualityReportOrderByWithRelationInput | DataQualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataQualityReports.
     */
    cursor?: DataQualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataQualityReports.
     */
    distinct?: DataQualityReportScalarFieldEnum | DataQualityReportScalarFieldEnum[]
  }

  /**
   * DataQualityReport findFirstOrThrow
   */
  export type DataQualityReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * Filter, which DataQualityReport to fetch.
     */
    where?: DataQualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityReports to fetch.
     */
    orderBy?: DataQualityReportOrderByWithRelationInput | DataQualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataQualityReports.
     */
    cursor?: DataQualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataQualityReports.
     */
    distinct?: DataQualityReportScalarFieldEnum | DataQualityReportScalarFieldEnum[]
  }

  /**
   * DataQualityReport findMany
   */
  export type DataQualityReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * Filter, which DataQualityReports to fetch.
     */
    where?: DataQualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityReports to fetch.
     */
    orderBy?: DataQualityReportOrderByWithRelationInput | DataQualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataQualityReports.
     */
    cursor?: DataQualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityReports.
     */
    skip?: number
    distinct?: DataQualityReportScalarFieldEnum | DataQualityReportScalarFieldEnum[]
  }

  /**
   * DataQualityReport create
   */
  export type DataQualityReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DataQualityReport.
     */
    data: XOR<DataQualityReportCreateInput, DataQualityReportUncheckedCreateInput>
  }

  /**
   * DataQualityReport createMany
   */
  export type DataQualityReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataQualityReports.
     */
    data: DataQualityReportCreateManyInput | DataQualityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataQualityReport createManyAndReturn
   */
  export type DataQualityReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataQualityReports.
     */
    data: DataQualityReportCreateManyInput | DataQualityReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataQualityReport update
   */
  export type DataQualityReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DataQualityReport.
     */
    data: XOR<DataQualityReportUpdateInput, DataQualityReportUncheckedUpdateInput>
    /**
     * Choose, which DataQualityReport to update.
     */
    where: DataQualityReportWhereUniqueInput
  }

  /**
   * DataQualityReport updateMany
   */
  export type DataQualityReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataQualityReports.
     */
    data: XOR<DataQualityReportUpdateManyMutationInput, DataQualityReportUncheckedUpdateManyInput>
    /**
     * Filter which DataQualityReports to update
     */
    where?: DataQualityReportWhereInput
  }

  /**
   * DataQualityReport upsert
   */
  export type DataQualityReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DataQualityReport to update in case it exists.
     */
    where: DataQualityReportWhereUniqueInput
    /**
     * In case the DataQualityReport found by the `where` argument doesn't exist, create a new DataQualityReport with this data.
     */
    create: XOR<DataQualityReportCreateInput, DataQualityReportUncheckedCreateInput>
    /**
     * In case the DataQualityReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataQualityReportUpdateInput, DataQualityReportUncheckedUpdateInput>
  }

  /**
   * DataQualityReport delete
   */
  export type DataQualityReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
    /**
     * Filter which DataQualityReport to delete.
     */
    where: DataQualityReportWhereUniqueInput
  }

  /**
   * DataQualityReport deleteMany
   */
  export type DataQualityReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataQualityReports to delete
     */
    where?: DataQualityReportWhereInput
  }

  /**
   * DataQualityReport without action
   */
  export type DataQualityReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityReport
     */
    select?: DataQualityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataQualityReportInclude<ExtArgs> | null
  }


  /**
   * Model IngestionJob
   */

  export type AggregateIngestionJob = {
    _count: IngestionJobCountAggregateOutputType | null
    _avg: IngestionJobAvgAggregateOutputType | null
    _sum: IngestionJobSumAggregateOutputType | null
    _min: IngestionJobMinAggregateOutputType | null
    _max: IngestionJobMaxAggregateOutputType | null
  }

  export type IngestionJobAvgAggregateOutputType = {
    recordsProcessed: number | null
    recordsSucceeded: number | null
    recordsFailed: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type IngestionJobSumAggregateOutputType = {
    recordsProcessed: bigint | null
    recordsSucceeded: bigint | null
    recordsFailed: bigint | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type IngestionJobMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    jobType: $Enums.IngestionJobType | null
    status: $Enums.JobStatus | null
    schedule: string | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    logs: string | null
    recordsProcessed: bigint | null
    recordsSucceeded: bigint | null
    recordsFailed: bigint | null
    retryCount: number | null
    maxRetries: number | null
    nextRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IngestionJobMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    jobType: $Enums.IngestionJobType | null
    status: $Enums.JobStatus | null
    schedule: string | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    logs: string | null
    recordsProcessed: bigint | null
    recordsSucceeded: bigint | null
    recordsFailed: bigint | null
    retryCount: number | null
    maxRetries: number | null
    nextRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IngestionJobCountAggregateOutputType = {
    id: number
    datasetId: number
    jobType: number
    status: number
    config: number
    schedule: number
    startedAt: number
    completedAt: number
    errorMessage: number
    logs: number
    recordsProcessed: number
    recordsSucceeded: number
    recordsFailed: number
    metrics: number
    retryCount: number
    maxRetries: number
    nextRetryAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IngestionJobAvgAggregateInputType = {
    recordsProcessed?: true
    recordsSucceeded?: true
    recordsFailed?: true
    retryCount?: true
    maxRetries?: true
  }

  export type IngestionJobSumAggregateInputType = {
    recordsProcessed?: true
    recordsSucceeded?: true
    recordsFailed?: true
    retryCount?: true
    maxRetries?: true
  }

  export type IngestionJobMinAggregateInputType = {
    id?: true
    datasetId?: true
    jobType?: true
    status?: true
    schedule?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    logs?: true
    recordsProcessed?: true
    recordsSucceeded?: true
    recordsFailed?: true
    retryCount?: true
    maxRetries?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IngestionJobMaxAggregateInputType = {
    id?: true
    datasetId?: true
    jobType?: true
    status?: true
    schedule?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    logs?: true
    recordsProcessed?: true
    recordsSucceeded?: true
    recordsFailed?: true
    retryCount?: true
    maxRetries?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IngestionJobCountAggregateInputType = {
    id?: true
    datasetId?: true
    jobType?: true
    status?: true
    config?: true
    schedule?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    logs?: true
    recordsProcessed?: true
    recordsSucceeded?: true
    recordsFailed?: true
    metrics?: true
    retryCount?: true
    maxRetries?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IngestionJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestionJob to aggregate.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngestionJobs
    **/
    _count?: true | IngestionJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngestionJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngestionJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngestionJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngestionJobMaxAggregateInputType
  }

  export type GetIngestionJobAggregateType<T extends IngestionJobAggregateArgs> = {
        [P in keyof T & keyof AggregateIngestionJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestionJob[P]>
      : GetScalarType<T[P], AggregateIngestionJob[P]>
  }




  export type IngestionJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestionJobWhereInput
    orderBy?: IngestionJobOrderByWithAggregationInput | IngestionJobOrderByWithAggregationInput[]
    by: IngestionJobScalarFieldEnum[] | IngestionJobScalarFieldEnum
    having?: IngestionJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngestionJobCountAggregateInputType | true
    _avg?: IngestionJobAvgAggregateInputType
    _sum?: IngestionJobSumAggregateInputType
    _min?: IngestionJobMinAggregateInputType
    _max?: IngestionJobMaxAggregateInputType
  }

  export type IngestionJobGroupByOutputType = {
    id: string
    datasetId: string
    jobType: $Enums.IngestionJobType
    status: $Enums.JobStatus
    config: JsonValue
    schedule: string | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    logs: string | null
    recordsProcessed: bigint | null
    recordsSucceeded: bigint | null
    recordsFailed: bigint | null
    metrics: JsonValue | null
    retryCount: number
    maxRetries: number
    nextRetryAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IngestionJobCountAggregateOutputType | null
    _avg: IngestionJobAvgAggregateOutputType | null
    _sum: IngestionJobSumAggregateOutputType | null
    _min: IngestionJobMinAggregateOutputType | null
    _max: IngestionJobMaxAggregateOutputType | null
  }

  type GetIngestionJobGroupByPayload<T extends IngestionJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngestionJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngestionJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngestionJobGroupByOutputType[P]>
            : GetScalarType<T[P], IngestionJobGroupByOutputType[P]>
        }
      >
    >


  export type IngestionJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    jobType?: boolean
    status?: boolean
    config?: boolean
    schedule?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    logs?: boolean
    recordsProcessed?: boolean
    recordsSucceeded?: boolean
    recordsFailed?: boolean
    metrics?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionJob"]>

  export type IngestionJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    jobType?: boolean
    status?: boolean
    config?: boolean
    schedule?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    logs?: boolean
    recordsProcessed?: boolean
    recordsSucceeded?: boolean
    recordsFailed?: boolean
    metrics?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionJob"]>

  export type IngestionJobSelectScalar = {
    id?: boolean
    datasetId?: boolean
    jobType?: boolean
    status?: boolean
    config?: boolean
    schedule?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    logs?: boolean
    recordsProcessed?: boolean
    recordsSucceeded?: boolean
    recordsFailed?: boolean
    metrics?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IngestionJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type IngestionJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $IngestionJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngestionJob"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string
      jobType: $Enums.IngestionJobType
      status: $Enums.JobStatus
      config: Prisma.JsonValue
      schedule: string | null
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      logs: string | null
      recordsProcessed: bigint | null
      recordsSucceeded: bigint | null
      recordsFailed: bigint | null
      metrics: Prisma.JsonValue | null
      retryCount: number
      maxRetries: number
      nextRetryAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ingestionJob"]>
    composites: {}
  }

  type IngestionJobGetPayload<S extends boolean | null | undefined | IngestionJobDefaultArgs> = $Result.GetResult<Prisma.$IngestionJobPayload, S>

  type IngestionJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngestionJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngestionJobCountAggregateInputType | true
    }

  export interface IngestionJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngestionJob'], meta: { name: 'IngestionJob' } }
    /**
     * Find zero or one IngestionJob that matches the filter.
     * @param {IngestionJobFindUniqueArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestionJobFindUniqueArgs>(args: SelectSubset<T, IngestionJobFindUniqueArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IngestionJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IngestionJobFindUniqueOrThrowArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestionJobFindUniqueOrThrowArgs>(args: SelectSubset<T, IngestionJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IngestionJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobFindFirstArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestionJobFindFirstArgs>(args?: SelectSubset<T, IngestionJobFindFirstArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IngestionJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobFindFirstOrThrowArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestionJobFindFirstOrThrowArgs>(args?: SelectSubset<T, IngestionJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IngestionJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestionJobs
     * const ingestionJobs = await prisma.ingestionJob.findMany()
     * 
     * // Get first 10 IngestionJobs
     * const ingestionJobs = await prisma.ingestionJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingestionJobWithIdOnly = await prisma.ingestionJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngestionJobFindManyArgs>(args?: SelectSubset<T, IngestionJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IngestionJob.
     * @param {IngestionJobCreateArgs} args - Arguments to create a IngestionJob.
     * @example
     * // Create one IngestionJob
     * const IngestionJob = await prisma.ingestionJob.create({
     *   data: {
     *     // ... data to create a IngestionJob
     *   }
     * })
     * 
     */
    create<T extends IngestionJobCreateArgs>(args: SelectSubset<T, IngestionJobCreateArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IngestionJobs.
     * @param {IngestionJobCreateManyArgs} args - Arguments to create many IngestionJobs.
     * @example
     * // Create many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngestionJobCreateManyArgs>(args?: SelectSubset<T, IngestionJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngestionJobs and returns the data saved in the database.
     * @param {IngestionJobCreateManyAndReturnArgs} args - Arguments to create many IngestionJobs.
     * @example
     * // Create many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IngestionJobs and only return the `id`
     * const ingestionJobWithIdOnly = await prisma.ingestionJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngestionJobCreateManyAndReturnArgs>(args?: SelectSubset<T, IngestionJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IngestionJob.
     * @param {IngestionJobDeleteArgs} args - Arguments to delete one IngestionJob.
     * @example
     * // Delete one IngestionJob
     * const IngestionJob = await prisma.ingestionJob.delete({
     *   where: {
     *     // ... filter to delete one IngestionJob
     *   }
     * })
     * 
     */
    delete<T extends IngestionJobDeleteArgs>(args: SelectSubset<T, IngestionJobDeleteArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IngestionJob.
     * @param {IngestionJobUpdateArgs} args - Arguments to update one IngestionJob.
     * @example
     * // Update one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngestionJobUpdateArgs>(args: SelectSubset<T, IngestionJobUpdateArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IngestionJobs.
     * @param {IngestionJobDeleteManyArgs} args - Arguments to filter IngestionJobs to delete.
     * @example
     * // Delete a few IngestionJobs
     * const { count } = await prisma.ingestionJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngestionJobDeleteManyArgs>(args?: SelectSubset<T, IngestionJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestionJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngestionJobUpdateManyArgs>(args: SelectSubset<T, IngestionJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngestionJob.
     * @param {IngestionJobUpsertArgs} args - Arguments to update or create a IngestionJob.
     * @example
     * // Update or create a IngestionJob
     * const ingestionJob = await prisma.ingestionJob.upsert({
     *   create: {
     *     // ... data to create a IngestionJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestionJob we want to update
     *   }
     * })
     */
    upsert<T extends IngestionJobUpsertArgs>(args: SelectSubset<T, IngestionJobUpsertArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IngestionJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobCountArgs} args - Arguments to filter IngestionJobs to count.
     * @example
     * // Count the number of IngestionJobs
     * const count = await prisma.ingestionJob.count({
     *   where: {
     *     // ... the filter for the IngestionJobs we want to count
     *   }
     * })
    **/
    count<T extends IngestionJobCountArgs>(
      args?: Subset<T, IngestionJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngestionJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngestionJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngestionJobAggregateArgs>(args: Subset<T, IngestionJobAggregateArgs>): Prisma.PrismaPromise<GetIngestionJobAggregateType<T>>

    /**
     * Group by IngestionJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngestionJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestionJobGroupByArgs['orderBy'] }
        : { orderBy?: IngestionJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngestionJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngestionJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngestionJob model
   */
  readonly fields: IngestionJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestionJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestionJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IngestionJob model
   */ 
  interface IngestionJobFieldRefs {
    readonly id: FieldRef<"IngestionJob", 'String'>
    readonly datasetId: FieldRef<"IngestionJob", 'String'>
    readonly jobType: FieldRef<"IngestionJob", 'IngestionJobType'>
    readonly status: FieldRef<"IngestionJob", 'JobStatus'>
    readonly config: FieldRef<"IngestionJob", 'Json'>
    readonly schedule: FieldRef<"IngestionJob", 'String'>
    readonly startedAt: FieldRef<"IngestionJob", 'DateTime'>
    readonly completedAt: FieldRef<"IngestionJob", 'DateTime'>
    readonly errorMessage: FieldRef<"IngestionJob", 'String'>
    readonly logs: FieldRef<"IngestionJob", 'String'>
    readonly recordsProcessed: FieldRef<"IngestionJob", 'BigInt'>
    readonly recordsSucceeded: FieldRef<"IngestionJob", 'BigInt'>
    readonly recordsFailed: FieldRef<"IngestionJob", 'BigInt'>
    readonly metrics: FieldRef<"IngestionJob", 'Json'>
    readonly retryCount: FieldRef<"IngestionJob", 'Int'>
    readonly maxRetries: FieldRef<"IngestionJob", 'Int'>
    readonly nextRetryAt: FieldRef<"IngestionJob", 'DateTime'>
    readonly createdAt: FieldRef<"IngestionJob", 'DateTime'>
    readonly updatedAt: FieldRef<"IngestionJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IngestionJob findUnique
   */
  export type IngestionJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob findUniqueOrThrow
   */
  export type IngestionJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob findFirst
   */
  export type IngestionJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestionJobs.
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestionJobs.
     */
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * IngestionJob findFirstOrThrow
   */
  export type IngestionJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestionJobs.
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestionJobs.
     */
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * IngestionJob findMany
   */
  export type IngestionJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJobs to fetch.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngestionJobs.
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * IngestionJob create
   */
  export type IngestionJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * The data needed to create a IngestionJob.
     */
    data: XOR<IngestionJobCreateInput, IngestionJobUncheckedCreateInput>
  }

  /**
   * IngestionJob createMany
   */
  export type IngestionJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngestionJobs.
     */
    data: IngestionJobCreateManyInput | IngestionJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IngestionJob createManyAndReturn
   */
  export type IngestionJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IngestionJobs.
     */
    data: IngestionJobCreateManyInput | IngestionJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestionJob update
   */
  export type IngestionJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * The data needed to update a IngestionJob.
     */
    data: XOR<IngestionJobUpdateInput, IngestionJobUncheckedUpdateInput>
    /**
     * Choose, which IngestionJob to update.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob updateMany
   */
  export type IngestionJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngestionJobs.
     */
    data: XOR<IngestionJobUpdateManyMutationInput, IngestionJobUncheckedUpdateManyInput>
    /**
     * Filter which IngestionJobs to update
     */
    where?: IngestionJobWhereInput
  }

  /**
   * IngestionJob upsert
   */
  export type IngestionJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * The filter to search for the IngestionJob to update in case it exists.
     */
    where: IngestionJobWhereUniqueInput
    /**
     * In case the IngestionJob found by the `where` argument doesn't exist, create a new IngestionJob with this data.
     */
    create: XOR<IngestionJobCreateInput, IngestionJobUncheckedCreateInput>
    /**
     * In case the IngestionJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestionJobUpdateInput, IngestionJobUncheckedUpdateInput>
  }

  /**
   * IngestionJob delete
   */
  export type IngestionJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter which IngestionJob to delete.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob deleteMany
   */
  export type IngestionJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestionJobs to delete
     */
    where?: IngestionJobWhereInput
  }

  /**
   * IngestionJob without action
   */
  export type IngestionJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
  }


  /**
   * Model DatasetLineage
   */

  export type AggregateDatasetLineage = {
    _count: DatasetLineageCountAggregateOutputType | null
    _avg: DatasetLineageAvgAggregateOutputType | null
    _sum: DatasetLineageSumAggregateOutputType | null
    _min: DatasetLineageMinAggregateOutputType | null
    _max: DatasetLineageMaxAggregateOutputType | null
  }

  export type DatasetLineageAvgAggregateOutputType = {
    confidence: number | null
  }

  export type DatasetLineageSumAggregateOutputType = {
    confidence: number | null
  }

  export type DatasetLineageMinAggregateOutputType = {
    id: string | null
    upstreamId: string | null
    downstreamId: string | null
    transformationType: string | null
    confidence: number | null
    createdAt: Date | null
  }

  export type DatasetLineageMaxAggregateOutputType = {
    id: string | null
    upstreamId: string | null
    downstreamId: string | null
    transformationType: string | null
    confidence: number | null
    createdAt: Date | null
  }

  export type DatasetLineageCountAggregateOutputType = {
    id: number
    upstreamId: number
    downstreamId: number
    transformationType: number
    transformationLogic: number
    confidence: number
    createdAt: number
    _all: number
  }


  export type DatasetLineageAvgAggregateInputType = {
    confidence?: true
  }

  export type DatasetLineageSumAggregateInputType = {
    confidence?: true
  }

  export type DatasetLineageMinAggregateInputType = {
    id?: true
    upstreamId?: true
    downstreamId?: true
    transformationType?: true
    confidence?: true
    createdAt?: true
  }

  export type DatasetLineageMaxAggregateInputType = {
    id?: true
    upstreamId?: true
    downstreamId?: true
    transformationType?: true
    confidence?: true
    createdAt?: true
  }

  export type DatasetLineageCountAggregateInputType = {
    id?: true
    upstreamId?: true
    downstreamId?: true
    transformationType?: true
    transformationLogic?: true
    confidence?: true
    createdAt?: true
    _all?: true
  }

  export type DatasetLineageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetLineage to aggregate.
     */
    where?: DatasetLineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetLineages to fetch.
     */
    orderBy?: DatasetLineageOrderByWithRelationInput | DatasetLineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetLineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetLineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetLineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatasetLineages
    **/
    _count?: true | DatasetLineageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatasetLineageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatasetLineageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetLineageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetLineageMaxAggregateInputType
  }

  export type GetDatasetLineageAggregateType<T extends DatasetLineageAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasetLineage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasetLineage[P]>
      : GetScalarType<T[P], AggregateDatasetLineage[P]>
  }




  export type DatasetLineageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetLineageWhereInput
    orderBy?: DatasetLineageOrderByWithAggregationInput | DatasetLineageOrderByWithAggregationInput[]
    by: DatasetLineageScalarFieldEnum[] | DatasetLineageScalarFieldEnum
    having?: DatasetLineageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetLineageCountAggregateInputType | true
    _avg?: DatasetLineageAvgAggregateInputType
    _sum?: DatasetLineageSumAggregateInputType
    _min?: DatasetLineageMinAggregateInputType
    _max?: DatasetLineageMaxAggregateInputType
  }

  export type DatasetLineageGroupByOutputType = {
    id: string
    upstreamId: string
    downstreamId: string
    transformationType: string
    transformationLogic: JsonValue | null
    confidence: number
    createdAt: Date
    _count: DatasetLineageCountAggregateOutputType | null
    _avg: DatasetLineageAvgAggregateOutputType | null
    _sum: DatasetLineageSumAggregateOutputType | null
    _min: DatasetLineageMinAggregateOutputType | null
    _max: DatasetLineageMaxAggregateOutputType | null
  }

  type GetDatasetLineageGroupByPayload<T extends DatasetLineageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetLineageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetLineageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetLineageGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetLineageGroupByOutputType[P]>
        }
      >
    >


  export type DatasetLineageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    upstreamId?: boolean
    downstreamId?: boolean
    transformationType?: boolean
    transformationLogic?: boolean
    confidence?: boolean
    createdAt?: boolean
    upstream?: boolean | DatasetDefaultArgs<ExtArgs>
    downstream?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetLineage"]>

  export type DatasetLineageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    upstreamId?: boolean
    downstreamId?: boolean
    transformationType?: boolean
    transformationLogic?: boolean
    confidence?: boolean
    createdAt?: boolean
    upstream?: boolean | DatasetDefaultArgs<ExtArgs>
    downstream?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["datasetLineage"]>

  export type DatasetLineageSelectScalar = {
    id?: boolean
    upstreamId?: boolean
    downstreamId?: boolean
    transformationType?: boolean
    transformationLogic?: boolean
    confidence?: boolean
    createdAt?: boolean
  }

  export type DatasetLineageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upstream?: boolean | DatasetDefaultArgs<ExtArgs>
    downstream?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type DatasetLineageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upstream?: boolean | DatasetDefaultArgs<ExtArgs>
    downstream?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $DatasetLineagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatasetLineage"
    objects: {
      upstream: Prisma.$DatasetPayload<ExtArgs>
      downstream: Prisma.$DatasetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      upstreamId: string
      downstreamId: string
      transformationType: string
      transformationLogic: Prisma.JsonValue | null
      confidence: number
      createdAt: Date
    }, ExtArgs["result"]["datasetLineage"]>
    composites: {}
  }

  type DatasetLineageGetPayload<S extends boolean | null | undefined | DatasetLineageDefaultArgs> = $Result.GetResult<Prisma.$DatasetLineagePayload, S>

  type DatasetLineageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatasetLineageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DatasetLineageCountAggregateInputType | true
    }

  export interface DatasetLineageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatasetLineage'], meta: { name: 'DatasetLineage' } }
    /**
     * Find zero or one DatasetLineage that matches the filter.
     * @param {DatasetLineageFindUniqueArgs} args - Arguments to find a DatasetLineage
     * @example
     * // Get one DatasetLineage
     * const datasetLineage = await prisma.datasetLineage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetLineageFindUniqueArgs>(args: SelectSubset<T, DatasetLineageFindUniqueArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DatasetLineage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatasetLineageFindUniqueOrThrowArgs} args - Arguments to find a DatasetLineage
     * @example
     * // Get one DatasetLineage
     * const datasetLineage = await prisma.datasetLineage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetLineageFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetLineageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DatasetLineage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageFindFirstArgs} args - Arguments to find a DatasetLineage
     * @example
     * // Get one DatasetLineage
     * const datasetLineage = await prisma.datasetLineage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetLineageFindFirstArgs>(args?: SelectSubset<T, DatasetLineageFindFirstArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DatasetLineage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageFindFirstOrThrowArgs} args - Arguments to find a DatasetLineage
     * @example
     * // Get one DatasetLineage
     * const datasetLineage = await prisma.datasetLineage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetLineageFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetLineageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DatasetLineages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatasetLineages
     * const datasetLineages = await prisma.datasetLineage.findMany()
     * 
     * // Get first 10 DatasetLineages
     * const datasetLineages = await prisma.datasetLineage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetLineageWithIdOnly = await prisma.datasetLineage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetLineageFindManyArgs>(args?: SelectSubset<T, DatasetLineageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DatasetLineage.
     * @param {DatasetLineageCreateArgs} args - Arguments to create a DatasetLineage.
     * @example
     * // Create one DatasetLineage
     * const DatasetLineage = await prisma.datasetLineage.create({
     *   data: {
     *     // ... data to create a DatasetLineage
     *   }
     * })
     * 
     */
    create<T extends DatasetLineageCreateArgs>(args: SelectSubset<T, DatasetLineageCreateArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DatasetLineages.
     * @param {DatasetLineageCreateManyArgs} args - Arguments to create many DatasetLineages.
     * @example
     * // Create many DatasetLineages
     * const datasetLineage = await prisma.datasetLineage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetLineageCreateManyArgs>(args?: SelectSubset<T, DatasetLineageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatasetLineages and returns the data saved in the database.
     * @param {DatasetLineageCreateManyAndReturnArgs} args - Arguments to create many DatasetLineages.
     * @example
     * // Create many DatasetLineages
     * const datasetLineage = await prisma.datasetLineage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatasetLineages and only return the `id`
     * const datasetLineageWithIdOnly = await prisma.datasetLineage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetLineageCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetLineageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DatasetLineage.
     * @param {DatasetLineageDeleteArgs} args - Arguments to delete one DatasetLineage.
     * @example
     * // Delete one DatasetLineage
     * const DatasetLineage = await prisma.datasetLineage.delete({
     *   where: {
     *     // ... filter to delete one DatasetLineage
     *   }
     * })
     * 
     */
    delete<T extends DatasetLineageDeleteArgs>(args: SelectSubset<T, DatasetLineageDeleteArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DatasetLineage.
     * @param {DatasetLineageUpdateArgs} args - Arguments to update one DatasetLineage.
     * @example
     * // Update one DatasetLineage
     * const datasetLineage = await prisma.datasetLineage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetLineageUpdateArgs>(args: SelectSubset<T, DatasetLineageUpdateArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DatasetLineages.
     * @param {DatasetLineageDeleteManyArgs} args - Arguments to filter DatasetLineages to delete.
     * @example
     * // Delete a few DatasetLineages
     * const { count } = await prisma.datasetLineage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetLineageDeleteManyArgs>(args?: SelectSubset<T, DatasetLineageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetLineages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatasetLineages
     * const datasetLineage = await prisma.datasetLineage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetLineageUpdateManyArgs>(args: SelectSubset<T, DatasetLineageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatasetLineage.
     * @param {DatasetLineageUpsertArgs} args - Arguments to update or create a DatasetLineage.
     * @example
     * // Update or create a DatasetLineage
     * const datasetLineage = await prisma.datasetLineage.upsert({
     *   create: {
     *     // ... data to create a DatasetLineage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatasetLineage we want to update
     *   }
     * })
     */
    upsert<T extends DatasetLineageUpsertArgs>(args: SelectSubset<T, DatasetLineageUpsertArgs<ExtArgs>>): Prisma__DatasetLineageClient<$Result.GetResult<Prisma.$DatasetLineagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DatasetLineages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageCountArgs} args - Arguments to filter DatasetLineages to count.
     * @example
     * // Count the number of DatasetLineages
     * const count = await prisma.datasetLineage.count({
     *   where: {
     *     // ... the filter for the DatasetLineages we want to count
     *   }
     * })
    **/
    count<T extends DatasetLineageCountArgs>(
      args?: Subset<T, DatasetLineageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetLineageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatasetLineage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetLineageAggregateArgs>(args: Subset<T, DatasetLineageAggregateArgs>): Prisma.PrismaPromise<GetDatasetLineageAggregateType<T>>

    /**
     * Group by DatasetLineage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetLineageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetLineageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetLineageGroupByArgs['orderBy'] }
        : { orderBy?: DatasetLineageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetLineageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetLineageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatasetLineage model
   */
  readonly fields: DatasetLineageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatasetLineage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetLineageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    upstream<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    downstream<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatasetLineage model
   */ 
  interface DatasetLineageFieldRefs {
    readonly id: FieldRef<"DatasetLineage", 'String'>
    readonly upstreamId: FieldRef<"DatasetLineage", 'String'>
    readonly downstreamId: FieldRef<"DatasetLineage", 'String'>
    readonly transformationType: FieldRef<"DatasetLineage", 'String'>
    readonly transformationLogic: FieldRef<"DatasetLineage", 'Json'>
    readonly confidence: FieldRef<"DatasetLineage", 'Float'>
    readonly createdAt: FieldRef<"DatasetLineage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatasetLineage findUnique
   */
  export type DatasetLineageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * Filter, which DatasetLineage to fetch.
     */
    where: DatasetLineageWhereUniqueInput
  }

  /**
   * DatasetLineage findUniqueOrThrow
   */
  export type DatasetLineageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * Filter, which DatasetLineage to fetch.
     */
    where: DatasetLineageWhereUniqueInput
  }

  /**
   * DatasetLineage findFirst
   */
  export type DatasetLineageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * Filter, which DatasetLineage to fetch.
     */
    where?: DatasetLineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetLineages to fetch.
     */
    orderBy?: DatasetLineageOrderByWithRelationInput | DatasetLineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetLineages.
     */
    cursor?: DatasetLineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetLineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetLineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetLineages.
     */
    distinct?: DatasetLineageScalarFieldEnum | DatasetLineageScalarFieldEnum[]
  }

  /**
   * DatasetLineage findFirstOrThrow
   */
  export type DatasetLineageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * Filter, which DatasetLineage to fetch.
     */
    where?: DatasetLineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetLineages to fetch.
     */
    orderBy?: DatasetLineageOrderByWithRelationInput | DatasetLineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetLineages.
     */
    cursor?: DatasetLineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetLineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetLineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetLineages.
     */
    distinct?: DatasetLineageScalarFieldEnum | DatasetLineageScalarFieldEnum[]
  }

  /**
   * DatasetLineage findMany
   */
  export type DatasetLineageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * Filter, which DatasetLineages to fetch.
     */
    where?: DatasetLineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetLineages to fetch.
     */
    orderBy?: DatasetLineageOrderByWithRelationInput | DatasetLineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatasetLineages.
     */
    cursor?: DatasetLineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetLineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetLineages.
     */
    skip?: number
    distinct?: DatasetLineageScalarFieldEnum | DatasetLineageScalarFieldEnum[]
  }

  /**
   * DatasetLineage create
   */
  export type DatasetLineageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * The data needed to create a DatasetLineage.
     */
    data: XOR<DatasetLineageCreateInput, DatasetLineageUncheckedCreateInput>
  }

  /**
   * DatasetLineage createMany
   */
  export type DatasetLineageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatasetLineages.
     */
    data: DatasetLineageCreateManyInput | DatasetLineageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatasetLineage createManyAndReturn
   */
  export type DatasetLineageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DatasetLineages.
     */
    data: DatasetLineageCreateManyInput | DatasetLineageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetLineage update
   */
  export type DatasetLineageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * The data needed to update a DatasetLineage.
     */
    data: XOR<DatasetLineageUpdateInput, DatasetLineageUncheckedUpdateInput>
    /**
     * Choose, which DatasetLineage to update.
     */
    where: DatasetLineageWhereUniqueInput
  }

  /**
   * DatasetLineage updateMany
   */
  export type DatasetLineageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatasetLineages.
     */
    data: XOR<DatasetLineageUpdateManyMutationInput, DatasetLineageUncheckedUpdateManyInput>
    /**
     * Filter which DatasetLineages to update
     */
    where?: DatasetLineageWhereInput
  }

  /**
   * DatasetLineage upsert
   */
  export type DatasetLineageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * The filter to search for the DatasetLineage to update in case it exists.
     */
    where: DatasetLineageWhereUniqueInput
    /**
     * In case the DatasetLineage found by the `where` argument doesn't exist, create a new DatasetLineage with this data.
     */
    create: XOR<DatasetLineageCreateInput, DatasetLineageUncheckedCreateInput>
    /**
     * In case the DatasetLineage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetLineageUpdateInput, DatasetLineageUncheckedUpdateInput>
  }

  /**
   * DatasetLineage delete
   */
  export type DatasetLineageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
    /**
     * Filter which DatasetLineage to delete.
     */
    where: DatasetLineageWhereUniqueInput
  }

  /**
   * DatasetLineage deleteMany
   */
  export type DatasetLineageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetLineages to delete
     */
    where?: DatasetLineageWhereInput
  }

  /**
   * DatasetLineage without action
   */
  export type DatasetLineageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetLineage
     */
    select?: DatasetLineageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetLineageInclude<ExtArgs> | null
  }


  /**
   * Model DataConnector
   */

  export type AggregateDataConnector = {
    _count: DataConnectorCountAggregateOutputType | null
    _min: DataConnectorMinAggregateOutputType | null
    _max: DataConnectorMaxAggregateOutputType | null
  }

  export type DataConnectorMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DataConnectorType | null
    description: string | null
    isActive: boolean | null
    lastHealthCheck: Date | null
    healthStatus: $Enums.ConnectorHealthStatus | null
    errorMessage: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataConnectorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DataConnectorType | null
    description: string | null
    isActive: boolean | null
    lastHealthCheck: Date | null
    healthStatus: $Enums.ConnectorHealthStatus | null
    errorMessage: string | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataConnectorCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    config: number
    credentials: number
    isActive: number
    lastHealthCheck: number
    healthStatus: number
    errorMessage: number
    datasets: number
    lastUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataConnectorMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isActive?: true
    lastHealthCheck?: true
    healthStatus?: true
    errorMessage?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataConnectorMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isActive?: true
    lastHealthCheck?: true
    healthStatus?: true
    errorMessage?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataConnectorCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    config?: true
    credentials?: true
    isActive?: true
    lastHealthCheck?: true
    healthStatus?: true
    errorMessage?: true
    datasets?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataConnectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataConnector to aggregate.
     */
    where?: DataConnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataConnectors to fetch.
     */
    orderBy?: DataConnectorOrderByWithRelationInput | DataConnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataConnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataConnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataConnectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataConnectors
    **/
    _count?: true | DataConnectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataConnectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataConnectorMaxAggregateInputType
  }

  export type GetDataConnectorAggregateType<T extends DataConnectorAggregateArgs> = {
        [P in keyof T & keyof AggregateDataConnector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataConnector[P]>
      : GetScalarType<T[P], AggregateDataConnector[P]>
  }




  export type DataConnectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataConnectorWhereInput
    orderBy?: DataConnectorOrderByWithAggregationInput | DataConnectorOrderByWithAggregationInput[]
    by: DataConnectorScalarFieldEnum[] | DataConnectorScalarFieldEnum
    having?: DataConnectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataConnectorCountAggregateInputType | true
    _min?: DataConnectorMinAggregateInputType
    _max?: DataConnectorMaxAggregateInputType
  }

  export type DataConnectorGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DataConnectorType
    description: string | null
    config: JsonValue
    credentials: JsonValue | null
    isActive: boolean
    lastHealthCheck: Date | null
    healthStatus: $Enums.ConnectorHealthStatus
    errorMessage: string | null
    datasets: string[]
    lastUsed: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DataConnectorCountAggregateOutputType | null
    _min: DataConnectorMinAggregateOutputType | null
    _max: DataConnectorMaxAggregateOutputType | null
  }

  type GetDataConnectorGroupByPayload<T extends DataConnectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataConnectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataConnectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataConnectorGroupByOutputType[P]>
            : GetScalarType<T[P], DataConnectorGroupByOutputType[P]>
        }
      >
    >


  export type DataConnectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    config?: boolean
    credentials?: boolean
    isActive?: boolean
    lastHealthCheck?: boolean
    healthStatus?: boolean
    errorMessage?: boolean
    datasets?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataConnector"]>

  export type DataConnectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    config?: boolean
    credentials?: boolean
    isActive?: boolean
    lastHealthCheck?: boolean
    healthStatus?: boolean
    errorMessage?: boolean
    datasets?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataConnector"]>

  export type DataConnectorSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    config?: boolean
    credentials?: boolean
    isActive?: boolean
    lastHealthCheck?: boolean
    healthStatus?: boolean
    errorMessage?: boolean
    datasets?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DataConnectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataConnector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DataConnectorType
      description: string | null
      config: Prisma.JsonValue
      credentials: Prisma.JsonValue | null
      isActive: boolean
      lastHealthCheck: Date | null
      healthStatus: $Enums.ConnectorHealthStatus
      errorMessage: string | null
      datasets: string[]
      lastUsed: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataConnector"]>
    composites: {}
  }

  type DataConnectorGetPayload<S extends boolean | null | undefined | DataConnectorDefaultArgs> = $Result.GetResult<Prisma.$DataConnectorPayload, S>

  type DataConnectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataConnectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataConnectorCountAggregateInputType | true
    }

  export interface DataConnectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataConnector'], meta: { name: 'DataConnector' } }
    /**
     * Find zero or one DataConnector that matches the filter.
     * @param {DataConnectorFindUniqueArgs} args - Arguments to find a DataConnector
     * @example
     * // Get one DataConnector
     * const dataConnector = await prisma.dataConnector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataConnectorFindUniqueArgs>(args: SelectSubset<T, DataConnectorFindUniqueArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataConnector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataConnectorFindUniqueOrThrowArgs} args - Arguments to find a DataConnector
     * @example
     * // Get one DataConnector
     * const dataConnector = await prisma.dataConnector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataConnectorFindUniqueOrThrowArgs>(args: SelectSubset<T, DataConnectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataConnector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorFindFirstArgs} args - Arguments to find a DataConnector
     * @example
     * // Get one DataConnector
     * const dataConnector = await prisma.dataConnector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataConnectorFindFirstArgs>(args?: SelectSubset<T, DataConnectorFindFirstArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataConnector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorFindFirstOrThrowArgs} args - Arguments to find a DataConnector
     * @example
     * // Get one DataConnector
     * const dataConnector = await prisma.dataConnector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataConnectorFindFirstOrThrowArgs>(args?: SelectSubset<T, DataConnectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataConnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataConnectors
     * const dataConnectors = await prisma.dataConnector.findMany()
     * 
     * // Get first 10 DataConnectors
     * const dataConnectors = await prisma.dataConnector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataConnectorWithIdOnly = await prisma.dataConnector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataConnectorFindManyArgs>(args?: SelectSubset<T, DataConnectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataConnector.
     * @param {DataConnectorCreateArgs} args - Arguments to create a DataConnector.
     * @example
     * // Create one DataConnector
     * const DataConnector = await prisma.dataConnector.create({
     *   data: {
     *     // ... data to create a DataConnector
     *   }
     * })
     * 
     */
    create<T extends DataConnectorCreateArgs>(args: SelectSubset<T, DataConnectorCreateArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataConnectors.
     * @param {DataConnectorCreateManyArgs} args - Arguments to create many DataConnectors.
     * @example
     * // Create many DataConnectors
     * const dataConnector = await prisma.dataConnector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataConnectorCreateManyArgs>(args?: SelectSubset<T, DataConnectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataConnectors and returns the data saved in the database.
     * @param {DataConnectorCreateManyAndReturnArgs} args - Arguments to create many DataConnectors.
     * @example
     * // Create many DataConnectors
     * const dataConnector = await prisma.dataConnector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataConnectors and only return the `id`
     * const dataConnectorWithIdOnly = await prisma.dataConnector.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataConnectorCreateManyAndReturnArgs>(args?: SelectSubset<T, DataConnectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataConnector.
     * @param {DataConnectorDeleteArgs} args - Arguments to delete one DataConnector.
     * @example
     * // Delete one DataConnector
     * const DataConnector = await prisma.dataConnector.delete({
     *   where: {
     *     // ... filter to delete one DataConnector
     *   }
     * })
     * 
     */
    delete<T extends DataConnectorDeleteArgs>(args: SelectSubset<T, DataConnectorDeleteArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataConnector.
     * @param {DataConnectorUpdateArgs} args - Arguments to update one DataConnector.
     * @example
     * // Update one DataConnector
     * const dataConnector = await prisma.dataConnector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataConnectorUpdateArgs>(args: SelectSubset<T, DataConnectorUpdateArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataConnectors.
     * @param {DataConnectorDeleteManyArgs} args - Arguments to filter DataConnectors to delete.
     * @example
     * // Delete a few DataConnectors
     * const { count } = await prisma.dataConnector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataConnectorDeleteManyArgs>(args?: SelectSubset<T, DataConnectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataConnectors
     * const dataConnector = await prisma.dataConnector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataConnectorUpdateManyArgs>(args: SelectSubset<T, DataConnectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataConnector.
     * @param {DataConnectorUpsertArgs} args - Arguments to update or create a DataConnector.
     * @example
     * // Update or create a DataConnector
     * const dataConnector = await prisma.dataConnector.upsert({
     *   create: {
     *     // ... data to create a DataConnector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataConnector we want to update
     *   }
     * })
     */
    upsert<T extends DataConnectorUpsertArgs>(args: SelectSubset<T, DataConnectorUpsertArgs<ExtArgs>>): Prisma__DataConnectorClient<$Result.GetResult<Prisma.$DataConnectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataConnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorCountArgs} args - Arguments to filter DataConnectors to count.
     * @example
     * // Count the number of DataConnectors
     * const count = await prisma.dataConnector.count({
     *   where: {
     *     // ... the filter for the DataConnectors we want to count
     *   }
     * })
    **/
    count<T extends DataConnectorCountArgs>(
      args?: Subset<T, DataConnectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataConnectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataConnector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataConnectorAggregateArgs>(args: Subset<T, DataConnectorAggregateArgs>): Prisma.PrismaPromise<GetDataConnectorAggregateType<T>>

    /**
     * Group by DataConnector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataConnectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataConnectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataConnectorGroupByArgs['orderBy'] }
        : { orderBy?: DataConnectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataConnectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataConnectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataConnector model
   */
  readonly fields: DataConnectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataConnector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataConnectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataConnector model
   */ 
  interface DataConnectorFieldRefs {
    readonly id: FieldRef<"DataConnector", 'String'>
    readonly name: FieldRef<"DataConnector", 'String'>
    readonly type: FieldRef<"DataConnector", 'DataConnectorType'>
    readonly description: FieldRef<"DataConnector", 'String'>
    readonly config: FieldRef<"DataConnector", 'Json'>
    readonly credentials: FieldRef<"DataConnector", 'Json'>
    readonly isActive: FieldRef<"DataConnector", 'Boolean'>
    readonly lastHealthCheck: FieldRef<"DataConnector", 'DateTime'>
    readonly healthStatus: FieldRef<"DataConnector", 'ConnectorHealthStatus'>
    readonly errorMessage: FieldRef<"DataConnector", 'String'>
    readonly datasets: FieldRef<"DataConnector", 'String[]'>
    readonly lastUsed: FieldRef<"DataConnector", 'DateTime'>
    readonly createdAt: FieldRef<"DataConnector", 'DateTime'>
    readonly updatedAt: FieldRef<"DataConnector", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataConnector findUnique
   */
  export type DataConnectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * Filter, which DataConnector to fetch.
     */
    where: DataConnectorWhereUniqueInput
  }

  /**
   * DataConnector findUniqueOrThrow
   */
  export type DataConnectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * Filter, which DataConnector to fetch.
     */
    where: DataConnectorWhereUniqueInput
  }

  /**
   * DataConnector findFirst
   */
  export type DataConnectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * Filter, which DataConnector to fetch.
     */
    where?: DataConnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataConnectors to fetch.
     */
    orderBy?: DataConnectorOrderByWithRelationInput | DataConnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataConnectors.
     */
    cursor?: DataConnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataConnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataConnectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataConnectors.
     */
    distinct?: DataConnectorScalarFieldEnum | DataConnectorScalarFieldEnum[]
  }

  /**
   * DataConnector findFirstOrThrow
   */
  export type DataConnectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * Filter, which DataConnector to fetch.
     */
    where?: DataConnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataConnectors to fetch.
     */
    orderBy?: DataConnectorOrderByWithRelationInput | DataConnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataConnectors.
     */
    cursor?: DataConnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataConnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataConnectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataConnectors.
     */
    distinct?: DataConnectorScalarFieldEnum | DataConnectorScalarFieldEnum[]
  }

  /**
   * DataConnector findMany
   */
  export type DataConnectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * Filter, which DataConnectors to fetch.
     */
    where?: DataConnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataConnectors to fetch.
     */
    orderBy?: DataConnectorOrderByWithRelationInput | DataConnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataConnectors.
     */
    cursor?: DataConnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataConnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataConnectors.
     */
    skip?: number
    distinct?: DataConnectorScalarFieldEnum | DataConnectorScalarFieldEnum[]
  }

  /**
   * DataConnector create
   */
  export type DataConnectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * The data needed to create a DataConnector.
     */
    data: XOR<DataConnectorCreateInput, DataConnectorUncheckedCreateInput>
  }

  /**
   * DataConnector createMany
   */
  export type DataConnectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataConnectors.
     */
    data: DataConnectorCreateManyInput | DataConnectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataConnector createManyAndReturn
   */
  export type DataConnectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataConnectors.
     */
    data: DataConnectorCreateManyInput | DataConnectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataConnector update
   */
  export type DataConnectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * The data needed to update a DataConnector.
     */
    data: XOR<DataConnectorUpdateInput, DataConnectorUncheckedUpdateInput>
    /**
     * Choose, which DataConnector to update.
     */
    where: DataConnectorWhereUniqueInput
  }

  /**
   * DataConnector updateMany
   */
  export type DataConnectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataConnectors.
     */
    data: XOR<DataConnectorUpdateManyMutationInput, DataConnectorUncheckedUpdateManyInput>
    /**
     * Filter which DataConnectors to update
     */
    where?: DataConnectorWhereInput
  }

  /**
   * DataConnector upsert
   */
  export type DataConnectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * The filter to search for the DataConnector to update in case it exists.
     */
    where: DataConnectorWhereUniqueInput
    /**
     * In case the DataConnector found by the `where` argument doesn't exist, create a new DataConnector with this data.
     */
    create: XOR<DataConnectorCreateInput, DataConnectorUncheckedCreateInput>
    /**
     * In case the DataConnector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataConnectorUpdateInput, DataConnectorUncheckedUpdateInput>
  }

  /**
   * DataConnector delete
   */
  export type DataConnectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
    /**
     * Filter which DataConnector to delete.
     */
    where: DataConnectorWhereUniqueInput
  }

  /**
   * DataConnector deleteMany
   */
  export type DataConnectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataConnectors to delete
     */
    where?: DataConnectorWhereInput
  }

  /**
   * DataConnector without action
   */
  export type DataConnectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataConnector
     */
    select?: DataConnectorSelect<ExtArgs> | null
  }


  /**
   * Model SchemaMapping
   */

  export type AggregateSchemaMapping = {
    _count: SchemaMappingCountAggregateOutputType | null
    _avg: SchemaMappingAvgAggregateOutputType | null
    _sum: SchemaMappingSumAggregateOutputType | null
    _min: SchemaMappingMinAggregateOutputType | null
    _max: SchemaMappingMaxAggregateOutputType | null
  }

  export type SchemaMappingAvgAggregateOutputType = {
    successRate: number | null
  }

  export type SchemaMappingSumAggregateOutputType = {
    successRate: number | null
  }

  export type SchemaMappingMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    lastApplied: Date | null
    successRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchemaMappingMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    lastApplied: Date | null
    successRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchemaMappingCountAggregateOutputType = {
    id: number
    datasetId: number
    name: number
    description: number
    sourceSchema: number
    targetSchema: number
    mappingRules: number
    validationRules: number
    isActive: number
    lastApplied: number
    successRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchemaMappingAvgAggregateInputType = {
    successRate?: true
  }

  export type SchemaMappingSumAggregateInputType = {
    successRate?: true
  }

  export type SchemaMappingMinAggregateInputType = {
    id?: true
    datasetId?: true
    name?: true
    description?: true
    isActive?: true
    lastApplied?: true
    successRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchemaMappingMaxAggregateInputType = {
    id?: true
    datasetId?: true
    name?: true
    description?: true
    isActive?: true
    lastApplied?: true
    successRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchemaMappingCountAggregateInputType = {
    id?: true
    datasetId?: true
    name?: true
    description?: true
    sourceSchema?: true
    targetSchema?: true
    mappingRules?: true
    validationRules?: true
    isActive?: true
    lastApplied?: true
    successRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchemaMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchemaMapping to aggregate.
     */
    where?: SchemaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchemaMappings to fetch.
     */
    orderBy?: SchemaMappingOrderByWithRelationInput | SchemaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchemaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchemaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchemaMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchemaMappings
    **/
    _count?: true | SchemaMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchemaMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchemaMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchemaMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchemaMappingMaxAggregateInputType
  }

  export type GetSchemaMappingAggregateType<T extends SchemaMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateSchemaMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchemaMapping[P]>
      : GetScalarType<T[P], AggregateSchemaMapping[P]>
  }




  export type SchemaMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchemaMappingWhereInput
    orderBy?: SchemaMappingOrderByWithAggregationInput | SchemaMappingOrderByWithAggregationInput[]
    by: SchemaMappingScalarFieldEnum[] | SchemaMappingScalarFieldEnum
    having?: SchemaMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchemaMappingCountAggregateInputType | true
    _avg?: SchemaMappingAvgAggregateInputType
    _sum?: SchemaMappingSumAggregateInputType
    _min?: SchemaMappingMinAggregateInputType
    _max?: SchemaMappingMaxAggregateInputType
  }

  export type SchemaMappingGroupByOutputType = {
    id: string
    datasetId: string
    name: string
    description: string | null
    sourceSchema: JsonValue
    targetSchema: JsonValue
    mappingRules: JsonValue
    validationRules: JsonValue
    isActive: boolean
    lastApplied: Date | null
    successRate: number | null
    createdAt: Date
    updatedAt: Date
    _count: SchemaMappingCountAggregateOutputType | null
    _avg: SchemaMappingAvgAggregateOutputType | null
    _sum: SchemaMappingSumAggregateOutputType | null
    _min: SchemaMappingMinAggregateOutputType | null
    _max: SchemaMappingMaxAggregateOutputType | null
  }

  type GetSchemaMappingGroupByPayload<T extends SchemaMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchemaMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchemaMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchemaMappingGroupByOutputType[P]>
            : GetScalarType<T[P], SchemaMappingGroupByOutputType[P]>
        }
      >
    >


  export type SchemaMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    name?: boolean
    description?: boolean
    sourceSchema?: boolean
    targetSchema?: boolean
    mappingRules?: boolean
    validationRules?: boolean
    isActive?: boolean
    lastApplied?: boolean
    successRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["schemaMapping"]>

  export type SchemaMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    name?: boolean
    description?: boolean
    sourceSchema?: boolean
    targetSchema?: boolean
    mappingRules?: boolean
    validationRules?: boolean
    isActive?: boolean
    lastApplied?: boolean
    successRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["schemaMapping"]>

  export type SchemaMappingSelectScalar = {
    id?: boolean
    datasetId?: boolean
    name?: boolean
    description?: boolean
    sourceSchema?: boolean
    targetSchema?: boolean
    mappingRules?: boolean
    validationRules?: boolean
    isActive?: boolean
    lastApplied?: boolean
    successRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SchemaMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchemaMapping"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string
      name: string
      description: string | null
      sourceSchema: Prisma.JsonValue
      targetSchema: Prisma.JsonValue
      mappingRules: Prisma.JsonValue
      validationRules: Prisma.JsonValue
      isActive: boolean
      lastApplied: Date | null
      successRate: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schemaMapping"]>
    composites: {}
  }

  type SchemaMappingGetPayload<S extends boolean | null | undefined | SchemaMappingDefaultArgs> = $Result.GetResult<Prisma.$SchemaMappingPayload, S>

  type SchemaMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchemaMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchemaMappingCountAggregateInputType | true
    }

  export interface SchemaMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchemaMapping'], meta: { name: 'SchemaMapping' } }
    /**
     * Find zero or one SchemaMapping that matches the filter.
     * @param {SchemaMappingFindUniqueArgs} args - Arguments to find a SchemaMapping
     * @example
     * // Get one SchemaMapping
     * const schemaMapping = await prisma.schemaMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchemaMappingFindUniqueArgs>(args: SelectSubset<T, SchemaMappingFindUniqueArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchemaMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchemaMappingFindUniqueOrThrowArgs} args - Arguments to find a SchemaMapping
     * @example
     * // Get one SchemaMapping
     * const schemaMapping = await prisma.schemaMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchemaMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, SchemaMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchemaMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingFindFirstArgs} args - Arguments to find a SchemaMapping
     * @example
     * // Get one SchemaMapping
     * const schemaMapping = await prisma.schemaMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchemaMappingFindFirstArgs>(args?: SelectSubset<T, SchemaMappingFindFirstArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchemaMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingFindFirstOrThrowArgs} args - Arguments to find a SchemaMapping
     * @example
     * // Get one SchemaMapping
     * const schemaMapping = await prisma.schemaMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchemaMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, SchemaMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchemaMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchemaMappings
     * const schemaMappings = await prisma.schemaMapping.findMany()
     * 
     * // Get first 10 SchemaMappings
     * const schemaMappings = await prisma.schemaMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schemaMappingWithIdOnly = await prisma.schemaMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchemaMappingFindManyArgs>(args?: SelectSubset<T, SchemaMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchemaMapping.
     * @param {SchemaMappingCreateArgs} args - Arguments to create a SchemaMapping.
     * @example
     * // Create one SchemaMapping
     * const SchemaMapping = await prisma.schemaMapping.create({
     *   data: {
     *     // ... data to create a SchemaMapping
     *   }
     * })
     * 
     */
    create<T extends SchemaMappingCreateArgs>(args: SelectSubset<T, SchemaMappingCreateArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchemaMappings.
     * @param {SchemaMappingCreateManyArgs} args - Arguments to create many SchemaMappings.
     * @example
     * // Create many SchemaMappings
     * const schemaMapping = await prisma.schemaMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchemaMappingCreateManyArgs>(args?: SelectSubset<T, SchemaMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchemaMappings and returns the data saved in the database.
     * @param {SchemaMappingCreateManyAndReturnArgs} args - Arguments to create many SchemaMappings.
     * @example
     * // Create many SchemaMappings
     * const schemaMapping = await prisma.schemaMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchemaMappings and only return the `id`
     * const schemaMappingWithIdOnly = await prisma.schemaMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchemaMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, SchemaMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchemaMapping.
     * @param {SchemaMappingDeleteArgs} args - Arguments to delete one SchemaMapping.
     * @example
     * // Delete one SchemaMapping
     * const SchemaMapping = await prisma.schemaMapping.delete({
     *   where: {
     *     // ... filter to delete one SchemaMapping
     *   }
     * })
     * 
     */
    delete<T extends SchemaMappingDeleteArgs>(args: SelectSubset<T, SchemaMappingDeleteArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchemaMapping.
     * @param {SchemaMappingUpdateArgs} args - Arguments to update one SchemaMapping.
     * @example
     * // Update one SchemaMapping
     * const schemaMapping = await prisma.schemaMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchemaMappingUpdateArgs>(args: SelectSubset<T, SchemaMappingUpdateArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchemaMappings.
     * @param {SchemaMappingDeleteManyArgs} args - Arguments to filter SchemaMappings to delete.
     * @example
     * // Delete a few SchemaMappings
     * const { count } = await prisma.schemaMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchemaMappingDeleteManyArgs>(args?: SelectSubset<T, SchemaMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchemaMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchemaMappings
     * const schemaMapping = await prisma.schemaMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchemaMappingUpdateManyArgs>(args: SelectSubset<T, SchemaMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchemaMapping.
     * @param {SchemaMappingUpsertArgs} args - Arguments to update or create a SchemaMapping.
     * @example
     * // Update or create a SchemaMapping
     * const schemaMapping = await prisma.schemaMapping.upsert({
     *   create: {
     *     // ... data to create a SchemaMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchemaMapping we want to update
     *   }
     * })
     */
    upsert<T extends SchemaMappingUpsertArgs>(args: SelectSubset<T, SchemaMappingUpsertArgs<ExtArgs>>): Prisma__SchemaMappingClient<$Result.GetResult<Prisma.$SchemaMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchemaMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingCountArgs} args - Arguments to filter SchemaMappings to count.
     * @example
     * // Count the number of SchemaMappings
     * const count = await prisma.schemaMapping.count({
     *   where: {
     *     // ... the filter for the SchemaMappings we want to count
     *   }
     * })
    **/
    count<T extends SchemaMappingCountArgs>(
      args?: Subset<T, SchemaMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchemaMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchemaMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchemaMappingAggregateArgs>(args: Subset<T, SchemaMappingAggregateArgs>): Prisma.PrismaPromise<GetSchemaMappingAggregateType<T>>

    /**
     * Group by SchemaMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchemaMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchemaMappingGroupByArgs['orderBy'] }
        : { orderBy?: SchemaMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchemaMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchemaMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchemaMapping model
   */
  readonly fields: SchemaMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchemaMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchemaMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchemaMapping model
   */ 
  interface SchemaMappingFieldRefs {
    readonly id: FieldRef<"SchemaMapping", 'String'>
    readonly datasetId: FieldRef<"SchemaMapping", 'String'>
    readonly name: FieldRef<"SchemaMapping", 'String'>
    readonly description: FieldRef<"SchemaMapping", 'String'>
    readonly sourceSchema: FieldRef<"SchemaMapping", 'Json'>
    readonly targetSchema: FieldRef<"SchemaMapping", 'Json'>
    readonly mappingRules: FieldRef<"SchemaMapping", 'Json'>
    readonly validationRules: FieldRef<"SchemaMapping", 'Json'>
    readonly isActive: FieldRef<"SchemaMapping", 'Boolean'>
    readonly lastApplied: FieldRef<"SchemaMapping", 'DateTime'>
    readonly successRate: FieldRef<"SchemaMapping", 'Float'>
    readonly createdAt: FieldRef<"SchemaMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"SchemaMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchemaMapping findUnique
   */
  export type SchemaMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * Filter, which SchemaMapping to fetch.
     */
    where: SchemaMappingWhereUniqueInput
  }

  /**
   * SchemaMapping findUniqueOrThrow
   */
  export type SchemaMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * Filter, which SchemaMapping to fetch.
     */
    where: SchemaMappingWhereUniqueInput
  }

  /**
   * SchemaMapping findFirst
   */
  export type SchemaMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * Filter, which SchemaMapping to fetch.
     */
    where?: SchemaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchemaMappings to fetch.
     */
    orderBy?: SchemaMappingOrderByWithRelationInput | SchemaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchemaMappings.
     */
    cursor?: SchemaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchemaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchemaMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchemaMappings.
     */
    distinct?: SchemaMappingScalarFieldEnum | SchemaMappingScalarFieldEnum[]
  }

  /**
   * SchemaMapping findFirstOrThrow
   */
  export type SchemaMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * Filter, which SchemaMapping to fetch.
     */
    where?: SchemaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchemaMappings to fetch.
     */
    orderBy?: SchemaMappingOrderByWithRelationInput | SchemaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchemaMappings.
     */
    cursor?: SchemaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchemaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchemaMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchemaMappings.
     */
    distinct?: SchemaMappingScalarFieldEnum | SchemaMappingScalarFieldEnum[]
  }

  /**
   * SchemaMapping findMany
   */
  export type SchemaMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * Filter, which SchemaMappings to fetch.
     */
    where?: SchemaMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchemaMappings to fetch.
     */
    orderBy?: SchemaMappingOrderByWithRelationInput | SchemaMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchemaMappings.
     */
    cursor?: SchemaMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchemaMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchemaMappings.
     */
    skip?: number
    distinct?: SchemaMappingScalarFieldEnum | SchemaMappingScalarFieldEnum[]
  }

  /**
   * SchemaMapping create
   */
  export type SchemaMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * The data needed to create a SchemaMapping.
     */
    data: XOR<SchemaMappingCreateInput, SchemaMappingUncheckedCreateInput>
  }

  /**
   * SchemaMapping createMany
   */
  export type SchemaMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchemaMappings.
     */
    data: SchemaMappingCreateManyInput | SchemaMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchemaMapping createManyAndReturn
   */
  export type SchemaMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchemaMappings.
     */
    data: SchemaMappingCreateManyInput | SchemaMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchemaMapping update
   */
  export type SchemaMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * The data needed to update a SchemaMapping.
     */
    data: XOR<SchemaMappingUpdateInput, SchemaMappingUncheckedUpdateInput>
    /**
     * Choose, which SchemaMapping to update.
     */
    where: SchemaMappingWhereUniqueInput
  }

  /**
   * SchemaMapping updateMany
   */
  export type SchemaMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchemaMappings.
     */
    data: XOR<SchemaMappingUpdateManyMutationInput, SchemaMappingUncheckedUpdateManyInput>
    /**
     * Filter which SchemaMappings to update
     */
    where?: SchemaMappingWhereInput
  }

  /**
   * SchemaMapping upsert
   */
  export type SchemaMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * The filter to search for the SchemaMapping to update in case it exists.
     */
    where: SchemaMappingWhereUniqueInput
    /**
     * In case the SchemaMapping found by the `where` argument doesn't exist, create a new SchemaMapping with this data.
     */
    create: XOR<SchemaMappingCreateInput, SchemaMappingUncheckedCreateInput>
    /**
     * In case the SchemaMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchemaMappingUpdateInput, SchemaMappingUncheckedUpdateInput>
  }

  /**
   * SchemaMapping delete
   */
  export type SchemaMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
    /**
     * Filter which SchemaMapping to delete.
     */
    where: SchemaMappingWhereUniqueInput
  }

  /**
   * SchemaMapping deleteMany
   */
  export type SchemaMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchemaMappings to delete
     */
    where?: SchemaMappingWhereInput
  }

  /**
   * SchemaMapping without action
   */
  export type SchemaMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchemaMapping
     */
    select?: SchemaMappingSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    actorId: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    actorId: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    actorId: number
    changes: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    changes?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    action: string
    actorId: string | null
    changes: JsonValue
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changes?: boolean
    timestamp?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changes?: boolean
    timestamp?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changes?: boolean
    timestamp?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      action: string
      actorId: string | null
      changes: Prisma.JsonValue
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model DistributionSession
   */

  export type AggregateDistributionSession = {
    _count: DistributionSessionCountAggregateOutputType | null
    _min: DistributionSessionMinAggregateOutputType | null
    _max: DistributionSessionMaxAggregateOutputType | null
  }

  export type DistributionSessionMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    currentScenario: string | null
    presentationMode: boolean | null
    lastSaved: Date | null
    hasUnsavedChanges: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistributionSessionMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    currentScenario: string | null
    presentationMode: boolean | null
    lastSaved: Date | null
    hasUnsavedChanges: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistributionSessionCountAggregateOutputType = {
    id: number
    campaignId: number
    currentScenario: number
    presentationMode: number
    lastSaved: number
    hasUnsavedChanges: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DistributionSessionMinAggregateInputType = {
    id?: true
    campaignId?: true
    currentScenario?: true
    presentationMode?: true
    lastSaved?: true
    hasUnsavedChanges?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistributionSessionMaxAggregateInputType = {
    id?: true
    campaignId?: true
    currentScenario?: true
    presentationMode?: true
    lastSaved?: true
    hasUnsavedChanges?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistributionSessionCountAggregateInputType = {
    id?: true
    campaignId?: true
    currentScenario?: true
    presentationMode?: true
    lastSaved?: true
    hasUnsavedChanges?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DistributionSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionSession to aggregate.
     */
    where?: DistributionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionSessions to fetch.
     */
    orderBy?: DistributionSessionOrderByWithRelationInput | DistributionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DistributionSessions
    **/
    _count?: true | DistributionSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributionSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributionSessionMaxAggregateInputType
  }

  export type GetDistributionSessionAggregateType<T extends DistributionSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributionSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributionSession[P]>
      : GetScalarType<T[P], AggregateDistributionSession[P]>
  }




  export type DistributionSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionSessionWhereInput
    orderBy?: DistributionSessionOrderByWithAggregationInput | DistributionSessionOrderByWithAggregationInput[]
    by: DistributionSessionScalarFieldEnum[] | DistributionSessionScalarFieldEnum
    having?: DistributionSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributionSessionCountAggregateInputType | true
    _min?: DistributionSessionMinAggregateInputType
    _max?: DistributionSessionMaxAggregateInputType
  }

  export type DistributionSessionGroupByOutputType = {
    id: string
    campaignId: string
    currentScenario: string | null
    presentationMode: boolean
    lastSaved: Date
    hasUnsavedChanges: boolean
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DistributionSessionCountAggregateOutputType | null
    _min: DistributionSessionMinAggregateOutputType | null
    _max: DistributionSessionMaxAggregateOutputType | null
  }

  type GetDistributionSessionGroupByPayload<T extends DistributionSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributionSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributionSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributionSessionGroupByOutputType[P]>
            : GetScalarType<T[P], DistributionSessionGroupByOutputType[P]>
        }
      >
    >


  export type DistributionSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    currentScenario?: boolean
    presentationMode?: boolean
    lastSaved?: boolean
    hasUnsavedChanges?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    scenarios?: boolean | DistributionSession$scenariosArgs<ExtArgs>
    _count?: boolean | DistributionSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributionSession"]>

  export type DistributionSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    currentScenario?: boolean
    presentationMode?: boolean
    lastSaved?: boolean
    hasUnsavedChanges?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributionSession"]>

  export type DistributionSessionSelectScalar = {
    id?: boolean
    campaignId?: boolean
    currentScenario?: boolean
    presentationMode?: boolean
    lastSaved?: boolean
    hasUnsavedChanges?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DistributionSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    scenarios?: boolean | DistributionSession$scenariosArgs<ExtArgs>
    _count?: boolean | DistributionSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistributionSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $DistributionSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DistributionSession"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      scenarios: Prisma.$DistributionScenarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      currentScenario: string | null
      presentationMode: boolean
      lastSaved: Date
      hasUnsavedChanges: boolean
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["distributionSession"]>
    composites: {}
  }

  type DistributionSessionGetPayload<S extends boolean | null | undefined | DistributionSessionDefaultArgs> = $Result.GetResult<Prisma.$DistributionSessionPayload, S>

  type DistributionSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistributionSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistributionSessionCountAggregateInputType | true
    }

  export interface DistributionSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DistributionSession'], meta: { name: 'DistributionSession' } }
    /**
     * Find zero or one DistributionSession that matches the filter.
     * @param {DistributionSessionFindUniqueArgs} args - Arguments to find a DistributionSession
     * @example
     * // Get one DistributionSession
     * const distributionSession = await prisma.distributionSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributionSessionFindUniqueArgs>(args: SelectSubset<T, DistributionSessionFindUniqueArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DistributionSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistributionSessionFindUniqueOrThrowArgs} args - Arguments to find a DistributionSession
     * @example
     * // Get one DistributionSession
     * const distributionSession = await prisma.distributionSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributionSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributionSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DistributionSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionFindFirstArgs} args - Arguments to find a DistributionSession
     * @example
     * // Get one DistributionSession
     * const distributionSession = await prisma.distributionSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributionSessionFindFirstArgs>(args?: SelectSubset<T, DistributionSessionFindFirstArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DistributionSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionFindFirstOrThrowArgs} args - Arguments to find a DistributionSession
     * @example
     * // Get one DistributionSession
     * const distributionSession = await prisma.distributionSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributionSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributionSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DistributionSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DistributionSessions
     * const distributionSessions = await prisma.distributionSession.findMany()
     * 
     * // Get first 10 DistributionSessions
     * const distributionSessions = await prisma.distributionSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributionSessionWithIdOnly = await prisma.distributionSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistributionSessionFindManyArgs>(args?: SelectSubset<T, DistributionSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DistributionSession.
     * @param {DistributionSessionCreateArgs} args - Arguments to create a DistributionSession.
     * @example
     * // Create one DistributionSession
     * const DistributionSession = await prisma.distributionSession.create({
     *   data: {
     *     // ... data to create a DistributionSession
     *   }
     * })
     * 
     */
    create<T extends DistributionSessionCreateArgs>(args: SelectSubset<T, DistributionSessionCreateArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DistributionSessions.
     * @param {DistributionSessionCreateManyArgs} args - Arguments to create many DistributionSessions.
     * @example
     * // Create many DistributionSessions
     * const distributionSession = await prisma.distributionSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributionSessionCreateManyArgs>(args?: SelectSubset<T, DistributionSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DistributionSessions and returns the data saved in the database.
     * @param {DistributionSessionCreateManyAndReturnArgs} args - Arguments to create many DistributionSessions.
     * @example
     * // Create many DistributionSessions
     * const distributionSession = await prisma.distributionSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DistributionSessions and only return the `id`
     * const distributionSessionWithIdOnly = await prisma.distributionSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistributionSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, DistributionSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DistributionSession.
     * @param {DistributionSessionDeleteArgs} args - Arguments to delete one DistributionSession.
     * @example
     * // Delete one DistributionSession
     * const DistributionSession = await prisma.distributionSession.delete({
     *   where: {
     *     // ... filter to delete one DistributionSession
     *   }
     * })
     * 
     */
    delete<T extends DistributionSessionDeleteArgs>(args: SelectSubset<T, DistributionSessionDeleteArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DistributionSession.
     * @param {DistributionSessionUpdateArgs} args - Arguments to update one DistributionSession.
     * @example
     * // Update one DistributionSession
     * const distributionSession = await prisma.distributionSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributionSessionUpdateArgs>(args: SelectSubset<T, DistributionSessionUpdateArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DistributionSessions.
     * @param {DistributionSessionDeleteManyArgs} args - Arguments to filter DistributionSessions to delete.
     * @example
     * // Delete a few DistributionSessions
     * const { count } = await prisma.distributionSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributionSessionDeleteManyArgs>(args?: SelectSubset<T, DistributionSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DistributionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DistributionSessions
     * const distributionSession = await prisma.distributionSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributionSessionUpdateManyArgs>(args: SelectSubset<T, DistributionSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DistributionSession.
     * @param {DistributionSessionUpsertArgs} args - Arguments to update or create a DistributionSession.
     * @example
     * // Update or create a DistributionSession
     * const distributionSession = await prisma.distributionSession.upsert({
     *   create: {
     *     // ... data to create a DistributionSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DistributionSession we want to update
     *   }
     * })
     */
    upsert<T extends DistributionSessionUpsertArgs>(args: SelectSubset<T, DistributionSessionUpsertArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DistributionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionCountArgs} args - Arguments to filter DistributionSessions to count.
     * @example
     * // Count the number of DistributionSessions
     * const count = await prisma.distributionSession.count({
     *   where: {
     *     // ... the filter for the DistributionSessions we want to count
     *   }
     * })
    **/
    count<T extends DistributionSessionCountArgs>(
      args?: Subset<T, DistributionSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributionSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DistributionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributionSessionAggregateArgs>(args: Subset<T, DistributionSessionAggregateArgs>): Prisma.PrismaPromise<GetDistributionSessionAggregateType<T>>

    /**
     * Group by DistributionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributionSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributionSessionGroupByArgs['orderBy'] }
        : { orderBy?: DistributionSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributionSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributionSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DistributionSession model
   */
  readonly fields: DistributionSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DistributionSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributionSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scenarios<T extends DistributionSession$scenariosArgs<ExtArgs> = {}>(args?: Subset<T, DistributionSession$scenariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DistributionSession model
   */ 
  interface DistributionSessionFieldRefs {
    readonly id: FieldRef<"DistributionSession", 'String'>
    readonly campaignId: FieldRef<"DistributionSession", 'String'>
    readonly currentScenario: FieldRef<"DistributionSession", 'String'>
    readonly presentationMode: FieldRef<"DistributionSession", 'Boolean'>
    readonly lastSaved: FieldRef<"DistributionSession", 'DateTime'>
    readonly hasUnsavedChanges: FieldRef<"DistributionSession", 'Boolean'>
    readonly metadata: FieldRef<"DistributionSession", 'Json'>
    readonly createdAt: FieldRef<"DistributionSession", 'DateTime'>
    readonly updatedAt: FieldRef<"DistributionSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DistributionSession findUnique
   */
  export type DistributionSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * Filter, which DistributionSession to fetch.
     */
    where: DistributionSessionWhereUniqueInput
  }

  /**
   * DistributionSession findUniqueOrThrow
   */
  export type DistributionSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * Filter, which DistributionSession to fetch.
     */
    where: DistributionSessionWhereUniqueInput
  }

  /**
   * DistributionSession findFirst
   */
  export type DistributionSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * Filter, which DistributionSession to fetch.
     */
    where?: DistributionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionSessions to fetch.
     */
    orderBy?: DistributionSessionOrderByWithRelationInput | DistributionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionSessions.
     */
    cursor?: DistributionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionSessions.
     */
    distinct?: DistributionSessionScalarFieldEnum | DistributionSessionScalarFieldEnum[]
  }

  /**
   * DistributionSession findFirstOrThrow
   */
  export type DistributionSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * Filter, which DistributionSession to fetch.
     */
    where?: DistributionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionSessions to fetch.
     */
    orderBy?: DistributionSessionOrderByWithRelationInput | DistributionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionSessions.
     */
    cursor?: DistributionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionSessions.
     */
    distinct?: DistributionSessionScalarFieldEnum | DistributionSessionScalarFieldEnum[]
  }

  /**
   * DistributionSession findMany
   */
  export type DistributionSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * Filter, which DistributionSessions to fetch.
     */
    where?: DistributionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionSessions to fetch.
     */
    orderBy?: DistributionSessionOrderByWithRelationInput | DistributionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DistributionSessions.
     */
    cursor?: DistributionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionSessions.
     */
    skip?: number
    distinct?: DistributionSessionScalarFieldEnum | DistributionSessionScalarFieldEnum[]
  }

  /**
   * DistributionSession create
   */
  export type DistributionSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a DistributionSession.
     */
    data: XOR<DistributionSessionCreateInput, DistributionSessionUncheckedCreateInput>
  }

  /**
   * DistributionSession createMany
   */
  export type DistributionSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DistributionSessions.
     */
    data: DistributionSessionCreateManyInput | DistributionSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DistributionSession createManyAndReturn
   */
  export type DistributionSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DistributionSessions.
     */
    data: DistributionSessionCreateManyInput | DistributionSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DistributionSession update
   */
  export type DistributionSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a DistributionSession.
     */
    data: XOR<DistributionSessionUpdateInput, DistributionSessionUncheckedUpdateInput>
    /**
     * Choose, which DistributionSession to update.
     */
    where: DistributionSessionWhereUniqueInput
  }

  /**
   * DistributionSession updateMany
   */
  export type DistributionSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DistributionSessions.
     */
    data: XOR<DistributionSessionUpdateManyMutationInput, DistributionSessionUncheckedUpdateManyInput>
    /**
     * Filter which DistributionSessions to update
     */
    where?: DistributionSessionWhereInput
  }

  /**
   * DistributionSession upsert
   */
  export type DistributionSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the DistributionSession to update in case it exists.
     */
    where: DistributionSessionWhereUniqueInput
    /**
     * In case the DistributionSession found by the `where` argument doesn't exist, create a new DistributionSession with this data.
     */
    create: XOR<DistributionSessionCreateInput, DistributionSessionUncheckedCreateInput>
    /**
     * In case the DistributionSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributionSessionUpdateInput, DistributionSessionUncheckedUpdateInput>
  }

  /**
   * DistributionSession delete
   */
  export type DistributionSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
    /**
     * Filter which DistributionSession to delete.
     */
    where: DistributionSessionWhereUniqueInput
  }

  /**
   * DistributionSession deleteMany
   */
  export type DistributionSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionSessions to delete
     */
    where?: DistributionSessionWhereInput
  }

  /**
   * DistributionSession.scenarios
   */
  export type DistributionSession$scenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    where?: DistributionScenarioWhereInput
    orderBy?: DistributionScenarioOrderByWithRelationInput | DistributionScenarioOrderByWithRelationInput[]
    cursor?: DistributionScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistributionScenarioScalarFieldEnum | DistributionScenarioScalarFieldEnum[]
  }

  /**
   * DistributionSession without action
   */
  export type DistributionSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionSession
     */
    select?: DistributionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionSessionInclude<ExtArgs> | null
  }


  /**
   * Model DistributionScenario
   */

  export type AggregateDistributionScenario = {
    _count: DistributionScenarioCountAggregateOutputType | null
    _min: DistributionScenarioMinAggregateOutputType | null
    _max: DistributionScenarioMaxAggregateOutputType | null
  }

  export type DistributionScenarioMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    description: string | null
    isBaseline: boolean | null
    lastModified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistributionScenarioMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    description: string | null
    isBaseline: boolean | null
    lastModified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistributionScenarioCountAggregateOutputType = {
    id: number
    sessionId: number
    name: number
    description: number
    isBaseline: number
    parameters: number
    projections: number
    lastModified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DistributionScenarioMinAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    description?: true
    isBaseline?: true
    lastModified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistributionScenarioMaxAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    description?: true
    isBaseline?: true
    lastModified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistributionScenarioCountAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    description?: true
    isBaseline?: true
    parameters?: true
    projections?: true
    lastModified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DistributionScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionScenario to aggregate.
     */
    where?: DistributionScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionScenarios to fetch.
     */
    orderBy?: DistributionScenarioOrderByWithRelationInput | DistributionScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributionScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DistributionScenarios
    **/
    _count?: true | DistributionScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributionScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributionScenarioMaxAggregateInputType
  }

  export type GetDistributionScenarioAggregateType<T extends DistributionScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributionScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributionScenario[P]>
      : GetScalarType<T[P], AggregateDistributionScenario[P]>
  }




  export type DistributionScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionScenarioWhereInput
    orderBy?: DistributionScenarioOrderByWithAggregationInput | DistributionScenarioOrderByWithAggregationInput[]
    by: DistributionScenarioScalarFieldEnum[] | DistributionScenarioScalarFieldEnum
    having?: DistributionScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributionScenarioCountAggregateInputType | true
    _min?: DistributionScenarioMinAggregateInputType
    _max?: DistributionScenarioMaxAggregateInputType
  }

  export type DistributionScenarioGroupByOutputType = {
    id: string
    sessionId: string
    name: string
    description: string | null
    isBaseline: boolean
    parameters: JsonValue
    projections: JsonValue
    lastModified: Date
    createdAt: Date
    updatedAt: Date
    _count: DistributionScenarioCountAggregateOutputType | null
    _min: DistributionScenarioMinAggregateOutputType | null
    _max: DistributionScenarioMaxAggregateOutputType | null
  }

  type GetDistributionScenarioGroupByPayload<T extends DistributionScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributionScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributionScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributionScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], DistributionScenarioGroupByOutputType[P]>
        }
      >
    >


  export type DistributionScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    description?: boolean
    isBaseline?: boolean
    parameters?: boolean
    projections?: boolean
    lastModified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | DistributionSessionDefaultArgs<ExtArgs>
    changes?: boolean | DistributionScenario$changesArgs<ExtArgs>
    _count?: boolean | DistributionScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributionScenario"]>

  export type DistributionScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    description?: boolean
    isBaseline?: boolean
    parameters?: boolean
    projections?: boolean
    lastModified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | DistributionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distributionScenario"]>

  export type DistributionScenarioSelectScalar = {
    id?: boolean
    sessionId?: boolean
    name?: boolean
    description?: boolean
    isBaseline?: boolean
    parameters?: boolean
    projections?: boolean
    lastModified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DistributionScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | DistributionSessionDefaultArgs<ExtArgs>
    changes?: boolean | DistributionScenario$changesArgs<ExtArgs>
    _count?: boolean | DistributionScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistributionScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | DistributionSessionDefaultArgs<ExtArgs>
  }

  export type $DistributionScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DistributionScenario"
    objects: {
      session: Prisma.$DistributionSessionPayload<ExtArgs>
      changes: Prisma.$DistributionChangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      name: string
      description: string | null
      isBaseline: boolean
      parameters: Prisma.JsonValue
      projections: Prisma.JsonValue
      lastModified: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["distributionScenario"]>
    composites: {}
  }

  type DistributionScenarioGetPayload<S extends boolean | null | undefined | DistributionScenarioDefaultArgs> = $Result.GetResult<Prisma.$DistributionScenarioPayload, S>

  type DistributionScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistributionScenarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistributionScenarioCountAggregateInputType | true
    }

  export interface DistributionScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DistributionScenario'], meta: { name: 'DistributionScenario' } }
    /**
     * Find zero or one DistributionScenario that matches the filter.
     * @param {DistributionScenarioFindUniqueArgs} args - Arguments to find a DistributionScenario
     * @example
     * // Get one DistributionScenario
     * const distributionScenario = await prisma.distributionScenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributionScenarioFindUniqueArgs>(args: SelectSubset<T, DistributionScenarioFindUniqueArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DistributionScenario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistributionScenarioFindUniqueOrThrowArgs} args - Arguments to find a DistributionScenario
     * @example
     * // Get one DistributionScenario
     * const distributionScenario = await prisma.distributionScenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributionScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributionScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DistributionScenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioFindFirstArgs} args - Arguments to find a DistributionScenario
     * @example
     * // Get one DistributionScenario
     * const distributionScenario = await prisma.distributionScenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributionScenarioFindFirstArgs>(args?: SelectSubset<T, DistributionScenarioFindFirstArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DistributionScenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioFindFirstOrThrowArgs} args - Arguments to find a DistributionScenario
     * @example
     * // Get one DistributionScenario
     * const distributionScenario = await prisma.distributionScenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributionScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributionScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DistributionScenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DistributionScenarios
     * const distributionScenarios = await prisma.distributionScenario.findMany()
     * 
     * // Get first 10 DistributionScenarios
     * const distributionScenarios = await prisma.distributionScenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributionScenarioWithIdOnly = await prisma.distributionScenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistributionScenarioFindManyArgs>(args?: SelectSubset<T, DistributionScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DistributionScenario.
     * @param {DistributionScenarioCreateArgs} args - Arguments to create a DistributionScenario.
     * @example
     * // Create one DistributionScenario
     * const DistributionScenario = await prisma.distributionScenario.create({
     *   data: {
     *     // ... data to create a DistributionScenario
     *   }
     * })
     * 
     */
    create<T extends DistributionScenarioCreateArgs>(args: SelectSubset<T, DistributionScenarioCreateArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DistributionScenarios.
     * @param {DistributionScenarioCreateManyArgs} args - Arguments to create many DistributionScenarios.
     * @example
     * // Create many DistributionScenarios
     * const distributionScenario = await prisma.distributionScenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributionScenarioCreateManyArgs>(args?: SelectSubset<T, DistributionScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DistributionScenarios and returns the data saved in the database.
     * @param {DistributionScenarioCreateManyAndReturnArgs} args - Arguments to create many DistributionScenarios.
     * @example
     * // Create many DistributionScenarios
     * const distributionScenario = await prisma.distributionScenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DistributionScenarios and only return the `id`
     * const distributionScenarioWithIdOnly = await prisma.distributionScenario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistributionScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, DistributionScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DistributionScenario.
     * @param {DistributionScenarioDeleteArgs} args - Arguments to delete one DistributionScenario.
     * @example
     * // Delete one DistributionScenario
     * const DistributionScenario = await prisma.distributionScenario.delete({
     *   where: {
     *     // ... filter to delete one DistributionScenario
     *   }
     * })
     * 
     */
    delete<T extends DistributionScenarioDeleteArgs>(args: SelectSubset<T, DistributionScenarioDeleteArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DistributionScenario.
     * @param {DistributionScenarioUpdateArgs} args - Arguments to update one DistributionScenario.
     * @example
     * // Update one DistributionScenario
     * const distributionScenario = await prisma.distributionScenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributionScenarioUpdateArgs>(args: SelectSubset<T, DistributionScenarioUpdateArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DistributionScenarios.
     * @param {DistributionScenarioDeleteManyArgs} args - Arguments to filter DistributionScenarios to delete.
     * @example
     * // Delete a few DistributionScenarios
     * const { count } = await prisma.distributionScenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributionScenarioDeleteManyArgs>(args?: SelectSubset<T, DistributionScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DistributionScenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DistributionScenarios
     * const distributionScenario = await prisma.distributionScenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributionScenarioUpdateManyArgs>(args: SelectSubset<T, DistributionScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DistributionScenario.
     * @param {DistributionScenarioUpsertArgs} args - Arguments to update or create a DistributionScenario.
     * @example
     * // Update or create a DistributionScenario
     * const distributionScenario = await prisma.distributionScenario.upsert({
     *   create: {
     *     // ... data to create a DistributionScenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DistributionScenario we want to update
     *   }
     * })
     */
    upsert<T extends DistributionScenarioUpsertArgs>(args: SelectSubset<T, DistributionScenarioUpsertArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DistributionScenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioCountArgs} args - Arguments to filter DistributionScenarios to count.
     * @example
     * // Count the number of DistributionScenarios
     * const count = await prisma.distributionScenario.count({
     *   where: {
     *     // ... the filter for the DistributionScenarios we want to count
     *   }
     * })
    **/
    count<T extends DistributionScenarioCountArgs>(
      args?: Subset<T, DistributionScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributionScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DistributionScenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributionScenarioAggregateArgs>(args: Subset<T, DistributionScenarioAggregateArgs>): Prisma.PrismaPromise<GetDistributionScenarioAggregateType<T>>

    /**
     * Group by DistributionScenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributionScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributionScenarioGroupByArgs['orderBy'] }
        : { orderBy?: DistributionScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributionScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributionScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DistributionScenario model
   */
  readonly fields: DistributionScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DistributionScenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributionScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends DistributionSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistributionSessionDefaultArgs<ExtArgs>>): Prisma__DistributionSessionClient<$Result.GetResult<Prisma.$DistributionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changes<T extends DistributionScenario$changesArgs<ExtArgs> = {}>(args?: Subset<T, DistributionScenario$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DistributionScenario model
   */ 
  interface DistributionScenarioFieldRefs {
    readonly id: FieldRef<"DistributionScenario", 'String'>
    readonly sessionId: FieldRef<"DistributionScenario", 'String'>
    readonly name: FieldRef<"DistributionScenario", 'String'>
    readonly description: FieldRef<"DistributionScenario", 'String'>
    readonly isBaseline: FieldRef<"DistributionScenario", 'Boolean'>
    readonly parameters: FieldRef<"DistributionScenario", 'Json'>
    readonly projections: FieldRef<"DistributionScenario", 'Json'>
    readonly lastModified: FieldRef<"DistributionScenario", 'DateTime'>
    readonly createdAt: FieldRef<"DistributionScenario", 'DateTime'>
    readonly updatedAt: FieldRef<"DistributionScenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DistributionScenario findUnique
   */
  export type DistributionScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * Filter, which DistributionScenario to fetch.
     */
    where: DistributionScenarioWhereUniqueInput
  }

  /**
   * DistributionScenario findUniqueOrThrow
   */
  export type DistributionScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * Filter, which DistributionScenario to fetch.
     */
    where: DistributionScenarioWhereUniqueInput
  }

  /**
   * DistributionScenario findFirst
   */
  export type DistributionScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * Filter, which DistributionScenario to fetch.
     */
    where?: DistributionScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionScenarios to fetch.
     */
    orderBy?: DistributionScenarioOrderByWithRelationInput | DistributionScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionScenarios.
     */
    cursor?: DistributionScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionScenarios.
     */
    distinct?: DistributionScenarioScalarFieldEnum | DistributionScenarioScalarFieldEnum[]
  }

  /**
   * DistributionScenario findFirstOrThrow
   */
  export type DistributionScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * Filter, which DistributionScenario to fetch.
     */
    where?: DistributionScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionScenarios to fetch.
     */
    orderBy?: DistributionScenarioOrderByWithRelationInput | DistributionScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionScenarios.
     */
    cursor?: DistributionScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionScenarios.
     */
    distinct?: DistributionScenarioScalarFieldEnum | DistributionScenarioScalarFieldEnum[]
  }

  /**
   * DistributionScenario findMany
   */
  export type DistributionScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * Filter, which DistributionScenarios to fetch.
     */
    where?: DistributionScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionScenarios to fetch.
     */
    orderBy?: DistributionScenarioOrderByWithRelationInput | DistributionScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DistributionScenarios.
     */
    cursor?: DistributionScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionScenarios.
     */
    skip?: number
    distinct?: DistributionScenarioScalarFieldEnum | DistributionScenarioScalarFieldEnum[]
  }

  /**
   * DistributionScenario create
   */
  export type DistributionScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a DistributionScenario.
     */
    data: XOR<DistributionScenarioCreateInput, DistributionScenarioUncheckedCreateInput>
  }

  /**
   * DistributionScenario createMany
   */
  export type DistributionScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DistributionScenarios.
     */
    data: DistributionScenarioCreateManyInput | DistributionScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DistributionScenario createManyAndReturn
   */
  export type DistributionScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DistributionScenarios.
     */
    data: DistributionScenarioCreateManyInput | DistributionScenarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DistributionScenario update
   */
  export type DistributionScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a DistributionScenario.
     */
    data: XOR<DistributionScenarioUpdateInput, DistributionScenarioUncheckedUpdateInput>
    /**
     * Choose, which DistributionScenario to update.
     */
    where: DistributionScenarioWhereUniqueInput
  }

  /**
   * DistributionScenario updateMany
   */
  export type DistributionScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DistributionScenarios.
     */
    data: XOR<DistributionScenarioUpdateManyMutationInput, DistributionScenarioUncheckedUpdateManyInput>
    /**
     * Filter which DistributionScenarios to update
     */
    where?: DistributionScenarioWhereInput
  }

  /**
   * DistributionScenario upsert
   */
  export type DistributionScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the DistributionScenario to update in case it exists.
     */
    where: DistributionScenarioWhereUniqueInput
    /**
     * In case the DistributionScenario found by the `where` argument doesn't exist, create a new DistributionScenario with this data.
     */
    create: XOR<DistributionScenarioCreateInput, DistributionScenarioUncheckedCreateInput>
    /**
     * In case the DistributionScenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributionScenarioUpdateInput, DistributionScenarioUncheckedUpdateInput>
  }

  /**
   * DistributionScenario delete
   */
  export type DistributionScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
    /**
     * Filter which DistributionScenario to delete.
     */
    where: DistributionScenarioWhereUniqueInput
  }

  /**
   * DistributionScenario deleteMany
   */
  export type DistributionScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionScenarios to delete
     */
    where?: DistributionScenarioWhereInput
  }

  /**
   * DistributionScenario.changes
   */
  export type DistributionScenario$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    where?: DistributionChangeWhereInput
    orderBy?: DistributionChangeOrderByWithRelationInput | DistributionChangeOrderByWithRelationInput[]
    cursor?: DistributionChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistributionChangeScalarFieldEnum | DistributionChangeScalarFieldEnum[]
  }

  /**
   * DistributionScenario without action
   */
  export type DistributionScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionScenario
     */
    select?: DistributionScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionScenarioInclude<ExtArgs> | null
  }


  /**
   * Model DistributionChange
   */

  export type AggregateDistributionChange = {
    _count: DistributionChangeCountAggregateOutputType | null
    _min: DistributionChangeMinAggregateOutputType | null
    _max: DistributionChangeMaxAggregateOutputType | null
  }

  export type DistributionChangeMinAggregateOutputType = {
    id: string | null
    scenarioId: string | null
    field: string | null
    userId: string | null
    timestamp: Date | null
  }

  export type DistributionChangeMaxAggregateOutputType = {
    id: string | null
    scenarioId: string | null
    field: string | null
    userId: string | null
    timestamp: Date | null
  }

  export type DistributionChangeCountAggregateOutputType = {
    id: number
    scenarioId: number
    field: number
    oldValue: number
    newValue: number
    userId: number
    timestamp: number
    _all: number
  }


  export type DistributionChangeMinAggregateInputType = {
    id?: true
    scenarioId?: true
    field?: true
    userId?: true
    timestamp?: true
  }

  export type DistributionChangeMaxAggregateInputType = {
    id?: true
    scenarioId?: true
    field?: true
    userId?: true
    timestamp?: true
  }

  export type DistributionChangeCountAggregateInputType = {
    id?: true
    scenarioId?: true
    field?: true
    oldValue?: true
    newValue?: true
    userId?: true
    timestamp?: true
    _all?: true
  }

  export type DistributionChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionChange to aggregate.
     */
    where?: DistributionChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionChanges to fetch.
     */
    orderBy?: DistributionChangeOrderByWithRelationInput | DistributionChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributionChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DistributionChanges
    **/
    _count?: true | DistributionChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributionChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributionChangeMaxAggregateInputType
  }

  export type GetDistributionChangeAggregateType<T extends DistributionChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributionChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributionChange[P]>
      : GetScalarType<T[P], AggregateDistributionChange[P]>
  }




  export type DistributionChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionChangeWhereInput
    orderBy?: DistributionChangeOrderByWithAggregationInput | DistributionChangeOrderByWithAggregationInput[]
    by: DistributionChangeScalarFieldEnum[] | DistributionChangeScalarFieldEnum
    having?: DistributionChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributionChangeCountAggregateInputType | true
    _min?: DistributionChangeMinAggregateInputType
    _max?: DistributionChangeMaxAggregateInputType
  }

  export type DistributionChangeGroupByOutputType = {
    id: string
    scenarioId: string
    field: string
    oldValue: JsonValue
    newValue: JsonValue
    userId: string | null
    timestamp: Date
    _count: DistributionChangeCountAggregateOutputType | null
    _min: DistributionChangeMinAggregateOutputType | null
    _max: DistributionChangeMaxAggregateOutputType | null
  }

  type GetDistributionChangeGroupByPayload<T extends DistributionChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributionChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributionChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributionChangeGroupByOutputType[P]>
            : GetScalarType<T[P], DistributionChangeGroupByOutputType[P]>
        }
      >
    >


  export type DistributionChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    timestamp?: boolean
    scenario?: boolean | DistributionScenarioDefaultArgs<ExtArgs>
    user?: boolean | DistributionChange$userArgs<ExtArgs>
  }, ExtArgs["result"]["distributionChange"]>

  export type DistributionChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    timestamp?: boolean
    scenario?: boolean | DistributionScenarioDefaultArgs<ExtArgs>
    user?: boolean | DistributionChange$userArgs<ExtArgs>
  }, ExtArgs["result"]["distributionChange"]>

  export type DistributionChangeSelectScalar = {
    id?: boolean
    scenarioId?: boolean
    field?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    timestamp?: boolean
  }

  export type DistributionChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | DistributionScenarioDefaultArgs<ExtArgs>
    user?: boolean | DistributionChange$userArgs<ExtArgs>
  }
  export type DistributionChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | DistributionScenarioDefaultArgs<ExtArgs>
    user?: boolean | DistributionChange$userArgs<ExtArgs>
  }

  export type $DistributionChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DistributionChange"
    objects: {
      scenario: Prisma.$DistributionScenarioPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scenarioId: string
      field: string
      oldValue: Prisma.JsonValue
      newValue: Prisma.JsonValue
      userId: string | null
      timestamp: Date
    }, ExtArgs["result"]["distributionChange"]>
    composites: {}
  }

  type DistributionChangeGetPayload<S extends boolean | null | undefined | DistributionChangeDefaultArgs> = $Result.GetResult<Prisma.$DistributionChangePayload, S>

  type DistributionChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistributionChangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistributionChangeCountAggregateInputType | true
    }

  export interface DistributionChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DistributionChange'], meta: { name: 'DistributionChange' } }
    /**
     * Find zero or one DistributionChange that matches the filter.
     * @param {DistributionChangeFindUniqueArgs} args - Arguments to find a DistributionChange
     * @example
     * // Get one DistributionChange
     * const distributionChange = await prisma.distributionChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributionChangeFindUniqueArgs>(args: SelectSubset<T, DistributionChangeFindUniqueArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DistributionChange that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistributionChangeFindUniqueOrThrowArgs} args - Arguments to find a DistributionChange
     * @example
     * // Get one DistributionChange
     * const distributionChange = await prisma.distributionChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributionChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributionChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DistributionChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeFindFirstArgs} args - Arguments to find a DistributionChange
     * @example
     * // Get one DistributionChange
     * const distributionChange = await prisma.distributionChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributionChangeFindFirstArgs>(args?: SelectSubset<T, DistributionChangeFindFirstArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DistributionChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeFindFirstOrThrowArgs} args - Arguments to find a DistributionChange
     * @example
     * // Get one DistributionChange
     * const distributionChange = await prisma.distributionChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributionChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributionChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DistributionChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DistributionChanges
     * const distributionChanges = await prisma.distributionChange.findMany()
     * 
     * // Get first 10 DistributionChanges
     * const distributionChanges = await prisma.distributionChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributionChangeWithIdOnly = await prisma.distributionChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistributionChangeFindManyArgs>(args?: SelectSubset<T, DistributionChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DistributionChange.
     * @param {DistributionChangeCreateArgs} args - Arguments to create a DistributionChange.
     * @example
     * // Create one DistributionChange
     * const DistributionChange = await prisma.distributionChange.create({
     *   data: {
     *     // ... data to create a DistributionChange
     *   }
     * })
     * 
     */
    create<T extends DistributionChangeCreateArgs>(args: SelectSubset<T, DistributionChangeCreateArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DistributionChanges.
     * @param {DistributionChangeCreateManyArgs} args - Arguments to create many DistributionChanges.
     * @example
     * // Create many DistributionChanges
     * const distributionChange = await prisma.distributionChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributionChangeCreateManyArgs>(args?: SelectSubset<T, DistributionChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DistributionChanges and returns the data saved in the database.
     * @param {DistributionChangeCreateManyAndReturnArgs} args - Arguments to create many DistributionChanges.
     * @example
     * // Create many DistributionChanges
     * const distributionChange = await prisma.distributionChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DistributionChanges and only return the `id`
     * const distributionChangeWithIdOnly = await prisma.distributionChange.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistributionChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, DistributionChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DistributionChange.
     * @param {DistributionChangeDeleteArgs} args - Arguments to delete one DistributionChange.
     * @example
     * // Delete one DistributionChange
     * const DistributionChange = await prisma.distributionChange.delete({
     *   where: {
     *     // ... filter to delete one DistributionChange
     *   }
     * })
     * 
     */
    delete<T extends DistributionChangeDeleteArgs>(args: SelectSubset<T, DistributionChangeDeleteArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DistributionChange.
     * @param {DistributionChangeUpdateArgs} args - Arguments to update one DistributionChange.
     * @example
     * // Update one DistributionChange
     * const distributionChange = await prisma.distributionChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributionChangeUpdateArgs>(args: SelectSubset<T, DistributionChangeUpdateArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DistributionChanges.
     * @param {DistributionChangeDeleteManyArgs} args - Arguments to filter DistributionChanges to delete.
     * @example
     * // Delete a few DistributionChanges
     * const { count } = await prisma.distributionChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributionChangeDeleteManyArgs>(args?: SelectSubset<T, DistributionChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DistributionChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DistributionChanges
     * const distributionChange = await prisma.distributionChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributionChangeUpdateManyArgs>(args: SelectSubset<T, DistributionChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DistributionChange.
     * @param {DistributionChangeUpsertArgs} args - Arguments to update or create a DistributionChange.
     * @example
     * // Update or create a DistributionChange
     * const distributionChange = await prisma.distributionChange.upsert({
     *   create: {
     *     // ... data to create a DistributionChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DistributionChange we want to update
     *   }
     * })
     */
    upsert<T extends DistributionChangeUpsertArgs>(args: SelectSubset<T, DistributionChangeUpsertArgs<ExtArgs>>): Prisma__DistributionChangeClient<$Result.GetResult<Prisma.$DistributionChangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DistributionChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeCountArgs} args - Arguments to filter DistributionChanges to count.
     * @example
     * // Count the number of DistributionChanges
     * const count = await prisma.distributionChange.count({
     *   where: {
     *     // ... the filter for the DistributionChanges we want to count
     *   }
     * })
    **/
    count<T extends DistributionChangeCountArgs>(
      args?: Subset<T, DistributionChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributionChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DistributionChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributionChangeAggregateArgs>(args: Subset<T, DistributionChangeAggregateArgs>): Prisma.PrismaPromise<GetDistributionChangeAggregateType<T>>

    /**
     * Group by DistributionChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributionChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributionChangeGroupByArgs['orderBy'] }
        : { orderBy?: DistributionChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributionChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributionChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DistributionChange model
   */
  readonly fields: DistributionChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DistributionChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributionChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scenario<T extends DistributionScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistributionScenarioDefaultArgs<ExtArgs>>): Prisma__DistributionScenarioClient<$Result.GetResult<Prisma.$DistributionScenarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends DistributionChange$userArgs<ExtArgs> = {}>(args?: Subset<T, DistributionChange$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DistributionChange model
   */ 
  interface DistributionChangeFieldRefs {
    readonly id: FieldRef<"DistributionChange", 'String'>
    readonly scenarioId: FieldRef<"DistributionChange", 'String'>
    readonly field: FieldRef<"DistributionChange", 'String'>
    readonly oldValue: FieldRef<"DistributionChange", 'Json'>
    readonly newValue: FieldRef<"DistributionChange", 'Json'>
    readonly userId: FieldRef<"DistributionChange", 'String'>
    readonly timestamp: FieldRef<"DistributionChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DistributionChange findUnique
   */
  export type DistributionChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * Filter, which DistributionChange to fetch.
     */
    where: DistributionChangeWhereUniqueInput
  }

  /**
   * DistributionChange findUniqueOrThrow
   */
  export type DistributionChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * Filter, which DistributionChange to fetch.
     */
    where: DistributionChangeWhereUniqueInput
  }

  /**
   * DistributionChange findFirst
   */
  export type DistributionChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * Filter, which DistributionChange to fetch.
     */
    where?: DistributionChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionChanges to fetch.
     */
    orderBy?: DistributionChangeOrderByWithRelationInput | DistributionChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionChanges.
     */
    cursor?: DistributionChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionChanges.
     */
    distinct?: DistributionChangeScalarFieldEnum | DistributionChangeScalarFieldEnum[]
  }

  /**
   * DistributionChange findFirstOrThrow
   */
  export type DistributionChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * Filter, which DistributionChange to fetch.
     */
    where?: DistributionChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionChanges to fetch.
     */
    orderBy?: DistributionChangeOrderByWithRelationInput | DistributionChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionChanges.
     */
    cursor?: DistributionChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionChanges.
     */
    distinct?: DistributionChangeScalarFieldEnum | DistributionChangeScalarFieldEnum[]
  }

  /**
   * DistributionChange findMany
   */
  export type DistributionChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * Filter, which DistributionChanges to fetch.
     */
    where?: DistributionChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionChanges to fetch.
     */
    orderBy?: DistributionChangeOrderByWithRelationInput | DistributionChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DistributionChanges.
     */
    cursor?: DistributionChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionChanges.
     */
    skip?: number
    distinct?: DistributionChangeScalarFieldEnum | DistributionChangeScalarFieldEnum[]
  }

  /**
   * DistributionChange create
   */
  export type DistributionChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a DistributionChange.
     */
    data: XOR<DistributionChangeCreateInput, DistributionChangeUncheckedCreateInput>
  }

  /**
   * DistributionChange createMany
   */
  export type DistributionChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DistributionChanges.
     */
    data: DistributionChangeCreateManyInput | DistributionChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DistributionChange createManyAndReturn
   */
  export type DistributionChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DistributionChanges.
     */
    data: DistributionChangeCreateManyInput | DistributionChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DistributionChange update
   */
  export type DistributionChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a DistributionChange.
     */
    data: XOR<DistributionChangeUpdateInput, DistributionChangeUncheckedUpdateInput>
    /**
     * Choose, which DistributionChange to update.
     */
    where: DistributionChangeWhereUniqueInput
  }

  /**
   * DistributionChange updateMany
   */
  export type DistributionChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DistributionChanges.
     */
    data: XOR<DistributionChangeUpdateManyMutationInput, DistributionChangeUncheckedUpdateManyInput>
    /**
     * Filter which DistributionChanges to update
     */
    where?: DistributionChangeWhereInput
  }

  /**
   * DistributionChange upsert
   */
  export type DistributionChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the DistributionChange to update in case it exists.
     */
    where: DistributionChangeWhereUniqueInput
    /**
     * In case the DistributionChange found by the `where` argument doesn't exist, create a new DistributionChange with this data.
     */
    create: XOR<DistributionChangeCreateInput, DistributionChangeUncheckedCreateInput>
    /**
     * In case the DistributionChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributionChangeUpdateInput, DistributionChangeUncheckedUpdateInput>
  }

  /**
   * DistributionChange delete
   */
  export type DistributionChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
    /**
     * Filter which DistributionChange to delete.
     */
    where: DistributionChangeWhereUniqueInput
  }

  /**
   * DistributionChange deleteMany
   */
  export type DistributionChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionChanges to delete
     */
    where?: DistributionChangeWhereInput
  }

  /**
   * DistributionChange.user
   */
  export type DistributionChange$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DistributionChange without action
   */
  export type DistributionChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionChange
     */
    select?: DistributionChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistributionChangeInclude<ExtArgs> | null
  }


  /**
   * Model DistributionCache
   */

  export type AggregateDistributionCache = {
    _count: DistributionCacheCountAggregateOutputType | null
    _min: DistributionCacheMinAggregateOutputType | null
    _max: DistributionCacheMaxAggregateOutputType | null
  }

  export type DistributionCacheMinAggregateOutputType = {
    id: string | null
    cacheKey: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type DistributionCacheMaxAggregateOutputType = {
    id: string | null
    cacheKey: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type DistributionCacheCountAggregateOutputType = {
    id: number
    cacheKey: number
    data: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type DistributionCacheMinAggregateInputType = {
    id?: true
    cacheKey?: true
    expiresAt?: true
    createdAt?: true
  }

  export type DistributionCacheMaxAggregateInputType = {
    id?: true
    cacheKey?: true
    expiresAt?: true
    createdAt?: true
  }

  export type DistributionCacheCountAggregateInputType = {
    id?: true
    cacheKey?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type DistributionCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionCache to aggregate.
     */
    where?: DistributionCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionCaches to fetch.
     */
    orderBy?: DistributionCacheOrderByWithRelationInput | DistributionCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributionCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DistributionCaches
    **/
    _count?: true | DistributionCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributionCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributionCacheMaxAggregateInputType
  }

  export type GetDistributionCacheAggregateType<T extends DistributionCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributionCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributionCache[P]>
      : GetScalarType<T[P], AggregateDistributionCache[P]>
  }




  export type DistributionCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistributionCacheWhereInput
    orderBy?: DistributionCacheOrderByWithAggregationInput | DistributionCacheOrderByWithAggregationInput[]
    by: DistributionCacheScalarFieldEnum[] | DistributionCacheScalarFieldEnum
    having?: DistributionCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributionCacheCountAggregateInputType | true
    _min?: DistributionCacheMinAggregateInputType
    _max?: DistributionCacheMaxAggregateInputType
  }

  export type DistributionCacheGroupByOutputType = {
    id: string
    cacheKey: string
    data: JsonValue
    expiresAt: Date
    createdAt: Date
    _count: DistributionCacheCountAggregateOutputType | null
    _min: DistributionCacheMinAggregateOutputType | null
    _max: DistributionCacheMaxAggregateOutputType | null
  }

  type GetDistributionCacheGroupByPayload<T extends DistributionCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistributionCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributionCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributionCacheGroupByOutputType[P]>
            : GetScalarType<T[P], DistributionCacheGroupByOutputType[P]>
        }
      >
    >


  export type DistributionCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cacheKey?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["distributionCache"]>

  export type DistributionCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cacheKey?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["distributionCache"]>

  export type DistributionCacheSelectScalar = {
    id?: boolean
    cacheKey?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }


  export type $DistributionCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DistributionCache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cacheKey: string
      data: Prisma.JsonValue
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["distributionCache"]>
    composites: {}
  }

  type DistributionCacheGetPayload<S extends boolean | null | undefined | DistributionCacheDefaultArgs> = $Result.GetResult<Prisma.$DistributionCachePayload, S>

  type DistributionCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistributionCacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistributionCacheCountAggregateInputType | true
    }

  export interface DistributionCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DistributionCache'], meta: { name: 'DistributionCache' } }
    /**
     * Find zero or one DistributionCache that matches the filter.
     * @param {DistributionCacheFindUniqueArgs} args - Arguments to find a DistributionCache
     * @example
     * // Get one DistributionCache
     * const distributionCache = await prisma.distributionCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistributionCacheFindUniqueArgs>(args: SelectSubset<T, DistributionCacheFindUniqueArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DistributionCache that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistributionCacheFindUniqueOrThrowArgs} args - Arguments to find a DistributionCache
     * @example
     * // Get one DistributionCache
     * const distributionCache = await prisma.distributionCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistributionCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, DistributionCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DistributionCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheFindFirstArgs} args - Arguments to find a DistributionCache
     * @example
     * // Get one DistributionCache
     * const distributionCache = await prisma.distributionCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistributionCacheFindFirstArgs>(args?: SelectSubset<T, DistributionCacheFindFirstArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DistributionCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheFindFirstOrThrowArgs} args - Arguments to find a DistributionCache
     * @example
     * // Get one DistributionCache
     * const distributionCache = await prisma.distributionCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistributionCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, DistributionCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DistributionCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DistributionCaches
     * const distributionCaches = await prisma.distributionCache.findMany()
     * 
     * // Get first 10 DistributionCaches
     * const distributionCaches = await prisma.distributionCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributionCacheWithIdOnly = await prisma.distributionCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistributionCacheFindManyArgs>(args?: SelectSubset<T, DistributionCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DistributionCache.
     * @param {DistributionCacheCreateArgs} args - Arguments to create a DistributionCache.
     * @example
     * // Create one DistributionCache
     * const DistributionCache = await prisma.distributionCache.create({
     *   data: {
     *     // ... data to create a DistributionCache
     *   }
     * })
     * 
     */
    create<T extends DistributionCacheCreateArgs>(args: SelectSubset<T, DistributionCacheCreateArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DistributionCaches.
     * @param {DistributionCacheCreateManyArgs} args - Arguments to create many DistributionCaches.
     * @example
     * // Create many DistributionCaches
     * const distributionCache = await prisma.distributionCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistributionCacheCreateManyArgs>(args?: SelectSubset<T, DistributionCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DistributionCaches and returns the data saved in the database.
     * @param {DistributionCacheCreateManyAndReturnArgs} args - Arguments to create many DistributionCaches.
     * @example
     * // Create many DistributionCaches
     * const distributionCache = await prisma.distributionCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DistributionCaches and only return the `id`
     * const distributionCacheWithIdOnly = await prisma.distributionCache.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistributionCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, DistributionCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DistributionCache.
     * @param {DistributionCacheDeleteArgs} args - Arguments to delete one DistributionCache.
     * @example
     * // Delete one DistributionCache
     * const DistributionCache = await prisma.distributionCache.delete({
     *   where: {
     *     // ... filter to delete one DistributionCache
     *   }
     * })
     * 
     */
    delete<T extends DistributionCacheDeleteArgs>(args: SelectSubset<T, DistributionCacheDeleteArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DistributionCache.
     * @param {DistributionCacheUpdateArgs} args - Arguments to update one DistributionCache.
     * @example
     * // Update one DistributionCache
     * const distributionCache = await prisma.distributionCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistributionCacheUpdateArgs>(args: SelectSubset<T, DistributionCacheUpdateArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DistributionCaches.
     * @param {DistributionCacheDeleteManyArgs} args - Arguments to filter DistributionCaches to delete.
     * @example
     * // Delete a few DistributionCaches
     * const { count } = await prisma.distributionCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistributionCacheDeleteManyArgs>(args?: SelectSubset<T, DistributionCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DistributionCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DistributionCaches
     * const distributionCache = await prisma.distributionCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistributionCacheUpdateManyArgs>(args: SelectSubset<T, DistributionCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DistributionCache.
     * @param {DistributionCacheUpsertArgs} args - Arguments to update or create a DistributionCache.
     * @example
     * // Update or create a DistributionCache
     * const distributionCache = await prisma.distributionCache.upsert({
     *   create: {
     *     // ... data to create a DistributionCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DistributionCache we want to update
     *   }
     * })
     */
    upsert<T extends DistributionCacheUpsertArgs>(args: SelectSubset<T, DistributionCacheUpsertArgs<ExtArgs>>): Prisma__DistributionCacheClient<$Result.GetResult<Prisma.$DistributionCachePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DistributionCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheCountArgs} args - Arguments to filter DistributionCaches to count.
     * @example
     * // Count the number of DistributionCaches
     * const count = await prisma.distributionCache.count({
     *   where: {
     *     // ... the filter for the DistributionCaches we want to count
     *   }
     * })
    **/
    count<T extends DistributionCacheCountArgs>(
      args?: Subset<T, DistributionCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributionCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DistributionCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributionCacheAggregateArgs>(args: Subset<T, DistributionCacheAggregateArgs>): Prisma.PrismaPromise<GetDistributionCacheAggregateType<T>>

    /**
     * Group by DistributionCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributionCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributionCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributionCacheGroupByArgs['orderBy'] }
        : { orderBy?: DistributionCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributionCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributionCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DistributionCache model
   */
  readonly fields: DistributionCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DistributionCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistributionCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DistributionCache model
   */ 
  interface DistributionCacheFieldRefs {
    readonly id: FieldRef<"DistributionCache", 'String'>
    readonly cacheKey: FieldRef<"DistributionCache", 'String'>
    readonly data: FieldRef<"DistributionCache", 'Json'>
    readonly expiresAt: FieldRef<"DistributionCache", 'DateTime'>
    readonly createdAt: FieldRef<"DistributionCache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DistributionCache findUnique
   */
  export type DistributionCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * Filter, which DistributionCache to fetch.
     */
    where: DistributionCacheWhereUniqueInput
  }

  /**
   * DistributionCache findUniqueOrThrow
   */
  export type DistributionCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * Filter, which DistributionCache to fetch.
     */
    where: DistributionCacheWhereUniqueInput
  }

  /**
   * DistributionCache findFirst
   */
  export type DistributionCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * Filter, which DistributionCache to fetch.
     */
    where?: DistributionCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionCaches to fetch.
     */
    orderBy?: DistributionCacheOrderByWithRelationInput | DistributionCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionCaches.
     */
    cursor?: DistributionCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionCaches.
     */
    distinct?: DistributionCacheScalarFieldEnum | DistributionCacheScalarFieldEnum[]
  }

  /**
   * DistributionCache findFirstOrThrow
   */
  export type DistributionCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * Filter, which DistributionCache to fetch.
     */
    where?: DistributionCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionCaches to fetch.
     */
    orderBy?: DistributionCacheOrderByWithRelationInput | DistributionCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DistributionCaches.
     */
    cursor?: DistributionCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DistributionCaches.
     */
    distinct?: DistributionCacheScalarFieldEnum | DistributionCacheScalarFieldEnum[]
  }

  /**
   * DistributionCache findMany
   */
  export type DistributionCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * Filter, which DistributionCaches to fetch.
     */
    where?: DistributionCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DistributionCaches to fetch.
     */
    orderBy?: DistributionCacheOrderByWithRelationInput | DistributionCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DistributionCaches.
     */
    cursor?: DistributionCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DistributionCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DistributionCaches.
     */
    skip?: number
    distinct?: DistributionCacheScalarFieldEnum | DistributionCacheScalarFieldEnum[]
  }

  /**
   * DistributionCache create
   */
  export type DistributionCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * The data needed to create a DistributionCache.
     */
    data: XOR<DistributionCacheCreateInput, DistributionCacheUncheckedCreateInput>
  }

  /**
   * DistributionCache createMany
   */
  export type DistributionCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DistributionCaches.
     */
    data: DistributionCacheCreateManyInput | DistributionCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DistributionCache createManyAndReturn
   */
  export type DistributionCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DistributionCaches.
     */
    data: DistributionCacheCreateManyInput | DistributionCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DistributionCache update
   */
  export type DistributionCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * The data needed to update a DistributionCache.
     */
    data: XOR<DistributionCacheUpdateInput, DistributionCacheUncheckedUpdateInput>
    /**
     * Choose, which DistributionCache to update.
     */
    where: DistributionCacheWhereUniqueInput
  }

  /**
   * DistributionCache updateMany
   */
  export type DistributionCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DistributionCaches.
     */
    data: XOR<DistributionCacheUpdateManyMutationInput, DistributionCacheUncheckedUpdateManyInput>
    /**
     * Filter which DistributionCaches to update
     */
    where?: DistributionCacheWhereInput
  }

  /**
   * DistributionCache upsert
   */
  export type DistributionCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * The filter to search for the DistributionCache to update in case it exists.
     */
    where: DistributionCacheWhereUniqueInput
    /**
     * In case the DistributionCache found by the `where` argument doesn't exist, create a new DistributionCache with this data.
     */
    create: XOR<DistributionCacheCreateInput, DistributionCacheUncheckedCreateInput>
    /**
     * In case the DistributionCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributionCacheUpdateInput, DistributionCacheUncheckedUpdateInput>
  }

  /**
   * DistributionCache delete
   */
  export type DistributionCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
    /**
     * Filter which DistributionCache to delete.
     */
    where: DistributionCacheWhereUniqueInput
  }

  /**
   * DistributionCache deleteMany
   */
  export type DistributionCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DistributionCaches to delete
     */
    where?: DistributionCacheWhereInput
  }

  /**
   * DistributionCache without action
   */
  export type DistributionCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistributionCache
     */
    select?: DistributionCacheSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brandId: 'brandId',
    objectives: 'objectives',
    budget: 'budget',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const RFPScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    partners: 'partners',
    status: 'status',
    requestedAt: 'requestedAt',
    responses: 'responses',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RFPScalarFieldEnum = (typeof RFPScalarFieldEnum)[keyof typeof RFPScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    type: 'type',
    status: 'status',
    companyInfo: 'companyInfo',
    contactInfo: 'contactInfo',
    apiCredentials: 'apiCredentials',
    targetingOptions: 'targetingOptions',
    measurementCapabilities: 'measurementCapabilities',
    onboardingStatus: 'onboardingStatus',
    onboardingSteps: 'onboardingSteps',
    pricingInfo: 'pricingInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const PartnerCapabilityScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    name: 'name',
    description: 'description',
    category: 'category',
    details: 'details',
    isActive: 'isActive',
    lastUpdated: 'lastUpdated',
    sourceType: 'sourceType',
    sourceData: 'sourceData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerCapabilityScalarFieldEnum = (typeof PartnerCapabilityScalarFieldEnum)[keyof typeof PartnerCapabilityScalarFieldEnum]


  export const CreativeSpecScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    format: 'format',
    dimensions: 'dimensions',
    fileType: 'fileType',
    maxFileSize: 'maxFileSize',
    requirements: 'requirements',
    examples: 'examples',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreativeSpecScalarFieldEnum = (typeof CreativeSpecScalarFieldEnum)[keyof typeof CreativeSpecScalarFieldEnum]


  export const PartnerHealthMetricScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    timestamp: 'timestamp',
    apiStatus: 'apiStatus',
    responseTime: 'responseTime',
    errorRate: 'errorRate',
    uptime: 'uptime',
    lastError: 'lastError',
    healthScore: 'healthScore',
    details: 'details'
  };

  export type PartnerHealthMetricScalarFieldEnum = (typeof PartnerHealthMetricScalarFieldEnum)[keyof typeof PartnerHealthMetricScalarFieldEnum]


  export const CampaignPartnerScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    partnerId: 'partnerId',
    status: 'status',
    budget: 'budget',
    targeting: 'targeting',
    creative: 'creative',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignPartnerScalarFieldEnum = (typeof CampaignPartnerScalarFieldEnum)[keyof typeof CampaignPartnerScalarFieldEnum]


  export const CapabilityMatrixScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    capabilities: 'capabilities',
    comparison: 'comparison',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CapabilityMatrixScalarFieldEnum = (typeof CapabilityMatrixScalarFieldEnum)[keyof typeof CapabilityMatrixScalarFieldEnum]


  export const DatasetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    sourceType: 'sourceType',
    updateFrequency: 'updateFrequency',
    schema: 'schema',
    metadata: 'metadata',
    qualityScore: 'qualityScore',
    status: 'status',
    tags: 'tags',
    sourceConfig: 'sourceConfig',
    lastIngestion: 'lastIngestion',
    nextIngestion: 'nextIngestion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatasetScalarFieldEnum = (typeof DatasetScalarFieldEnum)[keyof typeof DatasetScalarFieldEnum]


  export const DatasetVersionScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    version: 'version',
    description: 'description',
    schema: 'schema',
    metadata: 'metadata',
    size: 'size',
    recordCount: 'recordCount',
    checksums: 'checksums',
    location: 'location',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type DatasetVersionScalarFieldEnum = (typeof DatasetVersionScalarFieldEnum)[keyof typeof DatasetVersionScalarFieldEnum]


  export const DataQualityReportScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    reportDate: 'reportDate',
    overallScore: 'overallScore',
    completeness: 'completeness',
    accuracy: 'accuracy',
    consistency: 'consistency',
    validity: 'validity',
    freshness: 'freshness',
    metrics: 'metrics',
    anomalies: 'anomalies',
    issues: 'issues',
    recommendations: 'recommendations',
    processingTime: 'processingTime',
    recordsProcessed: 'recordsProcessed',
    createdAt: 'createdAt'
  };

  export type DataQualityReportScalarFieldEnum = (typeof DataQualityReportScalarFieldEnum)[keyof typeof DataQualityReportScalarFieldEnum]


  export const IngestionJobScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    jobType: 'jobType',
    status: 'status',
    config: 'config',
    schedule: 'schedule',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    logs: 'logs',
    recordsProcessed: 'recordsProcessed',
    recordsSucceeded: 'recordsSucceeded',
    recordsFailed: 'recordsFailed',
    metrics: 'metrics',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    nextRetryAt: 'nextRetryAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IngestionJobScalarFieldEnum = (typeof IngestionJobScalarFieldEnum)[keyof typeof IngestionJobScalarFieldEnum]


  export const DatasetLineageScalarFieldEnum: {
    id: 'id',
    upstreamId: 'upstreamId',
    downstreamId: 'downstreamId',
    transformationType: 'transformationType',
    transformationLogic: 'transformationLogic',
    confidence: 'confidence',
    createdAt: 'createdAt'
  };

  export type DatasetLineageScalarFieldEnum = (typeof DatasetLineageScalarFieldEnum)[keyof typeof DatasetLineageScalarFieldEnum]


  export const DataConnectorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    config: 'config',
    credentials: 'credentials',
    isActive: 'isActive',
    lastHealthCheck: 'lastHealthCheck',
    healthStatus: 'healthStatus',
    errorMessage: 'errorMessage',
    datasets: 'datasets',
    lastUsed: 'lastUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataConnectorScalarFieldEnum = (typeof DataConnectorScalarFieldEnum)[keyof typeof DataConnectorScalarFieldEnum]


  export const SchemaMappingScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    name: 'name',
    description: 'description',
    sourceSchema: 'sourceSchema',
    targetSchema: 'targetSchema',
    mappingRules: 'mappingRules',
    validationRules: 'validationRules',
    isActive: 'isActive',
    lastApplied: 'lastApplied',
    successRate: 'successRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchemaMappingScalarFieldEnum = (typeof SchemaMappingScalarFieldEnum)[keyof typeof SchemaMappingScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    actorId: 'actorId',
    changes: 'changes',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const DistributionSessionScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    currentScenario: 'currentScenario',
    presentationMode: 'presentationMode',
    lastSaved: 'lastSaved',
    hasUnsavedChanges: 'hasUnsavedChanges',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DistributionSessionScalarFieldEnum = (typeof DistributionSessionScalarFieldEnum)[keyof typeof DistributionSessionScalarFieldEnum]


  export const DistributionScenarioScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    name: 'name',
    description: 'description',
    isBaseline: 'isBaseline',
    parameters: 'parameters',
    projections: 'projections',
    lastModified: 'lastModified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DistributionScenarioScalarFieldEnum = (typeof DistributionScenarioScalarFieldEnum)[keyof typeof DistributionScenarioScalarFieldEnum]


  export const DistributionChangeScalarFieldEnum: {
    id: 'id',
    scenarioId: 'scenarioId',
    field: 'field',
    oldValue: 'oldValue',
    newValue: 'newValue',
    userId: 'userId',
    timestamp: 'timestamp'
  };

  export type DistributionChangeScalarFieldEnum = (typeof DistributionChangeScalarFieldEnum)[keyof typeof DistributionChangeScalarFieldEnum]


  export const DistributionCacheScalarFieldEnum: {
    id: 'id',
    cacheKey: 'cacheKey',
    data: 'data',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type DistributionCacheScalarFieldEnum = (typeof DistributionCacheScalarFieldEnum)[keyof typeof DistributionCacheScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PartnerType'
   */
  export type EnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType'>
    


  /**
   * Reference to a field of type 'PartnerType[]'
   */
  export type ListEnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType[]'>
    


  /**
   * Reference to a field of type 'PartnerStatus'
   */
  export type EnumPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerStatus'>
    


  /**
   * Reference to a field of type 'PartnerStatus[]'
   */
  export type ListEnumPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerStatus[]'>
    


  /**
   * Reference to a field of type 'OnboardingStatus'
   */
  export type EnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus'>
    


  /**
   * Reference to a field of type 'OnboardingStatus[]'
   */
  export type ListEnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CapabilitySourceType'
   */
  export type EnumCapabilitySourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CapabilitySourceType'>
    


  /**
   * Reference to a field of type 'CapabilitySourceType[]'
   */
  export type ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CapabilitySourceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ApiStatus'
   */
  export type EnumApiStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiStatus'>
    


  /**
   * Reference to a field of type 'ApiStatus[]'
   */
  export type ListEnumApiStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CampaignPartnerStatus'
   */
  export type EnumCampaignPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignPartnerStatus'>
    


  /**
   * Reference to a field of type 'CampaignPartnerStatus[]'
   */
  export type ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignPartnerStatus[]'>
    


  /**
   * Reference to a field of type 'DatasetCategory'
   */
  export type EnumDatasetCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetCategory'>
    


  /**
   * Reference to a field of type 'DatasetCategory[]'
   */
  export type ListEnumDatasetCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetCategory[]'>
    


  /**
   * Reference to a field of type 'DatasetSourceType'
   */
  export type EnumDatasetSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetSourceType'>
    


  /**
   * Reference to a field of type 'DatasetSourceType[]'
   */
  export type ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetSourceType[]'>
    


  /**
   * Reference to a field of type 'UpdateFrequency'
   */
  export type EnumUpdateFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UpdateFrequency'>
    


  /**
   * Reference to a field of type 'UpdateFrequency[]'
   */
  export type ListEnumUpdateFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UpdateFrequency[]'>
    


  /**
   * Reference to a field of type 'DatasetStatus'
   */
  export type EnumDatasetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetStatus'>
    


  /**
   * Reference to a field of type 'DatasetStatus[]'
   */
  export type ListEnumDatasetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'IngestionJobType'
   */
  export type EnumIngestionJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IngestionJobType'>
    


  /**
   * Reference to a field of type 'IngestionJobType[]'
   */
  export type ListEnumIngestionJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IngestionJobType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'DataConnectorType'
   */
  export type EnumDataConnectorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataConnectorType'>
    


  /**
   * Reference to a field of type 'DataConnectorType[]'
   */
  export type ListEnumDataConnectorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataConnectorType[]'>
    


  /**
   * Reference to a field of type 'ConnectorHealthStatus'
   */
  export type EnumConnectorHealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectorHealthStatus'>
    


  /**
   * Reference to a field of type 'ConnectorHealthStatus[]'
   */
  export type ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectorHealthStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    organizationId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    campaigns?: CampaignListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    distributionChanges?: DistributionChangeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    distributionChanges?: DistributionChangeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    organizationId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    campaigns?: CampaignListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    distributionChanges?: DistributionChangeListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    organizationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    brandId?: StringFilter<"Campaign"> | string
    objectives?: JsonFilter<"Campaign">
    budget?: JsonFilter<"Campaign">
    status?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    rfps?: RFPListRelationFilter
    partnerAssociations?: CampaignPartnerListRelationFilter
    distributionSession?: XOR<DistributionSessionNullableRelationFilter, DistributionSessionWhereInput> | null
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    objectives?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    rfps?: RFPOrderByRelationAggregateInput
    partnerAssociations?: CampaignPartnerOrderByRelationAggregateInput
    distributionSession?: DistributionSessionOrderByWithRelationInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    brandId?: StringFilter<"Campaign"> | string
    objectives?: JsonFilter<"Campaign">
    budget?: JsonFilter<"Campaign">
    status?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    rfps?: RFPListRelationFilter
    partnerAssociations?: CampaignPartnerListRelationFilter
    distributionSession?: XOR<DistributionSessionNullableRelationFilter, DistributionSessionWhereInput> | null
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    objectives?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    brandId?: StringWithAggregatesFilter<"Campaign"> | string
    objectives?: JsonWithAggregatesFilter<"Campaign">
    budget?: JsonWithAggregatesFilter<"Campaign">
    status?: StringWithAggregatesFilter<"Campaign"> | string
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type RFPWhereInput = {
    AND?: RFPWhereInput | RFPWhereInput[]
    OR?: RFPWhereInput[]
    NOT?: RFPWhereInput | RFPWhereInput[]
    id?: StringFilter<"RFP"> | string
    campaignId?: StringFilter<"RFP"> | string
    partners?: JsonFilter<"RFP">
    status?: StringFilter<"RFP"> | string
    requestedAt?: DateTimeFilter<"RFP"> | Date | string
    responses?: JsonFilter<"RFP">
    createdAt?: DateTimeFilter<"RFP"> | Date | string
    updatedAt?: DateTimeFilter<"RFP"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type RFPOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partners?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type RFPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RFPWhereInput | RFPWhereInput[]
    OR?: RFPWhereInput[]
    NOT?: RFPWhereInput | RFPWhereInput[]
    campaignId?: StringFilter<"RFP"> | string
    partners?: JsonFilter<"RFP">
    status?: StringFilter<"RFP"> | string
    requestedAt?: DateTimeFilter<"RFP"> | Date | string
    responses?: JsonFilter<"RFP">
    createdAt?: DateTimeFilter<"RFP"> | Date | string
    updatedAt?: DateTimeFilter<"RFP"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type RFPOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partners?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RFPCountOrderByAggregateInput
    _max?: RFPMaxOrderByAggregateInput
    _min?: RFPMinOrderByAggregateInput
  }

  export type RFPScalarWhereWithAggregatesInput = {
    AND?: RFPScalarWhereWithAggregatesInput | RFPScalarWhereWithAggregatesInput[]
    OR?: RFPScalarWhereWithAggregatesInput[]
    NOT?: RFPScalarWhereWithAggregatesInput | RFPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RFP"> | string
    campaignId?: StringWithAggregatesFilter<"RFP"> | string
    partners?: JsonWithAggregatesFilter<"RFP">
    status?: StringWithAggregatesFilter<"RFP"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"RFP"> | Date | string
    responses?: JsonWithAggregatesFilter<"RFP">
    createdAt?: DateTimeWithAggregatesFilter<"RFP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RFP"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    displayName?: StringFilter<"Partner"> | string
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    status?: EnumPartnerStatusFilter<"Partner"> | $Enums.PartnerStatus
    companyInfo?: JsonFilter<"Partner">
    contactInfo?: JsonFilter<"Partner">
    apiCredentials?: JsonNullableFilter<"Partner">
    targetingOptions?: JsonFilter<"Partner">
    measurementCapabilities?: JsonFilter<"Partner">
    onboardingStatus?: EnumOnboardingStatusFilter<"Partner"> | $Enums.OnboardingStatus
    onboardingSteps?: JsonFilter<"Partner">
    pricingInfo?: JsonFilter<"Partner">
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    capabilities?: PartnerCapabilityListRelationFilter
    creativeSpecs?: CreativeSpecListRelationFilter
    healthMetrics?: PartnerHealthMetricListRelationFilter
    campaignAssociations?: CampaignPartnerListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    companyInfo?: SortOrder
    contactInfo?: SortOrder
    apiCredentials?: SortOrderInput | SortOrder
    targetingOptions?: SortOrder
    measurementCapabilities?: SortOrder
    onboardingStatus?: SortOrder
    onboardingSteps?: SortOrder
    pricingInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capabilities?: PartnerCapabilityOrderByRelationAggregateInput
    creativeSpecs?: CreativeSpecOrderByRelationAggregateInput
    healthMetrics?: PartnerHealthMetricOrderByRelationAggregateInput
    campaignAssociations?: CampaignPartnerOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    name?: StringFilter<"Partner"> | string
    displayName?: StringFilter<"Partner"> | string
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    status?: EnumPartnerStatusFilter<"Partner"> | $Enums.PartnerStatus
    companyInfo?: JsonFilter<"Partner">
    contactInfo?: JsonFilter<"Partner">
    apiCredentials?: JsonNullableFilter<"Partner">
    targetingOptions?: JsonFilter<"Partner">
    measurementCapabilities?: JsonFilter<"Partner">
    onboardingStatus?: EnumOnboardingStatusFilter<"Partner"> | $Enums.OnboardingStatus
    onboardingSteps?: JsonFilter<"Partner">
    pricingInfo?: JsonFilter<"Partner">
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    capabilities?: PartnerCapabilityListRelationFilter
    creativeSpecs?: CreativeSpecListRelationFilter
    healthMetrics?: PartnerHealthMetricListRelationFilter
    campaignAssociations?: CampaignPartnerListRelationFilter
  }, "id">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    companyInfo?: SortOrder
    contactInfo?: SortOrder
    apiCredentials?: SortOrderInput | SortOrder
    targetingOptions?: SortOrder
    measurementCapabilities?: SortOrder
    onboardingStatus?: SortOrder
    onboardingSteps?: SortOrder
    pricingInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    displayName?: StringWithAggregatesFilter<"Partner"> | string
    type?: EnumPartnerTypeWithAggregatesFilter<"Partner"> | $Enums.PartnerType
    status?: EnumPartnerStatusWithAggregatesFilter<"Partner"> | $Enums.PartnerStatus
    companyInfo?: JsonWithAggregatesFilter<"Partner">
    contactInfo?: JsonWithAggregatesFilter<"Partner">
    apiCredentials?: JsonNullableWithAggregatesFilter<"Partner">
    targetingOptions?: JsonWithAggregatesFilter<"Partner">
    measurementCapabilities?: JsonWithAggregatesFilter<"Partner">
    onboardingStatus?: EnumOnboardingStatusWithAggregatesFilter<"Partner"> | $Enums.OnboardingStatus
    onboardingSteps?: JsonWithAggregatesFilter<"Partner">
    pricingInfo?: JsonWithAggregatesFilter<"Partner">
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
  }

  export type PartnerCapabilityWhereInput = {
    AND?: PartnerCapabilityWhereInput | PartnerCapabilityWhereInput[]
    OR?: PartnerCapabilityWhereInput[]
    NOT?: PartnerCapabilityWhereInput | PartnerCapabilityWhereInput[]
    id?: StringFilter<"PartnerCapability"> | string
    partnerId?: StringFilter<"PartnerCapability"> | string
    name?: StringFilter<"PartnerCapability"> | string
    description?: StringNullableFilter<"PartnerCapability"> | string | null
    category?: StringFilter<"PartnerCapability"> | string
    details?: JsonFilter<"PartnerCapability">
    isActive?: BoolFilter<"PartnerCapability"> | boolean
    lastUpdated?: DateTimeFilter<"PartnerCapability"> | Date | string
    sourceType?: EnumCapabilitySourceTypeFilter<"PartnerCapability"> | $Enums.CapabilitySourceType
    sourceData?: JsonNullableFilter<"PartnerCapability">
    createdAt?: DateTimeFilter<"PartnerCapability"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerCapability"> | Date | string
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }

  export type PartnerCapabilityOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    details?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    sourceType?: SortOrder
    sourceData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partner?: PartnerOrderByWithRelationInput
  }

  export type PartnerCapabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    partnerId_name?: PartnerCapabilityPartnerIdNameCompoundUniqueInput
    AND?: PartnerCapabilityWhereInput | PartnerCapabilityWhereInput[]
    OR?: PartnerCapabilityWhereInput[]
    NOT?: PartnerCapabilityWhereInput | PartnerCapabilityWhereInput[]
    partnerId?: StringFilter<"PartnerCapability"> | string
    name?: StringFilter<"PartnerCapability"> | string
    description?: StringNullableFilter<"PartnerCapability"> | string | null
    category?: StringFilter<"PartnerCapability"> | string
    details?: JsonFilter<"PartnerCapability">
    isActive?: BoolFilter<"PartnerCapability"> | boolean
    lastUpdated?: DateTimeFilter<"PartnerCapability"> | Date | string
    sourceType?: EnumCapabilitySourceTypeFilter<"PartnerCapability"> | $Enums.CapabilitySourceType
    sourceData?: JsonNullableFilter<"PartnerCapability">
    createdAt?: DateTimeFilter<"PartnerCapability"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerCapability"> | Date | string
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }, "id" | "partnerId_name">

  export type PartnerCapabilityOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    details?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    sourceType?: SortOrder
    sourceData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerCapabilityCountOrderByAggregateInput
    _max?: PartnerCapabilityMaxOrderByAggregateInput
    _min?: PartnerCapabilityMinOrderByAggregateInput
  }

  export type PartnerCapabilityScalarWhereWithAggregatesInput = {
    AND?: PartnerCapabilityScalarWhereWithAggregatesInput | PartnerCapabilityScalarWhereWithAggregatesInput[]
    OR?: PartnerCapabilityScalarWhereWithAggregatesInput[]
    NOT?: PartnerCapabilityScalarWhereWithAggregatesInput | PartnerCapabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerCapability"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerCapability"> | string
    name?: StringWithAggregatesFilter<"PartnerCapability"> | string
    description?: StringNullableWithAggregatesFilter<"PartnerCapability"> | string | null
    category?: StringWithAggregatesFilter<"PartnerCapability"> | string
    details?: JsonWithAggregatesFilter<"PartnerCapability">
    isActive?: BoolWithAggregatesFilter<"PartnerCapability"> | boolean
    lastUpdated?: DateTimeWithAggregatesFilter<"PartnerCapability"> | Date | string
    sourceType?: EnumCapabilitySourceTypeWithAggregatesFilter<"PartnerCapability"> | $Enums.CapabilitySourceType
    sourceData?: JsonNullableWithAggregatesFilter<"PartnerCapability">
    createdAt?: DateTimeWithAggregatesFilter<"PartnerCapability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerCapability"> | Date | string
  }

  export type CreativeSpecWhereInput = {
    AND?: CreativeSpecWhereInput | CreativeSpecWhereInput[]
    OR?: CreativeSpecWhereInput[]
    NOT?: CreativeSpecWhereInput | CreativeSpecWhereInput[]
    id?: StringFilter<"CreativeSpec"> | string
    partnerId?: StringFilter<"CreativeSpec"> | string
    format?: StringFilter<"CreativeSpec"> | string
    dimensions?: JsonFilter<"CreativeSpec">
    fileType?: StringFilter<"CreativeSpec"> | string
    maxFileSize?: IntFilter<"CreativeSpec"> | number
    requirements?: JsonFilter<"CreativeSpec">
    examples?: JsonNullableFilter<"CreativeSpec">
    isActive?: BoolFilter<"CreativeSpec"> | boolean
    createdAt?: DateTimeFilter<"CreativeSpec"> | Date | string
    updatedAt?: DateTimeFilter<"CreativeSpec"> | Date | string
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }

  export type CreativeSpecOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    format?: SortOrder
    dimensions?: SortOrder
    fileType?: SortOrder
    maxFileSize?: SortOrder
    requirements?: SortOrder
    examples?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partner?: PartnerOrderByWithRelationInput
  }

  export type CreativeSpecWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreativeSpecWhereInput | CreativeSpecWhereInput[]
    OR?: CreativeSpecWhereInput[]
    NOT?: CreativeSpecWhereInput | CreativeSpecWhereInput[]
    partnerId?: StringFilter<"CreativeSpec"> | string
    format?: StringFilter<"CreativeSpec"> | string
    dimensions?: JsonFilter<"CreativeSpec">
    fileType?: StringFilter<"CreativeSpec"> | string
    maxFileSize?: IntFilter<"CreativeSpec"> | number
    requirements?: JsonFilter<"CreativeSpec">
    examples?: JsonNullableFilter<"CreativeSpec">
    isActive?: BoolFilter<"CreativeSpec"> | boolean
    createdAt?: DateTimeFilter<"CreativeSpec"> | Date | string
    updatedAt?: DateTimeFilter<"CreativeSpec"> | Date | string
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }, "id">

  export type CreativeSpecOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    format?: SortOrder
    dimensions?: SortOrder
    fileType?: SortOrder
    maxFileSize?: SortOrder
    requirements?: SortOrder
    examples?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreativeSpecCountOrderByAggregateInput
    _avg?: CreativeSpecAvgOrderByAggregateInput
    _max?: CreativeSpecMaxOrderByAggregateInput
    _min?: CreativeSpecMinOrderByAggregateInput
    _sum?: CreativeSpecSumOrderByAggregateInput
  }

  export type CreativeSpecScalarWhereWithAggregatesInput = {
    AND?: CreativeSpecScalarWhereWithAggregatesInput | CreativeSpecScalarWhereWithAggregatesInput[]
    OR?: CreativeSpecScalarWhereWithAggregatesInput[]
    NOT?: CreativeSpecScalarWhereWithAggregatesInput | CreativeSpecScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreativeSpec"> | string
    partnerId?: StringWithAggregatesFilter<"CreativeSpec"> | string
    format?: StringWithAggregatesFilter<"CreativeSpec"> | string
    dimensions?: JsonWithAggregatesFilter<"CreativeSpec">
    fileType?: StringWithAggregatesFilter<"CreativeSpec"> | string
    maxFileSize?: IntWithAggregatesFilter<"CreativeSpec"> | number
    requirements?: JsonWithAggregatesFilter<"CreativeSpec">
    examples?: JsonNullableWithAggregatesFilter<"CreativeSpec">
    isActive?: BoolWithAggregatesFilter<"CreativeSpec"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CreativeSpec"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreativeSpec"> | Date | string
  }

  export type PartnerHealthMetricWhereInput = {
    AND?: PartnerHealthMetricWhereInput | PartnerHealthMetricWhereInput[]
    OR?: PartnerHealthMetricWhereInput[]
    NOT?: PartnerHealthMetricWhereInput | PartnerHealthMetricWhereInput[]
    id?: StringFilter<"PartnerHealthMetric"> | string
    partnerId?: StringFilter<"PartnerHealthMetric"> | string
    timestamp?: DateTimeFilter<"PartnerHealthMetric"> | Date | string
    apiStatus?: EnumApiStatusFilter<"PartnerHealthMetric"> | $Enums.ApiStatus
    responseTime?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    errorRate?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    uptime?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    lastError?: StringNullableFilter<"PartnerHealthMetric"> | string | null
    healthScore?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    details?: JsonNullableFilter<"PartnerHealthMetric">
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }

  export type PartnerHealthMetricOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    timestamp?: SortOrder
    apiStatus?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    healthScore?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    partner?: PartnerOrderByWithRelationInput
  }

  export type PartnerHealthMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerHealthMetricWhereInput | PartnerHealthMetricWhereInput[]
    OR?: PartnerHealthMetricWhereInput[]
    NOT?: PartnerHealthMetricWhereInput | PartnerHealthMetricWhereInput[]
    partnerId?: StringFilter<"PartnerHealthMetric"> | string
    timestamp?: DateTimeFilter<"PartnerHealthMetric"> | Date | string
    apiStatus?: EnumApiStatusFilter<"PartnerHealthMetric"> | $Enums.ApiStatus
    responseTime?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    errorRate?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    uptime?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    lastError?: StringNullableFilter<"PartnerHealthMetric"> | string | null
    healthScore?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    details?: JsonNullableFilter<"PartnerHealthMetric">
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }, "id">

  export type PartnerHealthMetricOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    timestamp?: SortOrder
    apiStatus?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    healthScore?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    _count?: PartnerHealthMetricCountOrderByAggregateInput
    _avg?: PartnerHealthMetricAvgOrderByAggregateInput
    _max?: PartnerHealthMetricMaxOrderByAggregateInput
    _min?: PartnerHealthMetricMinOrderByAggregateInput
    _sum?: PartnerHealthMetricSumOrderByAggregateInput
  }

  export type PartnerHealthMetricScalarWhereWithAggregatesInput = {
    AND?: PartnerHealthMetricScalarWhereWithAggregatesInput | PartnerHealthMetricScalarWhereWithAggregatesInput[]
    OR?: PartnerHealthMetricScalarWhereWithAggregatesInput[]
    NOT?: PartnerHealthMetricScalarWhereWithAggregatesInput | PartnerHealthMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerHealthMetric"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerHealthMetric"> | string
    timestamp?: DateTimeWithAggregatesFilter<"PartnerHealthMetric"> | Date | string
    apiStatus?: EnumApiStatusWithAggregatesFilter<"PartnerHealthMetric"> | $Enums.ApiStatus
    responseTime?: FloatNullableWithAggregatesFilter<"PartnerHealthMetric"> | number | null
    errorRate?: FloatNullableWithAggregatesFilter<"PartnerHealthMetric"> | number | null
    uptime?: FloatNullableWithAggregatesFilter<"PartnerHealthMetric"> | number | null
    lastError?: StringNullableWithAggregatesFilter<"PartnerHealthMetric"> | string | null
    healthScore?: FloatNullableWithAggregatesFilter<"PartnerHealthMetric"> | number | null
    details?: JsonNullableWithAggregatesFilter<"PartnerHealthMetric">
  }

  export type CampaignPartnerWhereInput = {
    AND?: CampaignPartnerWhereInput | CampaignPartnerWhereInput[]
    OR?: CampaignPartnerWhereInput[]
    NOT?: CampaignPartnerWhereInput | CampaignPartnerWhereInput[]
    id?: StringFilter<"CampaignPartner"> | string
    campaignId?: StringFilter<"CampaignPartner"> | string
    partnerId?: StringFilter<"CampaignPartner"> | string
    status?: EnumCampaignPartnerStatusFilter<"CampaignPartner"> | $Enums.CampaignPartnerStatus
    budget?: JsonNullableFilter<"CampaignPartner">
    targeting?: JsonNullableFilter<"CampaignPartner">
    creative?: JsonNullableFilter<"CampaignPartner">
    createdAt?: DateTimeFilter<"CampaignPartner"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignPartner"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }

  export type CampaignPartnerOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    targeting?: SortOrderInput | SortOrder
    creative?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
  }

  export type CampaignPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_partnerId?: CampaignPartnerCampaignIdPartnerIdCompoundUniqueInput
    AND?: CampaignPartnerWhereInput | CampaignPartnerWhereInput[]
    OR?: CampaignPartnerWhereInput[]
    NOT?: CampaignPartnerWhereInput | CampaignPartnerWhereInput[]
    campaignId?: StringFilter<"CampaignPartner"> | string
    partnerId?: StringFilter<"CampaignPartner"> | string
    status?: EnumCampaignPartnerStatusFilter<"CampaignPartner"> | $Enums.CampaignPartnerStatus
    budget?: JsonNullableFilter<"CampaignPartner">
    targeting?: JsonNullableFilter<"CampaignPartner">
    creative?: JsonNullableFilter<"CampaignPartner">
    createdAt?: DateTimeFilter<"CampaignPartner"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignPartner"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    partner?: XOR<PartnerRelationFilter, PartnerWhereInput>
  }, "id" | "campaignId_partnerId">

  export type CampaignPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    targeting?: SortOrderInput | SortOrder
    creative?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignPartnerCountOrderByAggregateInput
    _max?: CampaignPartnerMaxOrderByAggregateInput
    _min?: CampaignPartnerMinOrderByAggregateInput
  }

  export type CampaignPartnerScalarWhereWithAggregatesInput = {
    AND?: CampaignPartnerScalarWhereWithAggregatesInput | CampaignPartnerScalarWhereWithAggregatesInput[]
    OR?: CampaignPartnerScalarWhereWithAggregatesInput[]
    NOT?: CampaignPartnerScalarWhereWithAggregatesInput | CampaignPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignPartner"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignPartner"> | string
    partnerId?: StringWithAggregatesFilter<"CampaignPartner"> | string
    status?: EnumCampaignPartnerStatusWithAggregatesFilter<"CampaignPartner"> | $Enums.CampaignPartnerStatus
    budget?: JsonNullableWithAggregatesFilter<"CampaignPartner">
    targeting?: JsonNullableWithAggregatesFilter<"CampaignPartner">
    creative?: JsonNullableWithAggregatesFilter<"CampaignPartner">
    createdAt?: DateTimeWithAggregatesFilter<"CampaignPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignPartner"> | Date | string
  }

  export type CapabilityMatrixWhereInput = {
    AND?: CapabilityMatrixWhereInput | CapabilityMatrixWhereInput[]
    OR?: CapabilityMatrixWhereInput[]
    NOT?: CapabilityMatrixWhereInput | CapabilityMatrixWhereInput[]
    id?: StringFilter<"CapabilityMatrix"> | string
    name?: StringFilter<"CapabilityMatrix"> | string
    description?: StringNullableFilter<"CapabilityMatrix"> | string | null
    capabilities?: JsonFilter<"CapabilityMatrix">
    comparison?: JsonFilter<"CapabilityMatrix">
    lastUpdated?: DateTimeFilter<"CapabilityMatrix"> | Date | string
    createdAt?: DateTimeFilter<"CapabilityMatrix"> | Date | string
    updatedAt?: DateTimeFilter<"CapabilityMatrix"> | Date | string
  }

  export type CapabilityMatrixOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    comparison?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityMatrixWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CapabilityMatrixWhereInput | CapabilityMatrixWhereInput[]
    OR?: CapabilityMatrixWhereInput[]
    NOT?: CapabilityMatrixWhereInput | CapabilityMatrixWhereInput[]
    name?: StringFilter<"CapabilityMatrix"> | string
    description?: StringNullableFilter<"CapabilityMatrix"> | string | null
    capabilities?: JsonFilter<"CapabilityMatrix">
    comparison?: JsonFilter<"CapabilityMatrix">
    lastUpdated?: DateTimeFilter<"CapabilityMatrix"> | Date | string
    createdAt?: DateTimeFilter<"CapabilityMatrix"> | Date | string
    updatedAt?: DateTimeFilter<"CapabilityMatrix"> | Date | string
  }, "id">

  export type CapabilityMatrixOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    comparison?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CapabilityMatrixCountOrderByAggregateInput
    _max?: CapabilityMatrixMaxOrderByAggregateInput
    _min?: CapabilityMatrixMinOrderByAggregateInput
  }

  export type CapabilityMatrixScalarWhereWithAggregatesInput = {
    AND?: CapabilityMatrixScalarWhereWithAggregatesInput | CapabilityMatrixScalarWhereWithAggregatesInput[]
    OR?: CapabilityMatrixScalarWhereWithAggregatesInput[]
    NOT?: CapabilityMatrixScalarWhereWithAggregatesInput | CapabilityMatrixScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CapabilityMatrix"> | string
    name?: StringWithAggregatesFilter<"CapabilityMatrix"> | string
    description?: StringNullableWithAggregatesFilter<"CapabilityMatrix"> | string | null
    capabilities?: JsonWithAggregatesFilter<"CapabilityMatrix">
    comparison?: JsonWithAggregatesFilter<"CapabilityMatrix">
    lastUpdated?: DateTimeWithAggregatesFilter<"CapabilityMatrix"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CapabilityMatrix"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CapabilityMatrix"> | Date | string
  }

  export type DatasetWhereInput = {
    AND?: DatasetWhereInput | DatasetWhereInput[]
    OR?: DatasetWhereInput[]
    NOT?: DatasetWhereInput | DatasetWhereInput[]
    id?: StringFilter<"Dataset"> | string
    name?: StringFilter<"Dataset"> | string
    displayName?: StringFilter<"Dataset"> | string
    description?: StringNullableFilter<"Dataset"> | string | null
    category?: EnumDatasetCategoryFilter<"Dataset"> | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFilter<"Dataset"> | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFilter<"Dataset"> | $Enums.UpdateFrequency
    schema?: JsonFilter<"Dataset">
    metadata?: JsonFilter<"Dataset">
    qualityScore?: FloatNullableFilter<"Dataset"> | number | null
    status?: EnumDatasetStatusFilter<"Dataset"> | $Enums.DatasetStatus
    tags?: StringNullableListFilter<"Dataset">
    sourceConfig?: JsonFilter<"Dataset">
    lastIngestion?: DateTimeNullableFilter<"Dataset"> | Date | string | null
    nextIngestion?: DateTimeNullableFilter<"Dataset"> | Date | string | null
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
    versions?: DatasetVersionListRelationFilter
    qualityReports?: DataQualityReportListRelationFilter
    ingestionJobs?: IngestionJobListRelationFilter
    lineageUpstream?: DatasetLineageListRelationFilter
    lineageDownstream?: DatasetLineageListRelationFilter
  }

  export type DatasetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    sourceType?: SortOrder
    updateFrequency?: SortOrder
    schema?: SortOrder
    metadata?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    status?: SortOrder
    tags?: SortOrder
    sourceConfig?: SortOrder
    lastIngestion?: SortOrderInput | SortOrder
    nextIngestion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: DatasetVersionOrderByRelationAggregateInput
    qualityReports?: DataQualityReportOrderByRelationAggregateInput
    ingestionJobs?: IngestionJobOrderByRelationAggregateInput
    lineageUpstream?: DatasetLineageOrderByRelationAggregateInput
    lineageDownstream?: DatasetLineageOrderByRelationAggregateInput
  }

  export type DatasetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DatasetWhereInput | DatasetWhereInput[]
    OR?: DatasetWhereInput[]
    NOT?: DatasetWhereInput | DatasetWhereInput[]
    displayName?: StringFilter<"Dataset"> | string
    description?: StringNullableFilter<"Dataset"> | string | null
    category?: EnumDatasetCategoryFilter<"Dataset"> | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFilter<"Dataset"> | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFilter<"Dataset"> | $Enums.UpdateFrequency
    schema?: JsonFilter<"Dataset">
    metadata?: JsonFilter<"Dataset">
    qualityScore?: FloatNullableFilter<"Dataset"> | number | null
    status?: EnumDatasetStatusFilter<"Dataset"> | $Enums.DatasetStatus
    tags?: StringNullableListFilter<"Dataset">
    sourceConfig?: JsonFilter<"Dataset">
    lastIngestion?: DateTimeNullableFilter<"Dataset"> | Date | string | null
    nextIngestion?: DateTimeNullableFilter<"Dataset"> | Date | string | null
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
    versions?: DatasetVersionListRelationFilter
    qualityReports?: DataQualityReportListRelationFilter
    ingestionJobs?: IngestionJobListRelationFilter
    lineageUpstream?: DatasetLineageListRelationFilter
    lineageDownstream?: DatasetLineageListRelationFilter
  }, "id" | "name">

  export type DatasetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    sourceType?: SortOrder
    updateFrequency?: SortOrder
    schema?: SortOrder
    metadata?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    status?: SortOrder
    tags?: SortOrder
    sourceConfig?: SortOrder
    lastIngestion?: SortOrderInput | SortOrder
    nextIngestion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatasetCountOrderByAggregateInput
    _avg?: DatasetAvgOrderByAggregateInput
    _max?: DatasetMaxOrderByAggregateInput
    _min?: DatasetMinOrderByAggregateInput
    _sum?: DatasetSumOrderByAggregateInput
  }

  export type DatasetScalarWhereWithAggregatesInput = {
    AND?: DatasetScalarWhereWithAggregatesInput | DatasetScalarWhereWithAggregatesInput[]
    OR?: DatasetScalarWhereWithAggregatesInput[]
    NOT?: DatasetScalarWhereWithAggregatesInput | DatasetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dataset"> | string
    name?: StringWithAggregatesFilter<"Dataset"> | string
    displayName?: StringWithAggregatesFilter<"Dataset"> | string
    description?: StringNullableWithAggregatesFilter<"Dataset"> | string | null
    category?: EnumDatasetCategoryWithAggregatesFilter<"Dataset"> | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeWithAggregatesFilter<"Dataset"> | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyWithAggregatesFilter<"Dataset"> | $Enums.UpdateFrequency
    schema?: JsonWithAggregatesFilter<"Dataset">
    metadata?: JsonWithAggregatesFilter<"Dataset">
    qualityScore?: FloatNullableWithAggregatesFilter<"Dataset"> | number | null
    status?: EnumDatasetStatusWithAggregatesFilter<"Dataset"> | $Enums.DatasetStatus
    tags?: StringNullableListFilter<"Dataset">
    sourceConfig?: JsonWithAggregatesFilter<"Dataset">
    lastIngestion?: DateTimeNullableWithAggregatesFilter<"Dataset"> | Date | string | null
    nextIngestion?: DateTimeNullableWithAggregatesFilter<"Dataset"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
  }

  export type DatasetVersionWhereInput = {
    AND?: DatasetVersionWhereInput | DatasetVersionWhereInput[]
    OR?: DatasetVersionWhereInput[]
    NOT?: DatasetVersionWhereInput | DatasetVersionWhereInput[]
    id?: StringFilter<"DatasetVersion"> | string
    datasetId?: StringFilter<"DatasetVersion"> | string
    version?: StringFilter<"DatasetVersion"> | string
    description?: StringNullableFilter<"DatasetVersion"> | string | null
    schema?: JsonFilter<"DatasetVersion">
    metadata?: JsonFilter<"DatasetVersion">
    size?: BigIntNullableFilter<"DatasetVersion"> | bigint | number | null
    recordCount?: BigIntNullableFilter<"DatasetVersion"> | bigint | number | null
    checksums?: JsonFilter<"DatasetVersion">
    location?: StringFilter<"DatasetVersion"> | string
    isActive?: BoolFilter<"DatasetVersion"> | boolean
    createdAt?: DateTimeFilter<"DatasetVersion"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }

  export type DatasetVersionOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    schema?: SortOrder
    metadata?: SortOrder
    size?: SortOrderInput | SortOrder
    recordCount?: SortOrderInput | SortOrder
    checksums?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    dataset?: DatasetOrderByWithRelationInput
  }

  export type DatasetVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    datasetId_version?: DatasetVersionDatasetIdVersionCompoundUniqueInput
    AND?: DatasetVersionWhereInput | DatasetVersionWhereInput[]
    OR?: DatasetVersionWhereInput[]
    NOT?: DatasetVersionWhereInput | DatasetVersionWhereInput[]
    datasetId?: StringFilter<"DatasetVersion"> | string
    version?: StringFilter<"DatasetVersion"> | string
    description?: StringNullableFilter<"DatasetVersion"> | string | null
    schema?: JsonFilter<"DatasetVersion">
    metadata?: JsonFilter<"DatasetVersion">
    size?: BigIntNullableFilter<"DatasetVersion"> | bigint | number | null
    recordCount?: BigIntNullableFilter<"DatasetVersion"> | bigint | number | null
    checksums?: JsonFilter<"DatasetVersion">
    location?: StringFilter<"DatasetVersion"> | string
    isActive?: BoolFilter<"DatasetVersion"> | boolean
    createdAt?: DateTimeFilter<"DatasetVersion"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }, "id" | "datasetId_version">

  export type DatasetVersionOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    schema?: SortOrder
    metadata?: SortOrder
    size?: SortOrderInput | SortOrder
    recordCount?: SortOrderInput | SortOrder
    checksums?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: DatasetVersionCountOrderByAggregateInput
    _avg?: DatasetVersionAvgOrderByAggregateInput
    _max?: DatasetVersionMaxOrderByAggregateInput
    _min?: DatasetVersionMinOrderByAggregateInput
    _sum?: DatasetVersionSumOrderByAggregateInput
  }

  export type DatasetVersionScalarWhereWithAggregatesInput = {
    AND?: DatasetVersionScalarWhereWithAggregatesInput | DatasetVersionScalarWhereWithAggregatesInput[]
    OR?: DatasetVersionScalarWhereWithAggregatesInput[]
    NOT?: DatasetVersionScalarWhereWithAggregatesInput | DatasetVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatasetVersion"> | string
    datasetId?: StringWithAggregatesFilter<"DatasetVersion"> | string
    version?: StringWithAggregatesFilter<"DatasetVersion"> | string
    description?: StringNullableWithAggregatesFilter<"DatasetVersion"> | string | null
    schema?: JsonWithAggregatesFilter<"DatasetVersion">
    metadata?: JsonWithAggregatesFilter<"DatasetVersion">
    size?: BigIntNullableWithAggregatesFilter<"DatasetVersion"> | bigint | number | null
    recordCount?: BigIntNullableWithAggregatesFilter<"DatasetVersion"> | bigint | number | null
    checksums?: JsonWithAggregatesFilter<"DatasetVersion">
    location?: StringWithAggregatesFilter<"DatasetVersion"> | string
    isActive?: BoolWithAggregatesFilter<"DatasetVersion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DatasetVersion"> | Date | string
  }

  export type DataQualityReportWhereInput = {
    AND?: DataQualityReportWhereInput | DataQualityReportWhereInput[]
    OR?: DataQualityReportWhereInput[]
    NOT?: DataQualityReportWhereInput | DataQualityReportWhereInput[]
    id?: StringFilter<"DataQualityReport"> | string
    datasetId?: StringFilter<"DataQualityReport"> | string
    reportDate?: DateTimeFilter<"DataQualityReport"> | Date | string
    overallScore?: FloatFilter<"DataQualityReport"> | number
    completeness?: FloatFilter<"DataQualityReport"> | number
    accuracy?: FloatFilter<"DataQualityReport"> | number
    consistency?: FloatFilter<"DataQualityReport"> | number
    validity?: FloatFilter<"DataQualityReport"> | number
    freshness?: FloatFilter<"DataQualityReport"> | number
    metrics?: JsonFilter<"DataQualityReport">
    anomalies?: JsonFilter<"DataQualityReport">
    issues?: JsonFilter<"DataQualityReport">
    recommendations?: JsonFilter<"DataQualityReport">
    processingTime?: IntNullableFilter<"DataQualityReport"> | number | null
    recordsProcessed?: BigIntNullableFilter<"DataQualityReport"> | bigint | number | null
    createdAt?: DateTimeFilter<"DataQualityReport"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }

  export type DataQualityReportOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    reportDate?: SortOrder
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    metrics?: SortOrder
    anomalies?: SortOrder
    issues?: SortOrder
    recommendations?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    recordsProcessed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    dataset?: DatasetOrderByWithRelationInput
  }

  export type DataQualityReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataQualityReportWhereInput | DataQualityReportWhereInput[]
    OR?: DataQualityReportWhereInput[]
    NOT?: DataQualityReportWhereInput | DataQualityReportWhereInput[]
    datasetId?: StringFilter<"DataQualityReport"> | string
    reportDate?: DateTimeFilter<"DataQualityReport"> | Date | string
    overallScore?: FloatFilter<"DataQualityReport"> | number
    completeness?: FloatFilter<"DataQualityReport"> | number
    accuracy?: FloatFilter<"DataQualityReport"> | number
    consistency?: FloatFilter<"DataQualityReport"> | number
    validity?: FloatFilter<"DataQualityReport"> | number
    freshness?: FloatFilter<"DataQualityReport"> | number
    metrics?: JsonFilter<"DataQualityReport">
    anomalies?: JsonFilter<"DataQualityReport">
    issues?: JsonFilter<"DataQualityReport">
    recommendations?: JsonFilter<"DataQualityReport">
    processingTime?: IntNullableFilter<"DataQualityReport"> | number | null
    recordsProcessed?: BigIntNullableFilter<"DataQualityReport"> | bigint | number | null
    createdAt?: DateTimeFilter<"DataQualityReport"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }, "id">

  export type DataQualityReportOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    reportDate?: SortOrder
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    metrics?: SortOrder
    anomalies?: SortOrder
    issues?: SortOrder
    recommendations?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    recordsProcessed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DataQualityReportCountOrderByAggregateInput
    _avg?: DataQualityReportAvgOrderByAggregateInput
    _max?: DataQualityReportMaxOrderByAggregateInput
    _min?: DataQualityReportMinOrderByAggregateInput
    _sum?: DataQualityReportSumOrderByAggregateInput
  }

  export type DataQualityReportScalarWhereWithAggregatesInput = {
    AND?: DataQualityReportScalarWhereWithAggregatesInput | DataQualityReportScalarWhereWithAggregatesInput[]
    OR?: DataQualityReportScalarWhereWithAggregatesInput[]
    NOT?: DataQualityReportScalarWhereWithAggregatesInput | DataQualityReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataQualityReport"> | string
    datasetId?: StringWithAggregatesFilter<"DataQualityReport"> | string
    reportDate?: DateTimeWithAggregatesFilter<"DataQualityReport"> | Date | string
    overallScore?: FloatWithAggregatesFilter<"DataQualityReport"> | number
    completeness?: FloatWithAggregatesFilter<"DataQualityReport"> | number
    accuracy?: FloatWithAggregatesFilter<"DataQualityReport"> | number
    consistency?: FloatWithAggregatesFilter<"DataQualityReport"> | number
    validity?: FloatWithAggregatesFilter<"DataQualityReport"> | number
    freshness?: FloatWithAggregatesFilter<"DataQualityReport"> | number
    metrics?: JsonWithAggregatesFilter<"DataQualityReport">
    anomalies?: JsonWithAggregatesFilter<"DataQualityReport">
    issues?: JsonWithAggregatesFilter<"DataQualityReport">
    recommendations?: JsonWithAggregatesFilter<"DataQualityReport">
    processingTime?: IntNullableWithAggregatesFilter<"DataQualityReport"> | number | null
    recordsProcessed?: BigIntNullableWithAggregatesFilter<"DataQualityReport"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DataQualityReport"> | Date | string
  }

  export type IngestionJobWhereInput = {
    AND?: IngestionJobWhereInput | IngestionJobWhereInput[]
    OR?: IngestionJobWhereInput[]
    NOT?: IngestionJobWhereInput | IngestionJobWhereInput[]
    id?: StringFilter<"IngestionJob"> | string
    datasetId?: StringFilter<"IngestionJob"> | string
    jobType?: EnumIngestionJobTypeFilter<"IngestionJob"> | $Enums.IngestionJobType
    status?: EnumJobStatusFilter<"IngestionJob"> | $Enums.JobStatus
    config?: JsonFilter<"IngestionJob">
    schedule?: StringNullableFilter<"IngestionJob"> | string | null
    startedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"IngestionJob"> | string | null
    logs?: StringNullableFilter<"IngestionJob"> | string | null
    recordsProcessed?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    recordsSucceeded?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    recordsFailed?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    metrics?: JsonNullableFilter<"IngestionJob">
    retryCount?: IntFilter<"IngestionJob"> | number
    maxRetries?: IntFilter<"IngestionJob"> | number
    nextRetryAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    createdAt?: DateTimeFilter<"IngestionJob"> | Date | string
    updatedAt?: DateTimeFilter<"IngestionJob"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }

  export type IngestionJobOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    config?: SortOrder
    schedule?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    recordsProcessed?: SortOrderInput | SortOrder
    recordsSucceeded?: SortOrderInput | SortOrder
    recordsFailed?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dataset?: DatasetOrderByWithRelationInput
  }

  export type IngestionJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngestionJobWhereInput | IngestionJobWhereInput[]
    OR?: IngestionJobWhereInput[]
    NOT?: IngestionJobWhereInput | IngestionJobWhereInput[]
    datasetId?: StringFilter<"IngestionJob"> | string
    jobType?: EnumIngestionJobTypeFilter<"IngestionJob"> | $Enums.IngestionJobType
    status?: EnumJobStatusFilter<"IngestionJob"> | $Enums.JobStatus
    config?: JsonFilter<"IngestionJob">
    schedule?: StringNullableFilter<"IngestionJob"> | string | null
    startedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"IngestionJob"> | string | null
    logs?: StringNullableFilter<"IngestionJob"> | string | null
    recordsProcessed?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    recordsSucceeded?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    recordsFailed?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    metrics?: JsonNullableFilter<"IngestionJob">
    retryCount?: IntFilter<"IngestionJob"> | number
    maxRetries?: IntFilter<"IngestionJob"> | number
    nextRetryAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    createdAt?: DateTimeFilter<"IngestionJob"> | Date | string
    updatedAt?: DateTimeFilter<"IngestionJob"> | Date | string
    dataset?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }, "id">

  export type IngestionJobOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    config?: SortOrder
    schedule?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    logs?: SortOrderInput | SortOrder
    recordsProcessed?: SortOrderInput | SortOrder
    recordsSucceeded?: SortOrderInput | SortOrder
    recordsFailed?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IngestionJobCountOrderByAggregateInput
    _avg?: IngestionJobAvgOrderByAggregateInput
    _max?: IngestionJobMaxOrderByAggregateInput
    _min?: IngestionJobMinOrderByAggregateInput
    _sum?: IngestionJobSumOrderByAggregateInput
  }

  export type IngestionJobScalarWhereWithAggregatesInput = {
    AND?: IngestionJobScalarWhereWithAggregatesInput | IngestionJobScalarWhereWithAggregatesInput[]
    OR?: IngestionJobScalarWhereWithAggregatesInput[]
    NOT?: IngestionJobScalarWhereWithAggregatesInput | IngestionJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngestionJob"> | string
    datasetId?: StringWithAggregatesFilter<"IngestionJob"> | string
    jobType?: EnumIngestionJobTypeWithAggregatesFilter<"IngestionJob"> | $Enums.IngestionJobType
    status?: EnumJobStatusWithAggregatesFilter<"IngestionJob"> | $Enums.JobStatus
    config?: JsonWithAggregatesFilter<"IngestionJob">
    schedule?: StringNullableWithAggregatesFilter<"IngestionJob"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"IngestionJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"IngestionJob"> | string | null
    logs?: StringNullableWithAggregatesFilter<"IngestionJob"> | string | null
    recordsProcessed?: BigIntNullableWithAggregatesFilter<"IngestionJob"> | bigint | number | null
    recordsSucceeded?: BigIntNullableWithAggregatesFilter<"IngestionJob"> | bigint | number | null
    recordsFailed?: BigIntNullableWithAggregatesFilter<"IngestionJob"> | bigint | number | null
    metrics?: JsonNullableWithAggregatesFilter<"IngestionJob">
    retryCount?: IntWithAggregatesFilter<"IngestionJob"> | number
    maxRetries?: IntWithAggregatesFilter<"IngestionJob"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"IngestionJob"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IngestionJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IngestionJob"> | Date | string
  }

  export type DatasetLineageWhereInput = {
    AND?: DatasetLineageWhereInput | DatasetLineageWhereInput[]
    OR?: DatasetLineageWhereInput[]
    NOT?: DatasetLineageWhereInput | DatasetLineageWhereInput[]
    id?: StringFilter<"DatasetLineage"> | string
    upstreamId?: StringFilter<"DatasetLineage"> | string
    downstreamId?: StringFilter<"DatasetLineage"> | string
    transformationType?: StringFilter<"DatasetLineage"> | string
    transformationLogic?: JsonNullableFilter<"DatasetLineage">
    confidence?: FloatFilter<"DatasetLineage"> | number
    createdAt?: DateTimeFilter<"DatasetLineage"> | Date | string
    upstream?: XOR<DatasetRelationFilter, DatasetWhereInput>
    downstream?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }

  export type DatasetLineageOrderByWithRelationInput = {
    id?: SortOrder
    upstreamId?: SortOrder
    downstreamId?: SortOrder
    transformationType?: SortOrder
    transformationLogic?: SortOrderInput | SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    upstream?: DatasetOrderByWithRelationInput
    downstream?: DatasetOrderByWithRelationInput
  }

  export type DatasetLineageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    upstreamId_downstreamId?: DatasetLineageUpstreamIdDownstreamIdCompoundUniqueInput
    AND?: DatasetLineageWhereInput | DatasetLineageWhereInput[]
    OR?: DatasetLineageWhereInput[]
    NOT?: DatasetLineageWhereInput | DatasetLineageWhereInput[]
    upstreamId?: StringFilter<"DatasetLineage"> | string
    downstreamId?: StringFilter<"DatasetLineage"> | string
    transformationType?: StringFilter<"DatasetLineage"> | string
    transformationLogic?: JsonNullableFilter<"DatasetLineage">
    confidence?: FloatFilter<"DatasetLineage"> | number
    createdAt?: DateTimeFilter<"DatasetLineage"> | Date | string
    upstream?: XOR<DatasetRelationFilter, DatasetWhereInput>
    downstream?: XOR<DatasetRelationFilter, DatasetWhereInput>
  }, "id" | "upstreamId_downstreamId">

  export type DatasetLineageOrderByWithAggregationInput = {
    id?: SortOrder
    upstreamId?: SortOrder
    downstreamId?: SortOrder
    transformationType?: SortOrder
    transformationLogic?: SortOrderInput | SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    _count?: DatasetLineageCountOrderByAggregateInput
    _avg?: DatasetLineageAvgOrderByAggregateInput
    _max?: DatasetLineageMaxOrderByAggregateInput
    _min?: DatasetLineageMinOrderByAggregateInput
    _sum?: DatasetLineageSumOrderByAggregateInput
  }

  export type DatasetLineageScalarWhereWithAggregatesInput = {
    AND?: DatasetLineageScalarWhereWithAggregatesInput | DatasetLineageScalarWhereWithAggregatesInput[]
    OR?: DatasetLineageScalarWhereWithAggregatesInput[]
    NOT?: DatasetLineageScalarWhereWithAggregatesInput | DatasetLineageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatasetLineage"> | string
    upstreamId?: StringWithAggregatesFilter<"DatasetLineage"> | string
    downstreamId?: StringWithAggregatesFilter<"DatasetLineage"> | string
    transformationType?: StringWithAggregatesFilter<"DatasetLineage"> | string
    transformationLogic?: JsonNullableWithAggregatesFilter<"DatasetLineage">
    confidence?: FloatWithAggregatesFilter<"DatasetLineage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DatasetLineage"> | Date | string
  }

  export type DataConnectorWhereInput = {
    AND?: DataConnectorWhereInput | DataConnectorWhereInput[]
    OR?: DataConnectorWhereInput[]
    NOT?: DataConnectorWhereInput | DataConnectorWhereInput[]
    id?: StringFilter<"DataConnector"> | string
    name?: StringFilter<"DataConnector"> | string
    type?: EnumDataConnectorTypeFilter<"DataConnector"> | $Enums.DataConnectorType
    description?: StringNullableFilter<"DataConnector"> | string | null
    config?: JsonFilter<"DataConnector">
    credentials?: JsonNullableFilter<"DataConnector">
    isActive?: BoolFilter<"DataConnector"> | boolean
    lastHealthCheck?: DateTimeNullableFilter<"DataConnector"> | Date | string | null
    healthStatus?: EnumConnectorHealthStatusFilter<"DataConnector"> | $Enums.ConnectorHealthStatus
    errorMessage?: StringNullableFilter<"DataConnector"> | string | null
    datasets?: StringNullableListFilter<"DataConnector">
    lastUsed?: DateTimeNullableFilter<"DataConnector"> | Date | string | null
    createdAt?: DateTimeFilter<"DataConnector"> | Date | string
    updatedAt?: DateTimeFilter<"DataConnector"> | Date | string
  }

  export type DataConnectorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrder
    credentials?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastHealthCheck?: SortOrderInput | SortOrder
    healthStatus?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    datasets?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataConnectorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DataConnectorWhereInput | DataConnectorWhereInput[]
    OR?: DataConnectorWhereInput[]
    NOT?: DataConnectorWhereInput | DataConnectorWhereInput[]
    type?: EnumDataConnectorTypeFilter<"DataConnector"> | $Enums.DataConnectorType
    description?: StringNullableFilter<"DataConnector"> | string | null
    config?: JsonFilter<"DataConnector">
    credentials?: JsonNullableFilter<"DataConnector">
    isActive?: BoolFilter<"DataConnector"> | boolean
    lastHealthCheck?: DateTimeNullableFilter<"DataConnector"> | Date | string | null
    healthStatus?: EnumConnectorHealthStatusFilter<"DataConnector"> | $Enums.ConnectorHealthStatus
    errorMessage?: StringNullableFilter<"DataConnector"> | string | null
    datasets?: StringNullableListFilter<"DataConnector">
    lastUsed?: DateTimeNullableFilter<"DataConnector"> | Date | string | null
    createdAt?: DateTimeFilter<"DataConnector"> | Date | string
    updatedAt?: DateTimeFilter<"DataConnector"> | Date | string
  }, "id" | "name">

  export type DataConnectorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrder
    credentials?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastHealthCheck?: SortOrderInput | SortOrder
    healthStatus?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    datasets?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataConnectorCountOrderByAggregateInput
    _max?: DataConnectorMaxOrderByAggregateInput
    _min?: DataConnectorMinOrderByAggregateInput
  }

  export type DataConnectorScalarWhereWithAggregatesInput = {
    AND?: DataConnectorScalarWhereWithAggregatesInput | DataConnectorScalarWhereWithAggregatesInput[]
    OR?: DataConnectorScalarWhereWithAggregatesInput[]
    NOT?: DataConnectorScalarWhereWithAggregatesInput | DataConnectorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataConnector"> | string
    name?: StringWithAggregatesFilter<"DataConnector"> | string
    type?: EnumDataConnectorTypeWithAggregatesFilter<"DataConnector"> | $Enums.DataConnectorType
    description?: StringNullableWithAggregatesFilter<"DataConnector"> | string | null
    config?: JsonWithAggregatesFilter<"DataConnector">
    credentials?: JsonNullableWithAggregatesFilter<"DataConnector">
    isActive?: BoolWithAggregatesFilter<"DataConnector"> | boolean
    lastHealthCheck?: DateTimeNullableWithAggregatesFilter<"DataConnector"> | Date | string | null
    healthStatus?: EnumConnectorHealthStatusWithAggregatesFilter<"DataConnector"> | $Enums.ConnectorHealthStatus
    errorMessage?: StringNullableWithAggregatesFilter<"DataConnector"> | string | null
    datasets?: StringNullableListFilter<"DataConnector">
    lastUsed?: DateTimeNullableWithAggregatesFilter<"DataConnector"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DataConnector"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataConnector"> | Date | string
  }

  export type SchemaMappingWhereInput = {
    AND?: SchemaMappingWhereInput | SchemaMappingWhereInput[]
    OR?: SchemaMappingWhereInput[]
    NOT?: SchemaMappingWhereInput | SchemaMappingWhereInput[]
    id?: StringFilter<"SchemaMapping"> | string
    datasetId?: StringFilter<"SchemaMapping"> | string
    name?: StringFilter<"SchemaMapping"> | string
    description?: StringNullableFilter<"SchemaMapping"> | string | null
    sourceSchema?: JsonFilter<"SchemaMapping">
    targetSchema?: JsonFilter<"SchemaMapping">
    mappingRules?: JsonFilter<"SchemaMapping">
    validationRules?: JsonFilter<"SchemaMapping">
    isActive?: BoolFilter<"SchemaMapping"> | boolean
    lastApplied?: DateTimeNullableFilter<"SchemaMapping"> | Date | string | null
    successRate?: FloatNullableFilter<"SchemaMapping"> | number | null
    createdAt?: DateTimeFilter<"SchemaMapping"> | Date | string
    updatedAt?: DateTimeFilter<"SchemaMapping"> | Date | string
  }

  export type SchemaMappingOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceSchema?: SortOrder
    targetSchema?: SortOrder
    mappingRules?: SortOrder
    validationRules?: SortOrder
    isActive?: SortOrder
    lastApplied?: SortOrderInput | SortOrder
    successRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchemaMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    datasetId_name?: SchemaMappingDatasetIdNameCompoundUniqueInput
    AND?: SchemaMappingWhereInput | SchemaMappingWhereInput[]
    OR?: SchemaMappingWhereInput[]
    NOT?: SchemaMappingWhereInput | SchemaMappingWhereInput[]
    datasetId?: StringFilter<"SchemaMapping"> | string
    name?: StringFilter<"SchemaMapping"> | string
    description?: StringNullableFilter<"SchemaMapping"> | string | null
    sourceSchema?: JsonFilter<"SchemaMapping">
    targetSchema?: JsonFilter<"SchemaMapping">
    mappingRules?: JsonFilter<"SchemaMapping">
    validationRules?: JsonFilter<"SchemaMapping">
    isActive?: BoolFilter<"SchemaMapping"> | boolean
    lastApplied?: DateTimeNullableFilter<"SchemaMapping"> | Date | string | null
    successRate?: FloatNullableFilter<"SchemaMapping"> | number | null
    createdAt?: DateTimeFilter<"SchemaMapping"> | Date | string
    updatedAt?: DateTimeFilter<"SchemaMapping"> | Date | string
  }, "id" | "datasetId_name">

  export type SchemaMappingOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceSchema?: SortOrder
    targetSchema?: SortOrder
    mappingRules?: SortOrder
    validationRules?: SortOrder
    isActive?: SortOrder
    lastApplied?: SortOrderInput | SortOrder
    successRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchemaMappingCountOrderByAggregateInput
    _avg?: SchemaMappingAvgOrderByAggregateInput
    _max?: SchemaMappingMaxOrderByAggregateInput
    _min?: SchemaMappingMinOrderByAggregateInput
    _sum?: SchemaMappingSumOrderByAggregateInput
  }

  export type SchemaMappingScalarWhereWithAggregatesInput = {
    AND?: SchemaMappingScalarWhereWithAggregatesInput | SchemaMappingScalarWhereWithAggregatesInput[]
    OR?: SchemaMappingScalarWhereWithAggregatesInput[]
    NOT?: SchemaMappingScalarWhereWithAggregatesInput | SchemaMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchemaMapping"> | string
    datasetId?: StringWithAggregatesFilter<"SchemaMapping"> | string
    name?: StringWithAggregatesFilter<"SchemaMapping"> | string
    description?: StringNullableWithAggregatesFilter<"SchemaMapping"> | string | null
    sourceSchema?: JsonWithAggregatesFilter<"SchemaMapping">
    targetSchema?: JsonWithAggregatesFilter<"SchemaMapping">
    mappingRules?: JsonWithAggregatesFilter<"SchemaMapping">
    validationRules?: JsonWithAggregatesFilter<"SchemaMapping">
    isActive?: BoolWithAggregatesFilter<"SchemaMapping"> | boolean
    lastApplied?: DateTimeNullableWithAggregatesFilter<"SchemaMapping"> | Date | string | null
    successRate?: FloatNullableWithAggregatesFilter<"SchemaMapping"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SchemaMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchemaMapping"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrderInput | SortOrder
    changes?: SortOrder
    timestamp?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrderInput | SortOrder
    changes?: SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    changes?: JsonWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type DistributionSessionWhereInput = {
    AND?: DistributionSessionWhereInput | DistributionSessionWhereInput[]
    OR?: DistributionSessionWhereInput[]
    NOT?: DistributionSessionWhereInput | DistributionSessionWhereInput[]
    id?: StringFilter<"DistributionSession"> | string
    campaignId?: StringFilter<"DistributionSession"> | string
    currentScenario?: StringNullableFilter<"DistributionSession"> | string | null
    presentationMode?: BoolFilter<"DistributionSession"> | boolean
    lastSaved?: DateTimeFilter<"DistributionSession"> | Date | string
    hasUnsavedChanges?: BoolFilter<"DistributionSession"> | boolean
    metadata?: JsonFilter<"DistributionSession">
    createdAt?: DateTimeFilter<"DistributionSession"> | Date | string
    updatedAt?: DateTimeFilter<"DistributionSession"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    scenarios?: DistributionScenarioListRelationFilter
  }

  export type DistributionSessionOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    currentScenario?: SortOrderInput | SortOrder
    presentationMode?: SortOrder
    lastSaved?: SortOrder
    hasUnsavedChanges?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    scenarios?: DistributionScenarioOrderByRelationAggregateInput
  }

  export type DistributionSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId?: string
    AND?: DistributionSessionWhereInput | DistributionSessionWhereInput[]
    OR?: DistributionSessionWhereInput[]
    NOT?: DistributionSessionWhereInput | DistributionSessionWhereInput[]
    currentScenario?: StringNullableFilter<"DistributionSession"> | string | null
    presentationMode?: BoolFilter<"DistributionSession"> | boolean
    lastSaved?: DateTimeFilter<"DistributionSession"> | Date | string
    hasUnsavedChanges?: BoolFilter<"DistributionSession"> | boolean
    metadata?: JsonFilter<"DistributionSession">
    createdAt?: DateTimeFilter<"DistributionSession"> | Date | string
    updatedAt?: DateTimeFilter<"DistributionSession"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    scenarios?: DistributionScenarioListRelationFilter
  }, "id" | "campaignId">

  export type DistributionSessionOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    currentScenario?: SortOrderInput | SortOrder
    presentationMode?: SortOrder
    lastSaved?: SortOrder
    hasUnsavedChanges?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DistributionSessionCountOrderByAggregateInput
    _max?: DistributionSessionMaxOrderByAggregateInput
    _min?: DistributionSessionMinOrderByAggregateInput
  }

  export type DistributionSessionScalarWhereWithAggregatesInput = {
    AND?: DistributionSessionScalarWhereWithAggregatesInput | DistributionSessionScalarWhereWithAggregatesInput[]
    OR?: DistributionSessionScalarWhereWithAggregatesInput[]
    NOT?: DistributionSessionScalarWhereWithAggregatesInput | DistributionSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DistributionSession"> | string
    campaignId?: StringWithAggregatesFilter<"DistributionSession"> | string
    currentScenario?: StringNullableWithAggregatesFilter<"DistributionSession"> | string | null
    presentationMode?: BoolWithAggregatesFilter<"DistributionSession"> | boolean
    lastSaved?: DateTimeWithAggregatesFilter<"DistributionSession"> | Date | string
    hasUnsavedChanges?: BoolWithAggregatesFilter<"DistributionSession"> | boolean
    metadata?: JsonWithAggregatesFilter<"DistributionSession">
    createdAt?: DateTimeWithAggregatesFilter<"DistributionSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DistributionSession"> | Date | string
  }

  export type DistributionScenarioWhereInput = {
    AND?: DistributionScenarioWhereInput | DistributionScenarioWhereInput[]
    OR?: DistributionScenarioWhereInput[]
    NOT?: DistributionScenarioWhereInput | DistributionScenarioWhereInput[]
    id?: StringFilter<"DistributionScenario"> | string
    sessionId?: StringFilter<"DistributionScenario"> | string
    name?: StringFilter<"DistributionScenario"> | string
    description?: StringNullableFilter<"DistributionScenario"> | string | null
    isBaseline?: BoolFilter<"DistributionScenario"> | boolean
    parameters?: JsonFilter<"DistributionScenario">
    projections?: JsonFilter<"DistributionScenario">
    lastModified?: DateTimeFilter<"DistributionScenario"> | Date | string
    createdAt?: DateTimeFilter<"DistributionScenario"> | Date | string
    updatedAt?: DateTimeFilter<"DistributionScenario"> | Date | string
    session?: XOR<DistributionSessionRelationFilter, DistributionSessionWhereInput>
    changes?: DistributionChangeListRelationFilter
  }

  export type DistributionScenarioOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isBaseline?: SortOrder
    parameters?: SortOrder
    projections?: SortOrder
    lastModified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: DistributionSessionOrderByWithRelationInput
    changes?: DistributionChangeOrderByRelationAggregateInput
  }

  export type DistributionScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DistributionScenarioWhereInput | DistributionScenarioWhereInput[]
    OR?: DistributionScenarioWhereInput[]
    NOT?: DistributionScenarioWhereInput | DistributionScenarioWhereInput[]
    sessionId?: StringFilter<"DistributionScenario"> | string
    name?: StringFilter<"DistributionScenario"> | string
    description?: StringNullableFilter<"DistributionScenario"> | string | null
    isBaseline?: BoolFilter<"DistributionScenario"> | boolean
    parameters?: JsonFilter<"DistributionScenario">
    projections?: JsonFilter<"DistributionScenario">
    lastModified?: DateTimeFilter<"DistributionScenario"> | Date | string
    createdAt?: DateTimeFilter<"DistributionScenario"> | Date | string
    updatedAt?: DateTimeFilter<"DistributionScenario"> | Date | string
    session?: XOR<DistributionSessionRelationFilter, DistributionSessionWhereInput>
    changes?: DistributionChangeListRelationFilter
  }, "id">

  export type DistributionScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isBaseline?: SortOrder
    parameters?: SortOrder
    projections?: SortOrder
    lastModified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DistributionScenarioCountOrderByAggregateInput
    _max?: DistributionScenarioMaxOrderByAggregateInput
    _min?: DistributionScenarioMinOrderByAggregateInput
  }

  export type DistributionScenarioScalarWhereWithAggregatesInput = {
    AND?: DistributionScenarioScalarWhereWithAggregatesInput | DistributionScenarioScalarWhereWithAggregatesInput[]
    OR?: DistributionScenarioScalarWhereWithAggregatesInput[]
    NOT?: DistributionScenarioScalarWhereWithAggregatesInput | DistributionScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DistributionScenario"> | string
    sessionId?: StringWithAggregatesFilter<"DistributionScenario"> | string
    name?: StringWithAggregatesFilter<"DistributionScenario"> | string
    description?: StringNullableWithAggregatesFilter<"DistributionScenario"> | string | null
    isBaseline?: BoolWithAggregatesFilter<"DistributionScenario"> | boolean
    parameters?: JsonWithAggregatesFilter<"DistributionScenario">
    projections?: JsonWithAggregatesFilter<"DistributionScenario">
    lastModified?: DateTimeWithAggregatesFilter<"DistributionScenario"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DistributionScenario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DistributionScenario"> | Date | string
  }

  export type DistributionChangeWhereInput = {
    AND?: DistributionChangeWhereInput | DistributionChangeWhereInput[]
    OR?: DistributionChangeWhereInput[]
    NOT?: DistributionChangeWhereInput | DistributionChangeWhereInput[]
    id?: StringFilter<"DistributionChange"> | string
    scenarioId?: StringFilter<"DistributionChange"> | string
    field?: StringFilter<"DistributionChange"> | string
    oldValue?: JsonFilter<"DistributionChange">
    newValue?: JsonFilter<"DistributionChange">
    userId?: StringNullableFilter<"DistributionChange"> | string | null
    timestamp?: DateTimeFilter<"DistributionChange"> | Date | string
    scenario?: XOR<DistributionScenarioRelationFilter, DistributionScenarioWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type DistributionChangeOrderByWithRelationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    scenario?: DistributionScenarioOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DistributionChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DistributionChangeWhereInput | DistributionChangeWhereInput[]
    OR?: DistributionChangeWhereInput[]
    NOT?: DistributionChangeWhereInput | DistributionChangeWhereInput[]
    scenarioId?: StringFilter<"DistributionChange"> | string
    field?: StringFilter<"DistributionChange"> | string
    oldValue?: JsonFilter<"DistributionChange">
    newValue?: JsonFilter<"DistributionChange">
    userId?: StringNullableFilter<"DistributionChange"> | string | null
    timestamp?: DateTimeFilter<"DistributionChange"> | Date | string
    scenario?: XOR<DistributionScenarioRelationFilter, DistributionScenarioWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type DistributionChangeOrderByWithAggregationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: DistributionChangeCountOrderByAggregateInput
    _max?: DistributionChangeMaxOrderByAggregateInput
    _min?: DistributionChangeMinOrderByAggregateInput
  }

  export type DistributionChangeScalarWhereWithAggregatesInput = {
    AND?: DistributionChangeScalarWhereWithAggregatesInput | DistributionChangeScalarWhereWithAggregatesInput[]
    OR?: DistributionChangeScalarWhereWithAggregatesInput[]
    NOT?: DistributionChangeScalarWhereWithAggregatesInput | DistributionChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DistributionChange"> | string
    scenarioId?: StringWithAggregatesFilter<"DistributionChange"> | string
    field?: StringWithAggregatesFilter<"DistributionChange"> | string
    oldValue?: JsonWithAggregatesFilter<"DistributionChange">
    newValue?: JsonWithAggregatesFilter<"DistributionChange">
    userId?: StringNullableWithAggregatesFilter<"DistributionChange"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"DistributionChange"> | Date | string
  }

  export type DistributionCacheWhereInput = {
    AND?: DistributionCacheWhereInput | DistributionCacheWhereInput[]
    OR?: DistributionCacheWhereInput[]
    NOT?: DistributionCacheWhereInput | DistributionCacheWhereInput[]
    id?: StringFilter<"DistributionCache"> | string
    cacheKey?: StringFilter<"DistributionCache"> | string
    data?: JsonFilter<"DistributionCache">
    expiresAt?: DateTimeFilter<"DistributionCache"> | Date | string
    createdAt?: DateTimeFilter<"DistributionCache"> | Date | string
  }

  export type DistributionCacheOrderByWithRelationInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DistributionCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cacheKey?: string
    AND?: DistributionCacheWhereInput | DistributionCacheWhereInput[]
    OR?: DistributionCacheWhereInput[]
    NOT?: DistributionCacheWhereInput | DistributionCacheWhereInput[]
    data?: JsonFilter<"DistributionCache">
    expiresAt?: DateTimeFilter<"DistributionCache"> | Date | string
    createdAt?: DateTimeFilter<"DistributionCache"> | Date | string
  }, "id" | "cacheKey">

  export type DistributionCacheOrderByWithAggregationInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: DistributionCacheCountOrderByAggregateInput
    _max?: DistributionCacheMaxOrderByAggregateInput
    _min?: DistributionCacheMinOrderByAggregateInput
  }

  export type DistributionCacheScalarWhereWithAggregatesInput = {
    AND?: DistributionCacheScalarWhereWithAggregatesInput | DistributionCacheScalarWhereWithAggregatesInput[]
    OR?: DistributionCacheScalarWhereWithAggregatesInput[]
    NOT?: DistributionCacheScalarWhereWithAggregatesInput | DistributionCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DistributionCache"> | string
    cacheKey?: StringWithAggregatesFilter<"DistributionCache"> | string
    data?: JsonWithAggregatesFilter<"DistributionCache">
    expiresAt?: DateTimeWithAggregatesFilter<"DistributionCache"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DistributionCache"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    distributionChanges?: DistributionChangeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    distributionChanges?: DistributionChangeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    distributionChanges?: DistributionChangeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    distributionChanges?: DistributionChangeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    rfps?: RFPCreateNestedManyWithoutCampaignInput
    partnerAssociations?: CampaignPartnerCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rfps?: RFPUncheckedCreateNestedManyWithoutCampaignInput
    partnerAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    rfps?: RFPUpdateManyWithoutCampaignNestedInput
    partnerAssociations?: CampaignPartnerUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfps?: RFPUncheckedUpdateManyWithoutCampaignNestedInput
    partnerAssociations?: CampaignPartnerUncheckedUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFPCreateInput = {
    id?: string
    partners: JsonNullValueInput | InputJsonValue
    status: string
    requestedAt: Date | string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutRfpsInput
  }

  export type RFPUncheckedCreateInput = {
    id?: string
    campaignId: string
    partners: JsonNullValueInput | InputJsonValue
    status: string
    requestedAt: Date | string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutRfpsNestedInput
  }

  export type RFPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFPCreateManyInput = {
    id?: string
    campaignId: string
    partners: JsonNullValueInput | InputJsonValue
    status: string
    requestedAt: Date | string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityCreateNestedManyWithoutPartnerInput
    creativeSpecs?: CreativeSpecCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityUncheckedCreateNestedManyWithoutPartnerInput
    creativeSpecs?: CreativeSpecUncheckedCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricUncheckedCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUpdateManyWithoutPartnerNestedInput
    creativeSpecs?: CreativeSpecUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUncheckedUpdateManyWithoutPartnerNestedInput
    creativeSpecs?: CreativeSpecUncheckedUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUncheckedUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCapabilityCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    details: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastUpdated?: Date | string
    sourceType: $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutCapabilitiesInput
  }

  export type PartnerCapabilityUncheckedCreateInput = {
    id?: string
    partnerId: string
    name: string
    description?: string | null
    category: string
    details: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastUpdated?: Date | string
    sourceType: $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCapabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutCapabilitiesNestedInput
  }

  export type PartnerCapabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCapabilityCreateManyInput = {
    id?: string
    partnerId: string
    name: string
    description?: string | null
    category: string
    details: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastUpdated?: Date | string
    sourceType: $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCapabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCapabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeSpecCreateInput = {
    id?: string
    format: string
    dimensions: JsonNullValueInput | InputJsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutCreativeSpecsInput
  }

  export type CreativeSpecUncheckedCreateInput = {
    id?: string
    partnerId: string
    format: string
    dimensions: JsonNullValueInput | InputJsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeSpecUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutCreativeSpecsNestedInput
  }

  export type CreativeSpecUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeSpecCreateManyInput = {
    id?: string
    partnerId: string
    format: string
    dimensions: JsonNullValueInput | InputJsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeSpecUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeSpecUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerHealthMetricCreateInput = {
    id?: string
    timestamp?: Date | string
    apiStatus: $Enums.ApiStatus
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    lastError?: string | null
    healthScore?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    partner: PartnerCreateNestedOneWithoutHealthMetricsInput
  }

  export type PartnerHealthMetricUncheckedCreateInput = {
    id?: string
    partnerId: string
    timestamp?: Date | string
    apiStatus: $Enums.ApiStatus
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    lastError?: string | null
    healthScore?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    partner?: PartnerUpdateOneRequiredWithoutHealthMetricsNestedInput
  }

  export type PartnerHealthMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricCreateManyInput = {
    id?: string
    partnerId: string
    timestamp?: Date | string
    apiStatus: $Enums.ApiStatus
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    lastError?: string | null
    healthScore?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignPartnerCreateInput = {
    id?: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutPartnerAssociationsInput
    partner: PartnerCreateNestedOneWithoutCampaignAssociationsInput
  }

  export type CampaignPartnerUncheckedCreateInput = {
    id?: string
    campaignId: string
    partnerId: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutPartnerAssociationsNestedInput
    partner?: PartnerUpdateOneRequiredWithoutCampaignAssociationsNestedInput
  }

  export type CampaignPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPartnerCreateManyInput = {
    id?: string
    campaignId: string
    partnerId: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityMatrixCreateInput = {
    id?: string
    name: string
    description?: string | null
    capabilities: JsonNullValueInput | InputJsonValue
    comparison: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityMatrixUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    capabilities: JsonNullValueInput | InputJsonValue
    comparison: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityMatrixUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: JsonNullValueInput | InputJsonValue
    comparison?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityMatrixUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: JsonNullValueInput | InputJsonValue
    comparison?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityMatrixCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    capabilities: JsonNullValueInput | InputJsonValue
    comparison: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityMatrixUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: JsonNullValueInput | InputJsonValue
    comparison?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityMatrixUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capabilities?: JsonNullValueInput | InputJsonValue
    comparison?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionUncheckedCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportUncheckedCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageUncheckedCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageUncheckedCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUncheckedUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUncheckedUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUncheckedUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUncheckedUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetVersionCreateInput = {
    id?: string
    version: string
    description?: string | null
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    size?: bigint | number | null
    recordCount?: bigint | number | null
    checksums: JsonNullValueInput | InputJsonValue
    location: string
    isActive?: boolean
    createdAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutVersionsInput
  }

  export type DatasetVersionUncheckedCreateInput = {
    id?: string
    datasetId: string
    version: string
    description?: string | null
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    size?: bigint | number | null
    recordCount?: bigint | number | null
    checksums: JsonNullValueInput | InputJsonValue
    location: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type DatasetVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type DatasetVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetVersionCreateManyInput = {
    id?: string
    datasetId: string
    version: string
    description?: string | null
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    size?: bigint | number | null
    recordCount?: bigint | number | null
    checksums: JsonNullValueInput | InputJsonValue
    location: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type DatasetVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityReportCreateInput = {
    id?: string
    reportDate?: Date | string
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    issues: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    processingTime?: number | null
    recordsProcessed?: bigint | number | null
    createdAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutQualityReportsInput
  }

  export type DataQualityReportUncheckedCreateInput = {
    id?: string
    datasetId: string
    reportDate?: Date | string
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    issues: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    processingTime?: number | null
    recordsProcessed?: bigint | number | null
    createdAt?: Date | string
  }

  export type DataQualityReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutQualityReportsNestedInput
  }

  export type DataQualityReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityReportCreateManyInput = {
    id?: string
    datasetId: string
    reportDate?: Date | string
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    issues: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    processingTime?: number | null
    recordsProcessed?: bigint | number | null
    createdAt?: Date | string
  }

  export type DataQualityReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobCreateInput = {
    id?: string
    jobType: $Enums.IngestionJobType
    status?: $Enums.JobStatus
    config: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    logs?: string | null
    recordsProcessed?: bigint | number | null
    recordsSucceeded?: bigint | number | null
    recordsFailed?: bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutIngestionJobsInput
  }

  export type IngestionJobUncheckedCreateInput = {
    id?: string
    datasetId: string
    jobType: $Enums.IngestionJobType
    status?: $Enums.JobStatus
    config: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    logs?: string | null
    recordsProcessed?: bigint | number | null
    recordsSucceeded?: bigint | number | null
    recordsFailed?: bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngestionJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutIngestionJobsNestedInput
  }

  export type IngestionJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobCreateManyInput = {
    id?: string
    datasetId: string
    jobType: $Enums.IngestionJobType
    status?: $Enums.JobStatus
    config: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    logs?: string | null
    recordsProcessed?: bigint | number | null
    recordsSucceeded?: bigint | number | null
    recordsFailed?: bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngestionJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageCreateInput = {
    id?: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
    upstream: DatasetCreateNestedOneWithoutLineageUpstreamInput
    downstream: DatasetCreateNestedOneWithoutLineageDownstreamInput
  }

  export type DatasetLineageUncheckedCreateInput = {
    id?: string
    upstreamId: string
    downstreamId: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
  }

  export type DatasetLineageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upstream?: DatasetUpdateOneRequiredWithoutLineageUpstreamNestedInput
    downstream?: DatasetUpdateOneRequiredWithoutLineageDownstreamNestedInput
  }

  export type DatasetLineageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    upstreamId?: StringFieldUpdateOperationsInput | string
    downstreamId?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageCreateManyInput = {
    id?: string
    upstreamId: string
    downstreamId: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
  }

  export type DatasetLineageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    upstreamId?: StringFieldUpdateOperationsInput | string
    downstreamId?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataConnectorCreateInput = {
    id?: string
    name: string
    type: $Enums.DataConnectorType
    description?: string | null
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastHealthCheck?: Date | string | null
    healthStatus?: $Enums.ConnectorHealthStatus
    errorMessage?: string | null
    datasets?: DataConnectorCreatedatasetsInput | string[]
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataConnectorUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.DataConnectorType
    description?: string | null
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastHealthCheck?: Date | string | null
    healthStatus?: $Enums.ConnectorHealthStatus
    errorMessage?: string | null
    datasets?: DataConnectorCreatedatasetsInput | string[]
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataConnectorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDataConnectorTypeFieldUpdateOperationsInput | $Enums.DataConnectorType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthStatus?: EnumConnectorHealthStatusFieldUpdateOperationsInput | $Enums.ConnectorHealthStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    datasets?: DataConnectorUpdatedatasetsInput | string[]
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataConnectorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDataConnectorTypeFieldUpdateOperationsInput | $Enums.DataConnectorType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthStatus?: EnumConnectorHealthStatusFieldUpdateOperationsInput | $Enums.ConnectorHealthStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    datasets?: DataConnectorUpdatedatasetsInput | string[]
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataConnectorCreateManyInput = {
    id?: string
    name: string
    type: $Enums.DataConnectorType
    description?: string | null
    config: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastHealthCheck?: Date | string | null
    healthStatus?: $Enums.ConnectorHealthStatus
    errorMessage?: string | null
    datasets?: DataConnectorCreatedatasetsInput | string[]
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataConnectorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDataConnectorTypeFieldUpdateOperationsInput | $Enums.DataConnectorType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthStatus?: EnumConnectorHealthStatusFieldUpdateOperationsInput | $Enums.ConnectorHealthStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    datasets?: DataConnectorUpdatedatasetsInput | string[]
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataConnectorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDataConnectorTypeFieldUpdateOperationsInput | $Enums.DataConnectorType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthStatus?: EnumConnectorHealthStatusFieldUpdateOperationsInput | $Enums.ConnectorHealthStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    datasets?: DataConnectorUpdatedatasetsInput | string[]
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchemaMappingCreateInput = {
    id?: string
    datasetId: string
    name: string
    description?: string | null
    sourceSchema: JsonNullValueInput | InputJsonValue
    targetSchema: JsonNullValueInput | InputJsonValue
    mappingRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastApplied?: Date | string | null
    successRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchemaMappingUncheckedCreateInput = {
    id?: string
    datasetId: string
    name: string
    description?: string | null
    sourceSchema: JsonNullValueInput | InputJsonValue
    targetSchema: JsonNullValueInput | InputJsonValue
    mappingRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastApplied?: Date | string | null
    successRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchemaMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSchema?: JsonNullValueInput | InputJsonValue
    targetSchema?: JsonNullValueInput | InputJsonValue
    mappingRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastApplied?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchemaMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSchema?: JsonNullValueInput | InputJsonValue
    targetSchema?: JsonNullValueInput | InputJsonValue
    mappingRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastApplied?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchemaMappingCreateManyInput = {
    id?: string
    datasetId: string
    name: string
    description?: string | null
    sourceSchema: JsonNullValueInput | InputJsonValue
    targetSchema: JsonNullValueInput | InputJsonValue
    mappingRules: JsonNullValueInput | InputJsonValue
    validationRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastApplied?: Date | string | null
    successRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchemaMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSchema?: JsonNullValueInput | InputJsonValue
    targetSchema?: JsonNullValueInput | InputJsonValue
    mappingRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastApplied?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchemaMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSchema?: JsonNullValueInput | InputJsonValue
    targetSchema?: JsonNullValueInput | InputJsonValue
    mappingRules?: JsonNullValueInput | InputJsonValue
    validationRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastApplied?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    actorId?: string | null
    changes: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    actorId?: string | null
    changes: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionSessionCreateInput = {
    id?: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutDistributionSessionInput
    scenarios?: DistributionScenarioCreateNestedManyWithoutSessionInput
  }

  export type DistributionSessionUncheckedCreateInput = {
    id?: string
    campaignId: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: DistributionScenarioUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DistributionSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutDistributionSessionNestedInput
    scenarios?: DistributionScenarioUpdateManyWithoutSessionNestedInput
  }

  export type DistributionSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: DistributionScenarioUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type DistributionSessionCreateManyInput = {
    id?: string
    campaignId: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistributionSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionScenarioCreateInput = {
    id?: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DistributionSessionCreateNestedOneWithoutScenariosInput
    changes?: DistributionChangeCreateNestedManyWithoutScenarioInput
  }

  export type DistributionScenarioUncheckedCreateInput = {
    id?: string
    sessionId: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: DistributionChangeUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type DistributionScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DistributionSessionUpdateOneRequiredWithoutScenariosNestedInput
    changes?: DistributionChangeUpdateManyWithoutScenarioNestedInput
  }

  export type DistributionScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: DistributionChangeUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type DistributionScenarioCreateManyInput = {
    id?: string
    sessionId: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistributionScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeCreateInput = {
    id?: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    scenario: DistributionScenarioCreateNestedOneWithoutChangesInput
    user?: UserCreateNestedOneWithoutDistributionChangesInput
  }

  export type DistributionChangeUncheckedCreateInput = {
    id?: string
    scenarioId: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
  }

  export type DistributionChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scenario?: DistributionScenarioUpdateOneRequiredWithoutChangesNestedInput
    user?: UserUpdateOneWithoutDistributionChangesNestedInput
  }

  export type DistributionChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeCreateManyInput = {
    id?: string
    scenarioId: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
  }

  export type DistributionChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionCacheCreateInput = {
    id?: string
    cacheKey: string
    data: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type DistributionCacheUncheckedCreateInput = {
    id?: string
    cacheKey: string
    data: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type DistributionCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionCacheCreateManyInput = {
    id?: string
    cacheKey: string
    data: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type DistributionCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DistributionChangeListRelationFilter = {
    every?: DistributionChangeWhereInput
    some?: DistributionChangeWhereInput
    none?: DistributionChangeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistributionChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RFPListRelationFilter = {
    every?: RFPWhereInput
    some?: RFPWhereInput
    none?: RFPWhereInput
  }

  export type CampaignPartnerListRelationFilter = {
    every?: CampaignPartnerWhereInput
    some?: CampaignPartnerWhereInput
    none?: CampaignPartnerWhereInput
  }

  export type DistributionSessionNullableRelationFilter = {
    is?: DistributionSessionWhereInput | null
    isNot?: DistributionSessionWhereInput | null
  }

  export type RFPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    objectives?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type RFPCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partners?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFPMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFPMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type EnumPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusFilter<$PrismaModel> | $Enums.PartnerStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumOnboardingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusFilter<$PrismaModel> | $Enums.OnboardingStatus
  }

  export type PartnerCapabilityListRelationFilter = {
    every?: PartnerCapabilityWhereInput
    some?: PartnerCapabilityWhereInput
    none?: PartnerCapabilityWhereInput
  }

  export type CreativeSpecListRelationFilter = {
    every?: CreativeSpecWhereInput
    some?: CreativeSpecWhereInput
    none?: CreativeSpecWhereInput
  }

  export type PartnerHealthMetricListRelationFilter = {
    every?: PartnerHealthMetricWhereInput
    some?: PartnerHealthMetricWhereInput
    none?: PartnerHealthMetricWhereInput
  }

  export type PartnerCapabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreativeSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerHealthMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    companyInfo?: SortOrder
    contactInfo?: SortOrder
    apiCredentials?: SortOrder
    targetingOptions?: SortOrder
    measurementCapabilities?: SortOrder
    onboardingStatus?: SortOrder
    onboardingSteps?: SortOrder
    pricingInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    onboardingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    onboardingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type EnumPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumOnboardingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnboardingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnboardingStatusFilter<$PrismaModel>
    _max?: NestedEnumOnboardingStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumCapabilitySourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CapabilitySourceType | EnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCapabilitySourceTypeFilter<$PrismaModel> | $Enums.CapabilitySourceType
  }

  export type PartnerRelationFilter = {
    is?: PartnerWhereInput
    isNot?: PartnerWhereInput
  }

  export type PartnerCapabilityPartnerIdNameCompoundUniqueInput = {
    partnerId: string
    name: string
  }

  export type PartnerCapabilityCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    details?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    sourceType?: SortOrder
    sourceData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerCapabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerCapabilityMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    lastUpdated?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCapabilitySourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CapabilitySourceType | EnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCapabilitySourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.CapabilitySourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCapabilitySourceTypeFilter<$PrismaModel>
    _max?: NestedEnumCapabilitySourceTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CreativeSpecCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    format?: SortOrder
    dimensions?: SortOrder
    fileType?: SortOrder
    maxFileSize?: SortOrder
    requirements?: SortOrder
    examples?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreativeSpecAvgOrderByAggregateInput = {
    maxFileSize?: SortOrder
  }

  export type CreativeSpecMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    format?: SortOrder
    fileType?: SortOrder
    maxFileSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreativeSpecMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    format?: SortOrder
    fileType?: SortOrder
    maxFileSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreativeSpecSumOrderByAggregateInput = {
    maxFileSize?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumApiStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusFilter<$PrismaModel> | $Enums.ApiStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PartnerHealthMetricCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    timestamp?: SortOrder
    apiStatus?: SortOrder
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    lastError?: SortOrder
    healthScore?: SortOrder
    details?: SortOrder
  }

  export type PartnerHealthMetricAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    healthScore?: SortOrder
  }

  export type PartnerHealthMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    timestamp?: SortOrder
    apiStatus?: SortOrder
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    lastError?: SortOrder
    healthScore?: SortOrder
  }

  export type PartnerHealthMetricMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    timestamp?: SortOrder
    apiStatus?: SortOrder
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    lastError?: SortOrder
    healthScore?: SortOrder
  }

  export type PartnerHealthMetricSumOrderByAggregateInput = {
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    healthScore?: SortOrder
  }

  export type EnumApiStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApiStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiStatusFilter<$PrismaModel>
    _max?: NestedEnumApiStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCampaignPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignPartnerStatus | EnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignPartnerStatusFilter<$PrismaModel> | $Enums.CampaignPartnerStatus
  }

  export type CampaignPartnerCampaignIdPartnerIdCompoundUniqueInput = {
    campaignId: string
    partnerId: string
  }

  export type CampaignPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    targeting?: SortOrder
    creative?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCampaignPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignPartnerStatus | EnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignPartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignPartnerStatusFilter<$PrismaModel>
  }

  export type CapabilityMatrixCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    capabilities?: SortOrder
    comparison?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityMatrixMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityMatrixMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDatasetCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetCategory | EnumDatasetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetCategoryFilter<$PrismaModel> | $Enums.DatasetCategory
  }

  export type EnumDatasetSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetSourceType | EnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetSourceTypeFilter<$PrismaModel> | $Enums.DatasetSourceType
  }

  export type EnumUpdateFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateFrequency | EnumUpdateFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumUpdateFrequencyFilter<$PrismaModel> | $Enums.UpdateFrequency
  }

  export type EnumDatasetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusFilter<$PrismaModel> | $Enums.DatasetStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DatasetVersionListRelationFilter = {
    every?: DatasetVersionWhereInput
    some?: DatasetVersionWhereInput
    none?: DatasetVersionWhereInput
  }

  export type DataQualityReportListRelationFilter = {
    every?: DataQualityReportWhereInput
    some?: DataQualityReportWhereInput
    none?: DataQualityReportWhereInput
  }

  export type IngestionJobListRelationFilter = {
    every?: IngestionJobWhereInput
    some?: IngestionJobWhereInput
    none?: IngestionJobWhereInput
  }

  export type DatasetLineageListRelationFilter = {
    every?: DatasetLineageWhereInput
    some?: DatasetLineageWhereInput
    none?: DatasetLineageWhereInput
  }

  export type DatasetVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataQualityReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngestionJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetLineageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    sourceType?: SortOrder
    updateFrequency?: SortOrder
    schema?: SortOrder
    metadata?: SortOrder
    qualityScore?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    sourceConfig?: SortOrder
    lastIngestion?: SortOrder
    nextIngestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetAvgOrderByAggregateInput = {
    qualityScore?: SortOrder
  }

  export type DatasetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    sourceType?: SortOrder
    updateFrequency?: SortOrder
    qualityScore?: SortOrder
    status?: SortOrder
    lastIngestion?: SortOrder
    nextIngestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    sourceType?: SortOrder
    updateFrequency?: SortOrder
    qualityScore?: SortOrder
    status?: SortOrder
    lastIngestion?: SortOrder
    nextIngestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetSumOrderByAggregateInput = {
    qualityScore?: SortOrder
  }

  export type EnumDatasetCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetCategory | EnumDatasetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DatasetCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetCategoryFilter<$PrismaModel>
    _max?: NestedEnumDatasetCategoryFilter<$PrismaModel>
  }

  export type EnumDatasetSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetSourceType | EnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DatasetSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumDatasetSourceTypeFilter<$PrismaModel>
  }

  export type EnumUpdateFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateFrequency | EnumUpdateFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumUpdateFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.UpdateFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUpdateFrequencyFilter<$PrismaModel>
    _max?: NestedEnumUpdateFrequencyFilter<$PrismaModel>
  }

  export type EnumDatasetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel> | $Enums.DatasetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetStatusFilter<$PrismaModel>
    _max?: NestedEnumDatasetStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DatasetRelationFilter = {
    is?: DatasetWhereInput
    isNot?: DatasetWhereInput
  }

  export type DatasetVersionDatasetIdVersionCompoundUniqueInput = {
    datasetId: string
    version: string
  }

  export type DatasetVersionCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    version?: SortOrder
    description?: SortOrder
    schema?: SortOrder
    metadata?: SortOrder
    size?: SortOrder
    recordCount?: SortOrder
    checksums?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type DatasetVersionAvgOrderByAggregateInput = {
    size?: SortOrder
    recordCount?: SortOrder
  }

  export type DatasetVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    version?: SortOrder
    description?: SortOrder
    size?: SortOrder
    recordCount?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type DatasetVersionMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    version?: SortOrder
    description?: SortOrder
    size?: SortOrder
    recordCount?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type DatasetVersionSumOrderByAggregateInput = {
    size?: SortOrder
    recordCount?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DataQualityReportCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    reportDate?: SortOrder
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    metrics?: SortOrder
    anomalies?: SortOrder
    issues?: SortOrder
    recommendations?: SortOrder
    processingTime?: SortOrder
    recordsProcessed?: SortOrder
    createdAt?: SortOrder
  }

  export type DataQualityReportAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    processingTime?: SortOrder
    recordsProcessed?: SortOrder
  }

  export type DataQualityReportMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    reportDate?: SortOrder
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    processingTime?: SortOrder
    recordsProcessed?: SortOrder
    createdAt?: SortOrder
  }

  export type DataQualityReportMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    reportDate?: SortOrder
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    processingTime?: SortOrder
    recordsProcessed?: SortOrder
    createdAt?: SortOrder
  }

  export type DataQualityReportSumOrderByAggregateInput = {
    overallScore?: SortOrder
    completeness?: SortOrder
    accuracy?: SortOrder
    consistency?: SortOrder
    validity?: SortOrder
    freshness?: SortOrder
    processingTime?: SortOrder
    recordsProcessed?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumIngestionJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IngestionJobType | EnumIngestionJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIngestionJobTypeFilter<$PrismaModel> | $Enums.IngestionJobType
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type IngestionJobCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    config?: SortOrder
    schedule?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    logs?: SortOrder
    recordsProcessed?: SortOrder
    recordsSucceeded?: SortOrder
    recordsFailed?: SortOrder
    metrics?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngestionJobAvgOrderByAggregateInput = {
    recordsProcessed?: SortOrder
    recordsSucceeded?: SortOrder
    recordsFailed?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type IngestionJobMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    schedule?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    logs?: SortOrder
    recordsProcessed?: SortOrder
    recordsSucceeded?: SortOrder
    recordsFailed?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngestionJobMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    schedule?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    logs?: SortOrder
    recordsProcessed?: SortOrder
    recordsSucceeded?: SortOrder
    recordsFailed?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngestionJobSumOrderByAggregateInput = {
    recordsProcessed?: SortOrder
    recordsSucceeded?: SortOrder
    recordsFailed?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type EnumIngestionJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IngestionJobType | EnumIngestionJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIngestionJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.IngestionJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIngestionJobTypeFilter<$PrismaModel>
    _max?: NestedEnumIngestionJobTypeFilter<$PrismaModel>
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type DatasetLineageUpstreamIdDownstreamIdCompoundUniqueInput = {
    upstreamId: string
    downstreamId: string
  }

  export type DatasetLineageCountOrderByAggregateInput = {
    id?: SortOrder
    upstreamId?: SortOrder
    downstreamId?: SortOrder
    transformationType?: SortOrder
    transformationLogic?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type DatasetLineageAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type DatasetLineageMaxOrderByAggregateInput = {
    id?: SortOrder
    upstreamId?: SortOrder
    downstreamId?: SortOrder
    transformationType?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type DatasetLineageMinOrderByAggregateInput = {
    id?: SortOrder
    upstreamId?: SortOrder
    downstreamId?: SortOrder
    transformationType?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type DatasetLineageSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumDataConnectorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataConnectorType | EnumDataConnectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataConnectorTypeFilter<$PrismaModel> | $Enums.DataConnectorType
  }

  export type EnumConnectorHealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectorHealthStatus | EnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectorHealthStatusFilter<$PrismaModel> | $Enums.ConnectorHealthStatus
  }

  export type DataConnectorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    config?: SortOrder
    credentials?: SortOrder
    isActive?: SortOrder
    lastHealthCheck?: SortOrder
    healthStatus?: SortOrder
    errorMessage?: SortOrder
    datasets?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataConnectorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    lastHealthCheck?: SortOrder
    healthStatus?: SortOrder
    errorMessage?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataConnectorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    lastHealthCheck?: SortOrder
    healthStatus?: SortOrder
    errorMessage?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDataConnectorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataConnectorType | EnumDataConnectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataConnectorTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataConnectorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataConnectorTypeFilter<$PrismaModel>
    _max?: NestedEnumDataConnectorTypeFilter<$PrismaModel>
  }

  export type EnumConnectorHealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectorHealthStatus | EnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectorHealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConnectorHealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectorHealthStatusFilter<$PrismaModel>
    _max?: NestedEnumConnectorHealthStatusFilter<$PrismaModel>
  }

  export type SchemaMappingDatasetIdNameCompoundUniqueInput = {
    datasetId: string
    name: string
  }

  export type SchemaMappingCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sourceSchema?: SortOrder
    targetSchema?: SortOrder
    mappingRules?: SortOrder
    validationRules?: SortOrder
    isActive?: SortOrder
    lastApplied?: SortOrder
    successRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchemaMappingAvgOrderByAggregateInput = {
    successRate?: SortOrder
  }

  export type SchemaMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    lastApplied?: SortOrder
    successRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchemaMappingMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    lastApplied?: SortOrder
    successRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchemaMappingSumOrderByAggregateInput = {
    successRate?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    changes?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    timestamp?: SortOrder
  }

  export type DistributionScenarioListRelationFilter = {
    every?: DistributionScenarioWhereInput
    some?: DistributionScenarioWhereInput
    none?: DistributionScenarioWhereInput
  }

  export type DistributionScenarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistributionSessionCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    currentScenario?: SortOrder
    presentationMode?: SortOrder
    lastSaved?: SortOrder
    hasUnsavedChanges?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistributionSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    currentScenario?: SortOrder
    presentationMode?: SortOrder
    lastSaved?: SortOrder
    hasUnsavedChanges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistributionSessionMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    currentScenario?: SortOrder
    presentationMode?: SortOrder
    lastSaved?: SortOrder
    hasUnsavedChanges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistributionSessionRelationFilter = {
    is?: DistributionSessionWhereInput
    isNot?: DistributionSessionWhereInput
  }

  export type DistributionScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isBaseline?: SortOrder
    parameters?: SortOrder
    projections?: SortOrder
    lastModified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistributionScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isBaseline?: SortOrder
    lastModified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistributionScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isBaseline?: SortOrder
    lastModified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistributionScenarioRelationFilter = {
    is?: DistributionScenarioWhereInput
    isNot?: DistributionScenarioWhereInput
  }

  export type DistributionChangeCountOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    field?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type DistributionChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    field?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type DistributionChangeMinOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    field?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type DistributionCacheCountOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DistributionCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DistributionCacheMinOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DistributionChangeCreateNestedManyWithoutUserInput = {
    create?: XOR<DistributionChangeCreateWithoutUserInput, DistributionChangeUncheckedCreateWithoutUserInput> | DistributionChangeCreateWithoutUserInput[] | DistributionChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutUserInput | DistributionChangeCreateOrConnectWithoutUserInput[]
    createMany?: DistributionChangeCreateManyUserInputEnvelope
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DistributionChangeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DistributionChangeCreateWithoutUserInput, DistributionChangeUncheckedCreateWithoutUserInput> | DistributionChangeCreateWithoutUserInput[] | DistributionChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutUserInput | DistributionChangeCreateOrConnectWithoutUserInput[]
    createMany?: DistributionChangeCreateManyUserInputEnvelope
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DistributionChangeUpdateManyWithoutUserNestedInput = {
    create?: XOR<DistributionChangeCreateWithoutUserInput, DistributionChangeUncheckedCreateWithoutUserInput> | DistributionChangeCreateWithoutUserInput[] | DistributionChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutUserInput | DistributionChangeCreateOrConnectWithoutUserInput[]
    upsert?: DistributionChangeUpsertWithWhereUniqueWithoutUserInput | DistributionChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DistributionChangeCreateManyUserInputEnvelope
    set?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    disconnect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    delete?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    update?: DistributionChangeUpdateWithWhereUniqueWithoutUserInput | DistributionChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DistributionChangeUpdateManyWithWhereWithoutUserInput | DistributionChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DistributionChangeScalarWhereInput | DistributionChangeScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DistributionChangeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DistributionChangeCreateWithoutUserInput, DistributionChangeUncheckedCreateWithoutUserInput> | DistributionChangeCreateWithoutUserInput[] | DistributionChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutUserInput | DistributionChangeCreateOrConnectWithoutUserInput[]
    upsert?: DistributionChangeUpsertWithWhereUniqueWithoutUserInput | DistributionChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DistributionChangeCreateManyUserInputEnvelope
    set?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    disconnect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    delete?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    update?: DistributionChangeUpdateWithWhereUniqueWithoutUserInput | DistributionChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DistributionChangeUpdateManyWithWhereWithoutUserInput | DistributionChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DistributionChangeScalarWhereInput | DistributionChangeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type RFPCreateNestedManyWithoutCampaignInput = {
    create?: XOR<RFPCreateWithoutCampaignInput, RFPUncheckedCreateWithoutCampaignInput> | RFPCreateWithoutCampaignInput[] | RFPUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RFPCreateOrConnectWithoutCampaignInput | RFPCreateOrConnectWithoutCampaignInput[]
    createMany?: RFPCreateManyCampaignInputEnvelope
    connect?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
  }

  export type CampaignPartnerCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignPartnerCreateWithoutCampaignInput, CampaignPartnerUncheckedCreateWithoutCampaignInput> | CampaignPartnerCreateWithoutCampaignInput[] | CampaignPartnerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutCampaignInput | CampaignPartnerCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignPartnerCreateManyCampaignInputEnvelope
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
  }

  export type DistributionSessionCreateNestedOneWithoutCampaignInput = {
    create?: XOR<DistributionSessionCreateWithoutCampaignInput, DistributionSessionUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: DistributionSessionCreateOrConnectWithoutCampaignInput
    connect?: DistributionSessionWhereUniqueInput
  }

  export type RFPUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<RFPCreateWithoutCampaignInput, RFPUncheckedCreateWithoutCampaignInput> | RFPCreateWithoutCampaignInput[] | RFPUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RFPCreateOrConnectWithoutCampaignInput | RFPCreateOrConnectWithoutCampaignInput[]
    createMany?: RFPCreateManyCampaignInputEnvelope
    connect?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
  }

  export type CampaignPartnerUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignPartnerCreateWithoutCampaignInput, CampaignPartnerUncheckedCreateWithoutCampaignInput> | CampaignPartnerCreateWithoutCampaignInput[] | CampaignPartnerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutCampaignInput | CampaignPartnerCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignPartnerCreateManyCampaignInputEnvelope
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
  }

  export type DistributionSessionUncheckedCreateNestedOneWithoutCampaignInput = {
    create?: XOR<DistributionSessionCreateWithoutCampaignInput, DistributionSessionUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: DistributionSessionCreateOrConnectWithoutCampaignInput
    connect?: DistributionSessionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsInput, UserUpdateWithoutCampaignsInput>, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type RFPUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<RFPCreateWithoutCampaignInput, RFPUncheckedCreateWithoutCampaignInput> | RFPCreateWithoutCampaignInput[] | RFPUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RFPCreateOrConnectWithoutCampaignInput | RFPCreateOrConnectWithoutCampaignInput[]
    upsert?: RFPUpsertWithWhereUniqueWithoutCampaignInput | RFPUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: RFPCreateManyCampaignInputEnvelope
    set?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    disconnect?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    delete?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    connect?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    update?: RFPUpdateWithWhereUniqueWithoutCampaignInput | RFPUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: RFPUpdateManyWithWhereWithoutCampaignInput | RFPUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: RFPScalarWhereInput | RFPScalarWhereInput[]
  }

  export type CampaignPartnerUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignPartnerCreateWithoutCampaignInput, CampaignPartnerUncheckedCreateWithoutCampaignInput> | CampaignPartnerCreateWithoutCampaignInput[] | CampaignPartnerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutCampaignInput | CampaignPartnerCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignPartnerUpsertWithWhereUniqueWithoutCampaignInput | CampaignPartnerUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignPartnerCreateManyCampaignInputEnvelope
    set?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    disconnect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    delete?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    update?: CampaignPartnerUpdateWithWhereUniqueWithoutCampaignInput | CampaignPartnerUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignPartnerUpdateManyWithWhereWithoutCampaignInput | CampaignPartnerUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignPartnerScalarWhereInput | CampaignPartnerScalarWhereInput[]
  }

  export type DistributionSessionUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<DistributionSessionCreateWithoutCampaignInput, DistributionSessionUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: DistributionSessionCreateOrConnectWithoutCampaignInput
    upsert?: DistributionSessionUpsertWithoutCampaignInput
    disconnect?: DistributionSessionWhereInput | boolean
    delete?: DistributionSessionWhereInput | boolean
    connect?: DistributionSessionWhereUniqueInput
    update?: XOR<XOR<DistributionSessionUpdateToOneWithWhereWithoutCampaignInput, DistributionSessionUpdateWithoutCampaignInput>, DistributionSessionUncheckedUpdateWithoutCampaignInput>
  }

  export type RFPUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<RFPCreateWithoutCampaignInput, RFPUncheckedCreateWithoutCampaignInput> | RFPCreateWithoutCampaignInput[] | RFPUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RFPCreateOrConnectWithoutCampaignInput | RFPCreateOrConnectWithoutCampaignInput[]
    upsert?: RFPUpsertWithWhereUniqueWithoutCampaignInput | RFPUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: RFPCreateManyCampaignInputEnvelope
    set?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    disconnect?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    delete?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    connect?: RFPWhereUniqueInput | RFPWhereUniqueInput[]
    update?: RFPUpdateWithWhereUniqueWithoutCampaignInput | RFPUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: RFPUpdateManyWithWhereWithoutCampaignInput | RFPUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: RFPScalarWhereInput | RFPScalarWhereInput[]
  }

  export type CampaignPartnerUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignPartnerCreateWithoutCampaignInput, CampaignPartnerUncheckedCreateWithoutCampaignInput> | CampaignPartnerCreateWithoutCampaignInput[] | CampaignPartnerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutCampaignInput | CampaignPartnerCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignPartnerUpsertWithWhereUniqueWithoutCampaignInput | CampaignPartnerUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignPartnerCreateManyCampaignInputEnvelope
    set?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    disconnect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    delete?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    update?: CampaignPartnerUpdateWithWhereUniqueWithoutCampaignInput | CampaignPartnerUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignPartnerUpdateManyWithWhereWithoutCampaignInput | CampaignPartnerUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignPartnerScalarWhereInput | CampaignPartnerScalarWhereInput[]
  }

  export type DistributionSessionUncheckedUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<DistributionSessionCreateWithoutCampaignInput, DistributionSessionUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: DistributionSessionCreateOrConnectWithoutCampaignInput
    upsert?: DistributionSessionUpsertWithoutCampaignInput
    disconnect?: DistributionSessionWhereInput | boolean
    delete?: DistributionSessionWhereInput | boolean
    connect?: DistributionSessionWhereUniqueInput
    update?: XOR<XOR<DistributionSessionUpdateToOneWithWhereWithoutCampaignInput, DistributionSessionUpdateWithoutCampaignInput>, DistributionSessionUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignCreateNestedOneWithoutRfpsInput = {
    create?: XOR<CampaignCreateWithoutRfpsInput, CampaignUncheckedCreateWithoutRfpsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRfpsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutRfpsNestedInput = {
    create?: XOR<CampaignCreateWithoutRfpsInput, CampaignUncheckedCreateWithoutRfpsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRfpsInput
    upsert?: CampaignUpsertWithoutRfpsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRfpsInput, CampaignUpdateWithoutRfpsInput>, CampaignUncheckedUpdateWithoutRfpsInput>
  }

  export type PartnerCapabilityCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerCapabilityCreateWithoutPartnerInput, PartnerCapabilityUncheckedCreateWithoutPartnerInput> | PartnerCapabilityCreateWithoutPartnerInput[] | PartnerCapabilityUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerCapabilityCreateOrConnectWithoutPartnerInput | PartnerCapabilityCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerCapabilityCreateManyPartnerInputEnvelope
    connect?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
  }

  export type CreativeSpecCreateNestedManyWithoutPartnerInput = {
    create?: XOR<CreativeSpecCreateWithoutPartnerInput, CreativeSpecUncheckedCreateWithoutPartnerInput> | CreativeSpecCreateWithoutPartnerInput[] | CreativeSpecUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CreativeSpecCreateOrConnectWithoutPartnerInput | CreativeSpecCreateOrConnectWithoutPartnerInput[]
    createMany?: CreativeSpecCreateManyPartnerInputEnvelope
    connect?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
  }

  export type PartnerHealthMetricCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerHealthMetricCreateWithoutPartnerInput, PartnerHealthMetricUncheckedCreateWithoutPartnerInput> | PartnerHealthMetricCreateWithoutPartnerInput[] | PartnerHealthMetricUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerHealthMetricCreateOrConnectWithoutPartnerInput | PartnerHealthMetricCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerHealthMetricCreateManyPartnerInputEnvelope
    connect?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
  }

  export type CampaignPartnerCreateNestedManyWithoutPartnerInput = {
    create?: XOR<CampaignPartnerCreateWithoutPartnerInput, CampaignPartnerUncheckedCreateWithoutPartnerInput> | CampaignPartnerCreateWithoutPartnerInput[] | CampaignPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutPartnerInput | CampaignPartnerCreateOrConnectWithoutPartnerInput[]
    createMany?: CampaignPartnerCreateManyPartnerInputEnvelope
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
  }

  export type PartnerCapabilityUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerCapabilityCreateWithoutPartnerInput, PartnerCapabilityUncheckedCreateWithoutPartnerInput> | PartnerCapabilityCreateWithoutPartnerInput[] | PartnerCapabilityUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerCapabilityCreateOrConnectWithoutPartnerInput | PartnerCapabilityCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerCapabilityCreateManyPartnerInputEnvelope
    connect?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
  }

  export type CreativeSpecUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<CreativeSpecCreateWithoutPartnerInput, CreativeSpecUncheckedCreateWithoutPartnerInput> | CreativeSpecCreateWithoutPartnerInput[] | CreativeSpecUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CreativeSpecCreateOrConnectWithoutPartnerInput | CreativeSpecCreateOrConnectWithoutPartnerInput[]
    createMany?: CreativeSpecCreateManyPartnerInputEnvelope
    connect?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
  }

  export type PartnerHealthMetricUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerHealthMetricCreateWithoutPartnerInput, PartnerHealthMetricUncheckedCreateWithoutPartnerInput> | PartnerHealthMetricCreateWithoutPartnerInput[] | PartnerHealthMetricUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerHealthMetricCreateOrConnectWithoutPartnerInput | PartnerHealthMetricCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerHealthMetricCreateManyPartnerInputEnvelope
    connect?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
  }

  export type CampaignPartnerUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<CampaignPartnerCreateWithoutPartnerInput, CampaignPartnerUncheckedCreateWithoutPartnerInput> | CampaignPartnerCreateWithoutPartnerInput[] | CampaignPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutPartnerInput | CampaignPartnerCreateOrConnectWithoutPartnerInput[]
    createMany?: CampaignPartnerCreateManyPartnerInputEnvelope
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
  }

  export type EnumPartnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartnerType
  }

  export type EnumPartnerStatusFieldUpdateOperationsInput = {
    set?: $Enums.PartnerStatus
  }

  export type EnumOnboardingStatusFieldUpdateOperationsInput = {
    set?: $Enums.OnboardingStatus
  }

  export type PartnerCapabilityUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerCapabilityCreateWithoutPartnerInput, PartnerCapabilityUncheckedCreateWithoutPartnerInput> | PartnerCapabilityCreateWithoutPartnerInput[] | PartnerCapabilityUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerCapabilityCreateOrConnectWithoutPartnerInput | PartnerCapabilityCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerCapabilityUpsertWithWhereUniqueWithoutPartnerInput | PartnerCapabilityUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerCapabilityCreateManyPartnerInputEnvelope
    set?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    disconnect?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    delete?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    connect?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    update?: PartnerCapabilityUpdateWithWhereUniqueWithoutPartnerInput | PartnerCapabilityUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerCapabilityUpdateManyWithWhereWithoutPartnerInput | PartnerCapabilityUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerCapabilityScalarWhereInput | PartnerCapabilityScalarWhereInput[]
  }

  export type CreativeSpecUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<CreativeSpecCreateWithoutPartnerInput, CreativeSpecUncheckedCreateWithoutPartnerInput> | CreativeSpecCreateWithoutPartnerInput[] | CreativeSpecUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CreativeSpecCreateOrConnectWithoutPartnerInput | CreativeSpecCreateOrConnectWithoutPartnerInput[]
    upsert?: CreativeSpecUpsertWithWhereUniqueWithoutPartnerInput | CreativeSpecUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: CreativeSpecCreateManyPartnerInputEnvelope
    set?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    disconnect?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    delete?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    connect?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    update?: CreativeSpecUpdateWithWhereUniqueWithoutPartnerInput | CreativeSpecUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: CreativeSpecUpdateManyWithWhereWithoutPartnerInput | CreativeSpecUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: CreativeSpecScalarWhereInput | CreativeSpecScalarWhereInput[]
  }

  export type PartnerHealthMetricUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerHealthMetricCreateWithoutPartnerInput, PartnerHealthMetricUncheckedCreateWithoutPartnerInput> | PartnerHealthMetricCreateWithoutPartnerInput[] | PartnerHealthMetricUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerHealthMetricCreateOrConnectWithoutPartnerInput | PartnerHealthMetricCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerHealthMetricUpsertWithWhereUniqueWithoutPartnerInput | PartnerHealthMetricUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerHealthMetricCreateManyPartnerInputEnvelope
    set?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    disconnect?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    delete?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    connect?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    update?: PartnerHealthMetricUpdateWithWhereUniqueWithoutPartnerInput | PartnerHealthMetricUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerHealthMetricUpdateManyWithWhereWithoutPartnerInput | PartnerHealthMetricUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerHealthMetricScalarWhereInput | PartnerHealthMetricScalarWhereInput[]
  }

  export type CampaignPartnerUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<CampaignPartnerCreateWithoutPartnerInput, CampaignPartnerUncheckedCreateWithoutPartnerInput> | CampaignPartnerCreateWithoutPartnerInput[] | CampaignPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutPartnerInput | CampaignPartnerCreateOrConnectWithoutPartnerInput[]
    upsert?: CampaignPartnerUpsertWithWhereUniqueWithoutPartnerInput | CampaignPartnerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: CampaignPartnerCreateManyPartnerInputEnvelope
    set?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    disconnect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    delete?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    update?: CampaignPartnerUpdateWithWhereUniqueWithoutPartnerInput | CampaignPartnerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: CampaignPartnerUpdateManyWithWhereWithoutPartnerInput | CampaignPartnerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: CampaignPartnerScalarWhereInput | CampaignPartnerScalarWhereInput[]
  }

  export type PartnerCapabilityUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerCapabilityCreateWithoutPartnerInput, PartnerCapabilityUncheckedCreateWithoutPartnerInput> | PartnerCapabilityCreateWithoutPartnerInput[] | PartnerCapabilityUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerCapabilityCreateOrConnectWithoutPartnerInput | PartnerCapabilityCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerCapabilityUpsertWithWhereUniqueWithoutPartnerInput | PartnerCapabilityUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerCapabilityCreateManyPartnerInputEnvelope
    set?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    disconnect?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    delete?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    connect?: PartnerCapabilityWhereUniqueInput | PartnerCapabilityWhereUniqueInput[]
    update?: PartnerCapabilityUpdateWithWhereUniqueWithoutPartnerInput | PartnerCapabilityUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerCapabilityUpdateManyWithWhereWithoutPartnerInput | PartnerCapabilityUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerCapabilityScalarWhereInput | PartnerCapabilityScalarWhereInput[]
  }

  export type CreativeSpecUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<CreativeSpecCreateWithoutPartnerInput, CreativeSpecUncheckedCreateWithoutPartnerInput> | CreativeSpecCreateWithoutPartnerInput[] | CreativeSpecUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CreativeSpecCreateOrConnectWithoutPartnerInput | CreativeSpecCreateOrConnectWithoutPartnerInput[]
    upsert?: CreativeSpecUpsertWithWhereUniqueWithoutPartnerInput | CreativeSpecUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: CreativeSpecCreateManyPartnerInputEnvelope
    set?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    disconnect?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    delete?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    connect?: CreativeSpecWhereUniqueInput | CreativeSpecWhereUniqueInput[]
    update?: CreativeSpecUpdateWithWhereUniqueWithoutPartnerInput | CreativeSpecUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: CreativeSpecUpdateManyWithWhereWithoutPartnerInput | CreativeSpecUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: CreativeSpecScalarWhereInput | CreativeSpecScalarWhereInput[]
  }

  export type PartnerHealthMetricUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerHealthMetricCreateWithoutPartnerInput, PartnerHealthMetricUncheckedCreateWithoutPartnerInput> | PartnerHealthMetricCreateWithoutPartnerInput[] | PartnerHealthMetricUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerHealthMetricCreateOrConnectWithoutPartnerInput | PartnerHealthMetricCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerHealthMetricUpsertWithWhereUniqueWithoutPartnerInput | PartnerHealthMetricUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerHealthMetricCreateManyPartnerInputEnvelope
    set?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    disconnect?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    delete?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    connect?: PartnerHealthMetricWhereUniqueInput | PartnerHealthMetricWhereUniqueInput[]
    update?: PartnerHealthMetricUpdateWithWhereUniqueWithoutPartnerInput | PartnerHealthMetricUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerHealthMetricUpdateManyWithWhereWithoutPartnerInput | PartnerHealthMetricUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerHealthMetricScalarWhereInput | PartnerHealthMetricScalarWhereInput[]
  }

  export type CampaignPartnerUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<CampaignPartnerCreateWithoutPartnerInput, CampaignPartnerUncheckedCreateWithoutPartnerInput> | CampaignPartnerCreateWithoutPartnerInput[] | CampaignPartnerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CampaignPartnerCreateOrConnectWithoutPartnerInput | CampaignPartnerCreateOrConnectWithoutPartnerInput[]
    upsert?: CampaignPartnerUpsertWithWhereUniqueWithoutPartnerInput | CampaignPartnerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: CampaignPartnerCreateManyPartnerInputEnvelope
    set?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    disconnect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    delete?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    connect?: CampaignPartnerWhereUniqueInput | CampaignPartnerWhereUniqueInput[]
    update?: CampaignPartnerUpdateWithWhereUniqueWithoutPartnerInput | CampaignPartnerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: CampaignPartnerUpdateManyWithWhereWithoutPartnerInput | CampaignPartnerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: CampaignPartnerScalarWhereInput | CampaignPartnerScalarWhereInput[]
  }

  export type PartnerCreateNestedOneWithoutCapabilitiesInput = {
    create?: XOR<PartnerCreateWithoutCapabilitiesInput, PartnerUncheckedCreateWithoutCapabilitiesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCapabilitiesInput
    connect?: PartnerWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumCapabilitySourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.CapabilitySourceType
  }

  export type PartnerUpdateOneRequiredWithoutCapabilitiesNestedInput = {
    create?: XOR<PartnerCreateWithoutCapabilitiesInput, PartnerUncheckedCreateWithoutCapabilitiesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCapabilitiesInput
    upsert?: PartnerUpsertWithoutCapabilitiesInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutCapabilitiesInput, PartnerUpdateWithoutCapabilitiesInput>, PartnerUncheckedUpdateWithoutCapabilitiesInput>
  }

  export type PartnerCreateNestedOneWithoutCreativeSpecsInput = {
    create?: XOR<PartnerCreateWithoutCreativeSpecsInput, PartnerUncheckedCreateWithoutCreativeSpecsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCreativeSpecsInput
    connect?: PartnerWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PartnerUpdateOneRequiredWithoutCreativeSpecsNestedInput = {
    create?: XOR<PartnerCreateWithoutCreativeSpecsInput, PartnerUncheckedCreateWithoutCreativeSpecsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCreativeSpecsInput
    upsert?: PartnerUpsertWithoutCreativeSpecsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutCreativeSpecsInput, PartnerUpdateWithoutCreativeSpecsInput>, PartnerUncheckedUpdateWithoutCreativeSpecsInput>
  }

  export type PartnerCreateNestedOneWithoutHealthMetricsInput = {
    create?: XOR<PartnerCreateWithoutHealthMetricsInput, PartnerUncheckedCreateWithoutHealthMetricsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutHealthMetricsInput
    connect?: PartnerWhereUniqueInput
  }

  export type EnumApiStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApiStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PartnerUpdateOneRequiredWithoutHealthMetricsNestedInput = {
    create?: XOR<PartnerCreateWithoutHealthMetricsInput, PartnerUncheckedCreateWithoutHealthMetricsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutHealthMetricsInput
    upsert?: PartnerUpsertWithoutHealthMetricsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutHealthMetricsInput, PartnerUpdateWithoutHealthMetricsInput>, PartnerUncheckedUpdateWithoutHealthMetricsInput>
  }

  export type CampaignCreateNestedOneWithoutPartnerAssociationsInput = {
    create?: XOR<CampaignCreateWithoutPartnerAssociationsInput, CampaignUncheckedCreateWithoutPartnerAssociationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPartnerAssociationsInput
    connect?: CampaignWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutCampaignAssociationsInput = {
    create?: XOR<PartnerCreateWithoutCampaignAssociationsInput, PartnerUncheckedCreateWithoutCampaignAssociationsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCampaignAssociationsInput
    connect?: PartnerWhereUniqueInput
  }

  export type EnumCampaignPartnerStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignPartnerStatus
  }

  export type CampaignUpdateOneRequiredWithoutPartnerAssociationsNestedInput = {
    create?: XOR<CampaignCreateWithoutPartnerAssociationsInput, CampaignUncheckedCreateWithoutPartnerAssociationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPartnerAssociationsInput
    upsert?: CampaignUpsertWithoutPartnerAssociationsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutPartnerAssociationsInput, CampaignUpdateWithoutPartnerAssociationsInput>, CampaignUncheckedUpdateWithoutPartnerAssociationsInput>
  }

  export type PartnerUpdateOneRequiredWithoutCampaignAssociationsNestedInput = {
    create?: XOR<PartnerCreateWithoutCampaignAssociationsInput, PartnerUncheckedCreateWithoutCampaignAssociationsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCampaignAssociationsInput
    upsert?: PartnerUpsertWithoutCampaignAssociationsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutCampaignAssociationsInput, PartnerUpdateWithoutCampaignAssociationsInput>, PartnerUncheckedUpdateWithoutCampaignAssociationsInput>
  }

  export type DatasetCreatetagsInput = {
    set: string[]
  }

  export type DatasetVersionCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetVersionCreateWithoutDatasetInput, DatasetVersionUncheckedCreateWithoutDatasetInput> | DatasetVersionCreateWithoutDatasetInput[] | DatasetVersionUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetVersionCreateOrConnectWithoutDatasetInput | DatasetVersionCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetVersionCreateManyDatasetInputEnvelope
    connect?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
  }

  export type DataQualityReportCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DataQualityReportCreateWithoutDatasetInput, DataQualityReportUncheckedCreateWithoutDatasetInput> | DataQualityReportCreateWithoutDatasetInput[] | DataQualityReportUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DataQualityReportCreateOrConnectWithoutDatasetInput | DataQualityReportCreateOrConnectWithoutDatasetInput[]
    createMany?: DataQualityReportCreateManyDatasetInputEnvelope
    connect?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
  }

  export type IngestionJobCreateNestedManyWithoutDatasetInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
  }

  export type DatasetLineageCreateNestedManyWithoutUpstreamInput = {
    create?: XOR<DatasetLineageCreateWithoutUpstreamInput, DatasetLineageUncheckedCreateWithoutUpstreamInput> | DatasetLineageCreateWithoutUpstreamInput[] | DatasetLineageUncheckedCreateWithoutUpstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutUpstreamInput | DatasetLineageCreateOrConnectWithoutUpstreamInput[]
    createMany?: DatasetLineageCreateManyUpstreamInputEnvelope
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
  }

  export type DatasetLineageCreateNestedManyWithoutDownstreamInput = {
    create?: XOR<DatasetLineageCreateWithoutDownstreamInput, DatasetLineageUncheckedCreateWithoutDownstreamInput> | DatasetLineageCreateWithoutDownstreamInput[] | DatasetLineageUncheckedCreateWithoutDownstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutDownstreamInput | DatasetLineageCreateOrConnectWithoutDownstreamInput[]
    createMany?: DatasetLineageCreateManyDownstreamInputEnvelope
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
  }

  export type DatasetVersionUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetVersionCreateWithoutDatasetInput, DatasetVersionUncheckedCreateWithoutDatasetInput> | DatasetVersionCreateWithoutDatasetInput[] | DatasetVersionUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetVersionCreateOrConnectWithoutDatasetInput | DatasetVersionCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetVersionCreateManyDatasetInputEnvelope
    connect?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
  }

  export type DataQualityReportUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DataQualityReportCreateWithoutDatasetInput, DataQualityReportUncheckedCreateWithoutDatasetInput> | DataQualityReportCreateWithoutDatasetInput[] | DataQualityReportUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DataQualityReportCreateOrConnectWithoutDatasetInput | DataQualityReportCreateOrConnectWithoutDatasetInput[]
    createMany?: DataQualityReportCreateManyDatasetInputEnvelope
    connect?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
  }

  export type IngestionJobUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
  }

  export type DatasetLineageUncheckedCreateNestedManyWithoutUpstreamInput = {
    create?: XOR<DatasetLineageCreateWithoutUpstreamInput, DatasetLineageUncheckedCreateWithoutUpstreamInput> | DatasetLineageCreateWithoutUpstreamInput[] | DatasetLineageUncheckedCreateWithoutUpstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutUpstreamInput | DatasetLineageCreateOrConnectWithoutUpstreamInput[]
    createMany?: DatasetLineageCreateManyUpstreamInputEnvelope
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
  }

  export type DatasetLineageUncheckedCreateNestedManyWithoutDownstreamInput = {
    create?: XOR<DatasetLineageCreateWithoutDownstreamInput, DatasetLineageUncheckedCreateWithoutDownstreamInput> | DatasetLineageCreateWithoutDownstreamInput[] | DatasetLineageUncheckedCreateWithoutDownstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutDownstreamInput | DatasetLineageCreateOrConnectWithoutDownstreamInput[]
    createMany?: DatasetLineageCreateManyDownstreamInputEnvelope
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
  }

  export type EnumDatasetCategoryFieldUpdateOperationsInput = {
    set?: $Enums.DatasetCategory
  }

  export type EnumDatasetSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DatasetSourceType
  }

  export type EnumUpdateFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.UpdateFrequency
  }

  export type EnumDatasetStatusFieldUpdateOperationsInput = {
    set?: $Enums.DatasetStatus
  }

  export type DatasetUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DatasetVersionUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetVersionCreateWithoutDatasetInput, DatasetVersionUncheckedCreateWithoutDatasetInput> | DatasetVersionCreateWithoutDatasetInput[] | DatasetVersionUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetVersionCreateOrConnectWithoutDatasetInput | DatasetVersionCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetVersionUpsertWithWhereUniqueWithoutDatasetInput | DatasetVersionUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetVersionCreateManyDatasetInputEnvelope
    set?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    disconnect?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    delete?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    connect?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    update?: DatasetVersionUpdateWithWhereUniqueWithoutDatasetInput | DatasetVersionUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetVersionUpdateManyWithWhereWithoutDatasetInput | DatasetVersionUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetVersionScalarWhereInput | DatasetVersionScalarWhereInput[]
  }

  export type DataQualityReportUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DataQualityReportCreateWithoutDatasetInput, DataQualityReportUncheckedCreateWithoutDatasetInput> | DataQualityReportCreateWithoutDatasetInput[] | DataQualityReportUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DataQualityReportCreateOrConnectWithoutDatasetInput | DataQualityReportCreateOrConnectWithoutDatasetInput[]
    upsert?: DataQualityReportUpsertWithWhereUniqueWithoutDatasetInput | DataQualityReportUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DataQualityReportCreateManyDatasetInputEnvelope
    set?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    disconnect?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    delete?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    connect?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    update?: DataQualityReportUpdateWithWhereUniqueWithoutDatasetInput | DataQualityReportUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DataQualityReportUpdateManyWithWhereWithoutDatasetInput | DataQualityReportUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DataQualityReportScalarWhereInput | DataQualityReportScalarWhereInput[]
  }

  export type IngestionJobUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    upsert?: IngestionJobUpsertWithWhereUniqueWithoutDatasetInput | IngestionJobUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    set?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    disconnect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    delete?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    update?: IngestionJobUpdateWithWhereUniqueWithoutDatasetInput | IngestionJobUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: IngestionJobUpdateManyWithWhereWithoutDatasetInput | IngestionJobUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
  }

  export type DatasetLineageUpdateManyWithoutUpstreamNestedInput = {
    create?: XOR<DatasetLineageCreateWithoutUpstreamInput, DatasetLineageUncheckedCreateWithoutUpstreamInput> | DatasetLineageCreateWithoutUpstreamInput[] | DatasetLineageUncheckedCreateWithoutUpstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutUpstreamInput | DatasetLineageCreateOrConnectWithoutUpstreamInput[]
    upsert?: DatasetLineageUpsertWithWhereUniqueWithoutUpstreamInput | DatasetLineageUpsertWithWhereUniqueWithoutUpstreamInput[]
    createMany?: DatasetLineageCreateManyUpstreamInputEnvelope
    set?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    disconnect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    delete?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    update?: DatasetLineageUpdateWithWhereUniqueWithoutUpstreamInput | DatasetLineageUpdateWithWhereUniqueWithoutUpstreamInput[]
    updateMany?: DatasetLineageUpdateManyWithWhereWithoutUpstreamInput | DatasetLineageUpdateManyWithWhereWithoutUpstreamInput[]
    deleteMany?: DatasetLineageScalarWhereInput | DatasetLineageScalarWhereInput[]
  }

  export type DatasetLineageUpdateManyWithoutDownstreamNestedInput = {
    create?: XOR<DatasetLineageCreateWithoutDownstreamInput, DatasetLineageUncheckedCreateWithoutDownstreamInput> | DatasetLineageCreateWithoutDownstreamInput[] | DatasetLineageUncheckedCreateWithoutDownstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutDownstreamInput | DatasetLineageCreateOrConnectWithoutDownstreamInput[]
    upsert?: DatasetLineageUpsertWithWhereUniqueWithoutDownstreamInput | DatasetLineageUpsertWithWhereUniqueWithoutDownstreamInput[]
    createMany?: DatasetLineageCreateManyDownstreamInputEnvelope
    set?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    disconnect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    delete?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    update?: DatasetLineageUpdateWithWhereUniqueWithoutDownstreamInput | DatasetLineageUpdateWithWhereUniqueWithoutDownstreamInput[]
    updateMany?: DatasetLineageUpdateManyWithWhereWithoutDownstreamInput | DatasetLineageUpdateManyWithWhereWithoutDownstreamInput[]
    deleteMany?: DatasetLineageScalarWhereInput | DatasetLineageScalarWhereInput[]
  }

  export type DatasetVersionUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetVersionCreateWithoutDatasetInput, DatasetVersionUncheckedCreateWithoutDatasetInput> | DatasetVersionCreateWithoutDatasetInput[] | DatasetVersionUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetVersionCreateOrConnectWithoutDatasetInput | DatasetVersionCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetVersionUpsertWithWhereUniqueWithoutDatasetInput | DatasetVersionUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetVersionCreateManyDatasetInputEnvelope
    set?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    disconnect?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    delete?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    connect?: DatasetVersionWhereUniqueInput | DatasetVersionWhereUniqueInput[]
    update?: DatasetVersionUpdateWithWhereUniqueWithoutDatasetInput | DatasetVersionUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetVersionUpdateManyWithWhereWithoutDatasetInput | DatasetVersionUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetVersionScalarWhereInput | DatasetVersionScalarWhereInput[]
  }

  export type DataQualityReportUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DataQualityReportCreateWithoutDatasetInput, DataQualityReportUncheckedCreateWithoutDatasetInput> | DataQualityReportCreateWithoutDatasetInput[] | DataQualityReportUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DataQualityReportCreateOrConnectWithoutDatasetInput | DataQualityReportCreateOrConnectWithoutDatasetInput[]
    upsert?: DataQualityReportUpsertWithWhereUniqueWithoutDatasetInput | DataQualityReportUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DataQualityReportCreateManyDatasetInputEnvelope
    set?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    disconnect?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    delete?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    connect?: DataQualityReportWhereUniqueInput | DataQualityReportWhereUniqueInput[]
    update?: DataQualityReportUpdateWithWhereUniqueWithoutDatasetInput | DataQualityReportUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DataQualityReportUpdateManyWithWhereWithoutDatasetInput | DataQualityReportUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DataQualityReportScalarWhereInput | DataQualityReportScalarWhereInput[]
  }

  export type IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    upsert?: IngestionJobUpsertWithWhereUniqueWithoutDatasetInput | IngestionJobUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    set?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    disconnect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    delete?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    update?: IngestionJobUpdateWithWhereUniqueWithoutDatasetInput | IngestionJobUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: IngestionJobUpdateManyWithWhereWithoutDatasetInput | IngestionJobUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
  }

  export type DatasetLineageUncheckedUpdateManyWithoutUpstreamNestedInput = {
    create?: XOR<DatasetLineageCreateWithoutUpstreamInput, DatasetLineageUncheckedCreateWithoutUpstreamInput> | DatasetLineageCreateWithoutUpstreamInput[] | DatasetLineageUncheckedCreateWithoutUpstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutUpstreamInput | DatasetLineageCreateOrConnectWithoutUpstreamInput[]
    upsert?: DatasetLineageUpsertWithWhereUniqueWithoutUpstreamInput | DatasetLineageUpsertWithWhereUniqueWithoutUpstreamInput[]
    createMany?: DatasetLineageCreateManyUpstreamInputEnvelope
    set?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    disconnect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    delete?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    update?: DatasetLineageUpdateWithWhereUniqueWithoutUpstreamInput | DatasetLineageUpdateWithWhereUniqueWithoutUpstreamInput[]
    updateMany?: DatasetLineageUpdateManyWithWhereWithoutUpstreamInput | DatasetLineageUpdateManyWithWhereWithoutUpstreamInput[]
    deleteMany?: DatasetLineageScalarWhereInput | DatasetLineageScalarWhereInput[]
  }

  export type DatasetLineageUncheckedUpdateManyWithoutDownstreamNestedInput = {
    create?: XOR<DatasetLineageCreateWithoutDownstreamInput, DatasetLineageUncheckedCreateWithoutDownstreamInput> | DatasetLineageCreateWithoutDownstreamInput[] | DatasetLineageUncheckedCreateWithoutDownstreamInput[]
    connectOrCreate?: DatasetLineageCreateOrConnectWithoutDownstreamInput | DatasetLineageCreateOrConnectWithoutDownstreamInput[]
    upsert?: DatasetLineageUpsertWithWhereUniqueWithoutDownstreamInput | DatasetLineageUpsertWithWhereUniqueWithoutDownstreamInput[]
    createMany?: DatasetLineageCreateManyDownstreamInputEnvelope
    set?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    disconnect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    delete?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    connect?: DatasetLineageWhereUniqueInput | DatasetLineageWhereUniqueInput[]
    update?: DatasetLineageUpdateWithWhereUniqueWithoutDownstreamInput | DatasetLineageUpdateWithWhereUniqueWithoutDownstreamInput[]
    updateMany?: DatasetLineageUpdateManyWithWhereWithoutDownstreamInput | DatasetLineageUpdateManyWithWhereWithoutDownstreamInput[]
    deleteMany?: DatasetLineageScalarWhereInput | DatasetLineageScalarWhereInput[]
  }

  export type DatasetCreateNestedOneWithoutVersionsInput = {
    create?: XOR<DatasetCreateWithoutVersionsInput, DatasetUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutVersionsInput
    connect?: DatasetWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DatasetUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<DatasetCreateWithoutVersionsInput, DatasetUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutVersionsInput
    upsert?: DatasetUpsertWithoutVersionsInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutVersionsInput, DatasetUpdateWithoutVersionsInput>, DatasetUncheckedUpdateWithoutVersionsInput>
  }

  export type DatasetCreateNestedOneWithoutQualityReportsInput = {
    create?: XOR<DatasetCreateWithoutQualityReportsInput, DatasetUncheckedCreateWithoutQualityReportsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutQualityReportsInput
    connect?: DatasetWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DatasetUpdateOneRequiredWithoutQualityReportsNestedInput = {
    create?: XOR<DatasetCreateWithoutQualityReportsInput, DatasetUncheckedCreateWithoutQualityReportsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutQualityReportsInput
    upsert?: DatasetUpsertWithoutQualityReportsInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutQualityReportsInput, DatasetUpdateWithoutQualityReportsInput>, DatasetUncheckedUpdateWithoutQualityReportsInput>
  }

  export type DatasetCreateNestedOneWithoutIngestionJobsInput = {
    create?: XOR<DatasetCreateWithoutIngestionJobsInput, DatasetUncheckedCreateWithoutIngestionJobsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutIngestionJobsInput
    connect?: DatasetWhereUniqueInput
  }

  export type EnumIngestionJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.IngestionJobType
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type DatasetUpdateOneRequiredWithoutIngestionJobsNestedInput = {
    create?: XOR<DatasetCreateWithoutIngestionJobsInput, DatasetUncheckedCreateWithoutIngestionJobsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutIngestionJobsInput
    upsert?: DatasetUpsertWithoutIngestionJobsInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutIngestionJobsInput, DatasetUpdateWithoutIngestionJobsInput>, DatasetUncheckedUpdateWithoutIngestionJobsInput>
  }

  export type DatasetCreateNestedOneWithoutLineageUpstreamInput = {
    create?: XOR<DatasetCreateWithoutLineageUpstreamInput, DatasetUncheckedCreateWithoutLineageUpstreamInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutLineageUpstreamInput
    connect?: DatasetWhereUniqueInput
  }

  export type DatasetCreateNestedOneWithoutLineageDownstreamInput = {
    create?: XOR<DatasetCreateWithoutLineageDownstreamInput, DatasetUncheckedCreateWithoutLineageDownstreamInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutLineageDownstreamInput
    connect?: DatasetWhereUniqueInput
  }

  export type DatasetUpdateOneRequiredWithoutLineageUpstreamNestedInput = {
    create?: XOR<DatasetCreateWithoutLineageUpstreamInput, DatasetUncheckedCreateWithoutLineageUpstreamInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutLineageUpstreamInput
    upsert?: DatasetUpsertWithoutLineageUpstreamInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutLineageUpstreamInput, DatasetUpdateWithoutLineageUpstreamInput>, DatasetUncheckedUpdateWithoutLineageUpstreamInput>
  }

  export type DatasetUpdateOneRequiredWithoutLineageDownstreamNestedInput = {
    create?: XOR<DatasetCreateWithoutLineageDownstreamInput, DatasetUncheckedCreateWithoutLineageDownstreamInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutLineageDownstreamInput
    upsert?: DatasetUpsertWithoutLineageDownstreamInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutLineageDownstreamInput, DatasetUpdateWithoutLineageDownstreamInput>, DatasetUncheckedUpdateWithoutLineageDownstreamInput>
  }

  export type DataConnectorCreatedatasetsInput = {
    set: string[]
  }

  export type EnumDataConnectorTypeFieldUpdateOperationsInput = {
    set?: $Enums.DataConnectorType
  }

  export type EnumConnectorHealthStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConnectorHealthStatus
  }

  export type DataConnectorUpdatedatasetsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CampaignCreateNestedOneWithoutDistributionSessionInput = {
    create?: XOR<CampaignCreateWithoutDistributionSessionInput, CampaignUncheckedCreateWithoutDistributionSessionInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDistributionSessionInput
    connect?: CampaignWhereUniqueInput
  }

  export type DistributionScenarioCreateNestedManyWithoutSessionInput = {
    create?: XOR<DistributionScenarioCreateWithoutSessionInput, DistributionScenarioUncheckedCreateWithoutSessionInput> | DistributionScenarioCreateWithoutSessionInput[] | DistributionScenarioUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: DistributionScenarioCreateOrConnectWithoutSessionInput | DistributionScenarioCreateOrConnectWithoutSessionInput[]
    createMany?: DistributionScenarioCreateManySessionInputEnvelope
    connect?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
  }

  export type DistributionScenarioUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<DistributionScenarioCreateWithoutSessionInput, DistributionScenarioUncheckedCreateWithoutSessionInput> | DistributionScenarioCreateWithoutSessionInput[] | DistributionScenarioUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: DistributionScenarioCreateOrConnectWithoutSessionInput | DistributionScenarioCreateOrConnectWithoutSessionInput[]
    createMany?: DistributionScenarioCreateManySessionInputEnvelope
    connect?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutDistributionSessionNestedInput = {
    create?: XOR<CampaignCreateWithoutDistributionSessionInput, CampaignUncheckedCreateWithoutDistributionSessionInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDistributionSessionInput
    upsert?: CampaignUpsertWithoutDistributionSessionInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutDistributionSessionInput, CampaignUpdateWithoutDistributionSessionInput>, CampaignUncheckedUpdateWithoutDistributionSessionInput>
  }

  export type DistributionScenarioUpdateManyWithoutSessionNestedInput = {
    create?: XOR<DistributionScenarioCreateWithoutSessionInput, DistributionScenarioUncheckedCreateWithoutSessionInput> | DistributionScenarioCreateWithoutSessionInput[] | DistributionScenarioUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: DistributionScenarioCreateOrConnectWithoutSessionInput | DistributionScenarioCreateOrConnectWithoutSessionInput[]
    upsert?: DistributionScenarioUpsertWithWhereUniqueWithoutSessionInput | DistributionScenarioUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: DistributionScenarioCreateManySessionInputEnvelope
    set?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    disconnect?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    delete?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    connect?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    update?: DistributionScenarioUpdateWithWhereUniqueWithoutSessionInput | DistributionScenarioUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: DistributionScenarioUpdateManyWithWhereWithoutSessionInput | DistributionScenarioUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: DistributionScenarioScalarWhereInput | DistributionScenarioScalarWhereInput[]
  }

  export type DistributionScenarioUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<DistributionScenarioCreateWithoutSessionInput, DistributionScenarioUncheckedCreateWithoutSessionInput> | DistributionScenarioCreateWithoutSessionInput[] | DistributionScenarioUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: DistributionScenarioCreateOrConnectWithoutSessionInput | DistributionScenarioCreateOrConnectWithoutSessionInput[]
    upsert?: DistributionScenarioUpsertWithWhereUniqueWithoutSessionInput | DistributionScenarioUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: DistributionScenarioCreateManySessionInputEnvelope
    set?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    disconnect?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    delete?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    connect?: DistributionScenarioWhereUniqueInput | DistributionScenarioWhereUniqueInput[]
    update?: DistributionScenarioUpdateWithWhereUniqueWithoutSessionInput | DistributionScenarioUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: DistributionScenarioUpdateManyWithWhereWithoutSessionInput | DistributionScenarioUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: DistributionScenarioScalarWhereInput | DistributionScenarioScalarWhereInput[]
  }

  export type DistributionSessionCreateNestedOneWithoutScenariosInput = {
    create?: XOR<DistributionSessionCreateWithoutScenariosInput, DistributionSessionUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: DistributionSessionCreateOrConnectWithoutScenariosInput
    connect?: DistributionSessionWhereUniqueInput
  }

  export type DistributionChangeCreateNestedManyWithoutScenarioInput = {
    create?: XOR<DistributionChangeCreateWithoutScenarioInput, DistributionChangeUncheckedCreateWithoutScenarioInput> | DistributionChangeCreateWithoutScenarioInput[] | DistributionChangeUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutScenarioInput | DistributionChangeCreateOrConnectWithoutScenarioInput[]
    createMany?: DistributionChangeCreateManyScenarioInputEnvelope
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
  }

  export type DistributionChangeUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<DistributionChangeCreateWithoutScenarioInput, DistributionChangeUncheckedCreateWithoutScenarioInput> | DistributionChangeCreateWithoutScenarioInput[] | DistributionChangeUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutScenarioInput | DistributionChangeCreateOrConnectWithoutScenarioInput[]
    createMany?: DistributionChangeCreateManyScenarioInputEnvelope
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
  }

  export type DistributionSessionUpdateOneRequiredWithoutScenariosNestedInput = {
    create?: XOR<DistributionSessionCreateWithoutScenariosInput, DistributionSessionUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: DistributionSessionCreateOrConnectWithoutScenariosInput
    upsert?: DistributionSessionUpsertWithoutScenariosInput
    connect?: DistributionSessionWhereUniqueInput
    update?: XOR<XOR<DistributionSessionUpdateToOneWithWhereWithoutScenariosInput, DistributionSessionUpdateWithoutScenariosInput>, DistributionSessionUncheckedUpdateWithoutScenariosInput>
  }

  export type DistributionChangeUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<DistributionChangeCreateWithoutScenarioInput, DistributionChangeUncheckedCreateWithoutScenarioInput> | DistributionChangeCreateWithoutScenarioInput[] | DistributionChangeUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutScenarioInput | DistributionChangeCreateOrConnectWithoutScenarioInput[]
    upsert?: DistributionChangeUpsertWithWhereUniqueWithoutScenarioInput | DistributionChangeUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: DistributionChangeCreateManyScenarioInputEnvelope
    set?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    disconnect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    delete?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    update?: DistributionChangeUpdateWithWhereUniqueWithoutScenarioInput | DistributionChangeUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: DistributionChangeUpdateManyWithWhereWithoutScenarioInput | DistributionChangeUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: DistributionChangeScalarWhereInput | DistributionChangeScalarWhereInput[]
  }

  export type DistributionChangeUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<DistributionChangeCreateWithoutScenarioInput, DistributionChangeUncheckedCreateWithoutScenarioInput> | DistributionChangeCreateWithoutScenarioInput[] | DistributionChangeUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: DistributionChangeCreateOrConnectWithoutScenarioInput | DistributionChangeCreateOrConnectWithoutScenarioInput[]
    upsert?: DistributionChangeUpsertWithWhereUniqueWithoutScenarioInput | DistributionChangeUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: DistributionChangeCreateManyScenarioInputEnvelope
    set?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    disconnect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    delete?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    connect?: DistributionChangeWhereUniqueInput | DistributionChangeWhereUniqueInput[]
    update?: DistributionChangeUpdateWithWhereUniqueWithoutScenarioInput | DistributionChangeUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: DistributionChangeUpdateManyWithWhereWithoutScenarioInput | DistributionChangeUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: DistributionChangeScalarWhereInput | DistributionChangeScalarWhereInput[]
  }

  export type DistributionScenarioCreateNestedOneWithoutChangesInput = {
    create?: XOR<DistributionScenarioCreateWithoutChangesInput, DistributionScenarioUncheckedCreateWithoutChangesInput>
    connectOrCreate?: DistributionScenarioCreateOrConnectWithoutChangesInput
    connect?: DistributionScenarioWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDistributionChangesInput = {
    create?: XOR<UserCreateWithoutDistributionChangesInput, UserUncheckedCreateWithoutDistributionChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDistributionChangesInput
    connect?: UserWhereUniqueInput
  }

  export type DistributionScenarioUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<DistributionScenarioCreateWithoutChangesInput, DistributionScenarioUncheckedCreateWithoutChangesInput>
    connectOrCreate?: DistributionScenarioCreateOrConnectWithoutChangesInput
    upsert?: DistributionScenarioUpsertWithoutChangesInput
    connect?: DistributionScenarioWhereUniqueInput
    update?: XOR<XOR<DistributionScenarioUpdateToOneWithWhereWithoutChangesInput, DistributionScenarioUpdateWithoutChangesInput>, DistributionScenarioUncheckedUpdateWithoutChangesInput>
  }

  export type UserUpdateOneWithoutDistributionChangesNestedInput = {
    create?: XOR<UserCreateWithoutDistributionChangesInput, UserUncheckedCreateWithoutDistributionChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDistributionChangesInput
    upsert?: UserUpsertWithoutDistributionChangesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDistributionChangesInput, UserUpdateWithoutDistributionChangesInput>, UserUncheckedUpdateWithoutDistributionChangesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type NestedEnumPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusFilter<$PrismaModel> | $Enums.PartnerStatus
  }

  export type NestedEnumOnboardingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusFilter<$PrismaModel> | $Enums.OnboardingStatus
  }

  export type NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOnboardingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnboardingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnboardingStatusFilter<$PrismaModel>
    _max?: NestedEnumOnboardingStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCapabilitySourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CapabilitySourceType | EnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCapabilitySourceTypeFilter<$PrismaModel> | $Enums.CapabilitySourceType
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCapabilitySourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CapabilitySourceType | EnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CapabilitySourceType[] | ListEnumCapabilitySourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCapabilitySourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.CapabilitySourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCapabilitySourceTypeFilter<$PrismaModel>
    _max?: NestedEnumCapabilitySourceTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumApiStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusFilter<$PrismaModel> | $Enums.ApiStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumApiStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApiStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiStatusFilter<$PrismaModel>
    _max?: NestedEnumApiStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCampaignPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignPartnerStatus | EnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignPartnerStatusFilter<$PrismaModel> | $Enums.CampaignPartnerStatus
  }

  export type NestedEnumCampaignPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignPartnerStatus | EnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignPartnerStatus[] | ListEnumCampaignPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignPartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignPartnerStatusFilter<$PrismaModel>
  }

  export type NestedEnumDatasetCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetCategory | EnumDatasetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetCategoryFilter<$PrismaModel> | $Enums.DatasetCategory
  }

  export type NestedEnumDatasetSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetSourceType | EnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetSourceTypeFilter<$PrismaModel> | $Enums.DatasetSourceType
  }

  export type NestedEnumUpdateFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateFrequency | EnumUpdateFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumUpdateFrequencyFilter<$PrismaModel> | $Enums.UpdateFrequency
  }

  export type NestedEnumDatasetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusFilter<$PrismaModel> | $Enums.DatasetStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumDatasetCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetCategory | EnumDatasetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetCategory[] | ListEnumDatasetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DatasetCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetCategoryFilter<$PrismaModel>
    _max?: NestedEnumDatasetCategoryFilter<$PrismaModel>
  }

  export type NestedEnumDatasetSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetSourceType | EnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetSourceType[] | ListEnumDatasetSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DatasetSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumDatasetSourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumUpdateFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateFrequency | EnumUpdateFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UpdateFrequency[] | ListEnumUpdateFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumUpdateFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.UpdateFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUpdateFrequencyFilter<$PrismaModel>
    _max?: NestedEnumUpdateFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel> | $Enums.DatasetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetStatusFilter<$PrismaModel>
    _max?: NestedEnumDatasetStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumIngestionJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IngestionJobType | EnumIngestionJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIngestionJobTypeFilter<$PrismaModel> | $Enums.IngestionJobType
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumIngestionJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IngestionJobType | EnumIngestionJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngestionJobType[] | ListEnumIngestionJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIngestionJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.IngestionJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIngestionJobTypeFilter<$PrismaModel>
    _max?: NestedEnumIngestionJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumDataConnectorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DataConnectorType | EnumDataConnectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataConnectorTypeFilter<$PrismaModel> | $Enums.DataConnectorType
  }

  export type NestedEnumConnectorHealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectorHealthStatus | EnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectorHealthStatusFilter<$PrismaModel> | $Enums.ConnectorHealthStatus
  }

  export type NestedEnumDataConnectorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataConnectorType | EnumDataConnectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataConnectorType[] | ListEnumDataConnectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDataConnectorTypeWithAggregatesFilter<$PrismaModel> | $Enums.DataConnectorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataConnectorTypeFilter<$PrismaModel>
    _max?: NestedEnumDataConnectorTypeFilter<$PrismaModel>
  }

  export type NestedEnumConnectorHealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectorHealthStatus | EnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectorHealthStatus[] | ListEnumConnectorHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectorHealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConnectorHealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectorHealthStatusFilter<$PrismaModel>
    _max?: NestedEnumConnectorHealthStatusFilter<$PrismaModel>
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rfps?: RFPCreateNestedManyWithoutCampaignInput
    partnerAssociations?: CampaignPartnerCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rfps?: RFPUncheckedCreateNestedManyWithoutCampaignInput
    partnerAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type DistributionChangeCreateWithoutUserInput = {
    id?: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    scenario: DistributionScenarioCreateNestedOneWithoutChangesInput
  }

  export type DistributionChangeUncheckedCreateWithoutUserInput = {
    id?: string
    scenarioId: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type DistributionChangeCreateOrConnectWithoutUserInput = {
    where: DistributionChangeWhereUniqueInput
    create: XOR<DistributionChangeCreateWithoutUserInput, DistributionChangeUncheckedCreateWithoutUserInput>
  }

  export type DistributionChangeCreateManyUserInputEnvelope = {
    data: DistributionChangeCreateManyUserInput | DistributionChangeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    brandId?: StringFilter<"Campaign"> | string
    objectives?: JsonFilter<"Campaign">
    budget?: JsonFilter<"Campaign">
    status?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DistributionChangeUpsertWithWhereUniqueWithoutUserInput = {
    where: DistributionChangeWhereUniqueInput
    update: XOR<DistributionChangeUpdateWithoutUserInput, DistributionChangeUncheckedUpdateWithoutUserInput>
    create: XOR<DistributionChangeCreateWithoutUserInput, DistributionChangeUncheckedCreateWithoutUserInput>
  }

  export type DistributionChangeUpdateWithWhereUniqueWithoutUserInput = {
    where: DistributionChangeWhereUniqueInput
    data: XOR<DistributionChangeUpdateWithoutUserInput, DistributionChangeUncheckedUpdateWithoutUserInput>
  }

  export type DistributionChangeUpdateManyWithWhereWithoutUserInput = {
    where: DistributionChangeScalarWhereInput
    data: XOR<DistributionChangeUpdateManyMutationInput, DistributionChangeUncheckedUpdateManyWithoutUserInput>
  }

  export type DistributionChangeScalarWhereInput = {
    AND?: DistributionChangeScalarWhereInput | DistributionChangeScalarWhereInput[]
    OR?: DistributionChangeScalarWhereInput[]
    NOT?: DistributionChangeScalarWhereInput | DistributionChangeScalarWhereInput[]
    id?: StringFilter<"DistributionChange"> | string
    scenarioId?: StringFilter<"DistributionChange"> | string
    field?: StringFilter<"DistributionChange"> | string
    oldValue?: JsonFilter<"DistributionChange">
    newValue?: JsonFilter<"DistributionChange">
    userId?: StringNullableFilter<"DistributionChange"> | string | null
    timestamp?: DateTimeFilter<"DistributionChange"> | Date | string
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    distributionChanges?: DistributionChangeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    distributionChanges?: DistributionChangeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type RFPCreateWithoutCampaignInput = {
    id?: string
    partners: JsonNullValueInput | InputJsonValue
    status: string
    requestedAt: Date | string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFPUncheckedCreateWithoutCampaignInput = {
    id?: string
    partners: JsonNullValueInput | InputJsonValue
    status: string
    requestedAt: Date | string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFPCreateOrConnectWithoutCampaignInput = {
    where: RFPWhereUniqueInput
    create: XOR<RFPCreateWithoutCampaignInput, RFPUncheckedCreateWithoutCampaignInput>
  }

  export type RFPCreateManyCampaignInputEnvelope = {
    data: RFPCreateManyCampaignInput | RFPCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignPartnerCreateWithoutCampaignInput = {
    id?: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutCampaignAssociationsInput
  }

  export type CampaignPartnerUncheckedCreateWithoutCampaignInput = {
    id?: string
    partnerId: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignPartnerCreateOrConnectWithoutCampaignInput = {
    where: CampaignPartnerWhereUniqueInput
    create: XOR<CampaignPartnerCreateWithoutCampaignInput, CampaignPartnerUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignPartnerCreateManyCampaignInputEnvelope = {
    data: CampaignPartnerCreateManyCampaignInput | CampaignPartnerCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type DistributionSessionCreateWithoutCampaignInput = {
    id?: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: DistributionScenarioCreateNestedManyWithoutSessionInput
  }

  export type DistributionSessionUncheckedCreateWithoutCampaignInput = {
    id?: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: DistributionScenarioUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DistributionSessionCreateOrConnectWithoutCampaignInput = {
    where: DistributionSessionWhereUniqueInput
    create: XOR<DistributionSessionCreateWithoutCampaignInput, DistributionSessionUncheckedCreateWithoutCampaignInput>
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    distributionChanges?: DistributionChangeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    distributionChanges?: DistributionChangeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RFPUpsertWithWhereUniqueWithoutCampaignInput = {
    where: RFPWhereUniqueInput
    update: XOR<RFPUpdateWithoutCampaignInput, RFPUncheckedUpdateWithoutCampaignInput>
    create: XOR<RFPCreateWithoutCampaignInput, RFPUncheckedCreateWithoutCampaignInput>
  }

  export type RFPUpdateWithWhereUniqueWithoutCampaignInput = {
    where: RFPWhereUniqueInput
    data: XOR<RFPUpdateWithoutCampaignInput, RFPUncheckedUpdateWithoutCampaignInput>
  }

  export type RFPUpdateManyWithWhereWithoutCampaignInput = {
    where: RFPScalarWhereInput
    data: XOR<RFPUpdateManyMutationInput, RFPUncheckedUpdateManyWithoutCampaignInput>
  }

  export type RFPScalarWhereInput = {
    AND?: RFPScalarWhereInput | RFPScalarWhereInput[]
    OR?: RFPScalarWhereInput[]
    NOT?: RFPScalarWhereInput | RFPScalarWhereInput[]
    id?: StringFilter<"RFP"> | string
    campaignId?: StringFilter<"RFP"> | string
    partners?: JsonFilter<"RFP">
    status?: StringFilter<"RFP"> | string
    requestedAt?: DateTimeFilter<"RFP"> | Date | string
    responses?: JsonFilter<"RFP">
    createdAt?: DateTimeFilter<"RFP"> | Date | string
    updatedAt?: DateTimeFilter<"RFP"> | Date | string
  }

  export type CampaignPartnerUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignPartnerWhereUniqueInput
    update: XOR<CampaignPartnerUpdateWithoutCampaignInput, CampaignPartnerUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignPartnerCreateWithoutCampaignInput, CampaignPartnerUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignPartnerUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignPartnerWhereUniqueInput
    data: XOR<CampaignPartnerUpdateWithoutCampaignInput, CampaignPartnerUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignPartnerUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignPartnerScalarWhereInput
    data: XOR<CampaignPartnerUpdateManyMutationInput, CampaignPartnerUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignPartnerScalarWhereInput = {
    AND?: CampaignPartnerScalarWhereInput | CampaignPartnerScalarWhereInput[]
    OR?: CampaignPartnerScalarWhereInput[]
    NOT?: CampaignPartnerScalarWhereInput | CampaignPartnerScalarWhereInput[]
    id?: StringFilter<"CampaignPartner"> | string
    campaignId?: StringFilter<"CampaignPartner"> | string
    partnerId?: StringFilter<"CampaignPartner"> | string
    status?: EnumCampaignPartnerStatusFilter<"CampaignPartner"> | $Enums.CampaignPartnerStatus
    budget?: JsonNullableFilter<"CampaignPartner">
    targeting?: JsonNullableFilter<"CampaignPartner">
    creative?: JsonNullableFilter<"CampaignPartner">
    createdAt?: DateTimeFilter<"CampaignPartner"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignPartner"> | Date | string
  }

  export type DistributionSessionUpsertWithoutCampaignInput = {
    update: XOR<DistributionSessionUpdateWithoutCampaignInput, DistributionSessionUncheckedUpdateWithoutCampaignInput>
    create: XOR<DistributionSessionCreateWithoutCampaignInput, DistributionSessionUncheckedCreateWithoutCampaignInput>
    where?: DistributionSessionWhereInput
  }

  export type DistributionSessionUpdateToOneWithWhereWithoutCampaignInput = {
    where?: DistributionSessionWhereInput
    data: XOR<DistributionSessionUpdateWithoutCampaignInput, DistributionSessionUncheckedUpdateWithoutCampaignInput>
  }

  export type DistributionSessionUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: DistributionScenarioUpdateManyWithoutSessionNestedInput
  }

  export type DistributionSessionUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: DistributionScenarioUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CampaignCreateWithoutRfpsInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    partnerAssociations?: CampaignPartnerCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRfpsInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRfpsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRfpsInput, CampaignUncheckedCreateWithoutRfpsInput>
  }

  export type CampaignUpsertWithoutRfpsInput = {
    update: XOR<CampaignUpdateWithoutRfpsInput, CampaignUncheckedUpdateWithoutRfpsInput>
    create: XOR<CampaignCreateWithoutRfpsInput, CampaignUncheckedCreateWithoutRfpsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRfpsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRfpsInput, CampaignUncheckedUpdateWithoutRfpsInput>
  }

  export type CampaignUpdateWithoutRfpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    partnerAssociations?: CampaignPartnerUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRfpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerAssociations?: CampaignPartnerUncheckedUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type PartnerCapabilityCreateWithoutPartnerInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    details: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastUpdated?: Date | string
    sourceType: $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCapabilityUncheckedCreateWithoutPartnerInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    details: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastUpdated?: Date | string
    sourceType: $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCapabilityCreateOrConnectWithoutPartnerInput = {
    where: PartnerCapabilityWhereUniqueInput
    create: XOR<PartnerCapabilityCreateWithoutPartnerInput, PartnerCapabilityUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerCapabilityCreateManyPartnerInputEnvelope = {
    data: PartnerCapabilityCreateManyPartnerInput | PartnerCapabilityCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type CreativeSpecCreateWithoutPartnerInput = {
    id?: string
    format: string
    dimensions: JsonNullValueInput | InputJsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeSpecUncheckedCreateWithoutPartnerInput = {
    id?: string
    format: string
    dimensions: JsonNullValueInput | InputJsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeSpecCreateOrConnectWithoutPartnerInput = {
    where: CreativeSpecWhereUniqueInput
    create: XOR<CreativeSpecCreateWithoutPartnerInput, CreativeSpecUncheckedCreateWithoutPartnerInput>
  }

  export type CreativeSpecCreateManyPartnerInputEnvelope = {
    data: CreativeSpecCreateManyPartnerInput | CreativeSpecCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type PartnerHealthMetricCreateWithoutPartnerInput = {
    id?: string
    timestamp?: Date | string
    apiStatus: $Enums.ApiStatus
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    lastError?: string | null
    healthScore?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricUncheckedCreateWithoutPartnerInput = {
    id?: string
    timestamp?: Date | string
    apiStatus: $Enums.ApiStatus
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    lastError?: string | null
    healthScore?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricCreateOrConnectWithoutPartnerInput = {
    where: PartnerHealthMetricWhereUniqueInput
    create: XOR<PartnerHealthMetricCreateWithoutPartnerInput, PartnerHealthMetricUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerHealthMetricCreateManyPartnerInputEnvelope = {
    data: PartnerHealthMetricCreateManyPartnerInput | PartnerHealthMetricCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type CampaignPartnerCreateWithoutPartnerInput = {
    id?: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutPartnerAssociationsInput
  }

  export type CampaignPartnerUncheckedCreateWithoutPartnerInput = {
    id?: string
    campaignId: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignPartnerCreateOrConnectWithoutPartnerInput = {
    where: CampaignPartnerWhereUniqueInput
    create: XOR<CampaignPartnerCreateWithoutPartnerInput, CampaignPartnerUncheckedCreateWithoutPartnerInput>
  }

  export type CampaignPartnerCreateManyPartnerInputEnvelope = {
    data: CampaignPartnerCreateManyPartnerInput | CampaignPartnerCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type PartnerCapabilityUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerCapabilityWhereUniqueInput
    update: XOR<PartnerCapabilityUpdateWithoutPartnerInput, PartnerCapabilityUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerCapabilityCreateWithoutPartnerInput, PartnerCapabilityUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerCapabilityUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerCapabilityWhereUniqueInput
    data: XOR<PartnerCapabilityUpdateWithoutPartnerInput, PartnerCapabilityUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerCapabilityUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerCapabilityScalarWhereInput
    data: XOR<PartnerCapabilityUpdateManyMutationInput, PartnerCapabilityUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerCapabilityScalarWhereInput = {
    AND?: PartnerCapabilityScalarWhereInput | PartnerCapabilityScalarWhereInput[]
    OR?: PartnerCapabilityScalarWhereInput[]
    NOT?: PartnerCapabilityScalarWhereInput | PartnerCapabilityScalarWhereInput[]
    id?: StringFilter<"PartnerCapability"> | string
    partnerId?: StringFilter<"PartnerCapability"> | string
    name?: StringFilter<"PartnerCapability"> | string
    description?: StringNullableFilter<"PartnerCapability"> | string | null
    category?: StringFilter<"PartnerCapability"> | string
    details?: JsonFilter<"PartnerCapability">
    isActive?: BoolFilter<"PartnerCapability"> | boolean
    lastUpdated?: DateTimeFilter<"PartnerCapability"> | Date | string
    sourceType?: EnumCapabilitySourceTypeFilter<"PartnerCapability"> | $Enums.CapabilitySourceType
    sourceData?: JsonNullableFilter<"PartnerCapability">
    createdAt?: DateTimeFilter<"PartnerCapability"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerCapability"> | Date | string
  }

  export type CreativeSpecUpsertWithWhereUniqueWithoutPartnerInput = {
    where: CreativeSpecWhereUniqueInput
    update: XOR<CreativeSpecUpdateWithoutPartnerInput, CreativeSpecUncheckedUpdateWithoutPartnerInput>
    create: XOR<CreativeSpecCreateWithoutPartnerInput, CreativeSpecUncheckedCreateWithoutPartnerInput>
  }

  export type CreativeSpecUpdateWithWhereUniqueWithoutPartnerInput = {
    where: CreativeSpecWhereUniqueInput
    data: XOR<CreativeSpecUpdateWithoutPartnerInput, CreativeSpecUncheckedUpdateWithoutPartnerInput>
  }

  export type CreativeSpecUpdateManyWithWhereWithoutPartnerInput = {
    where: CreativeSpecScalarWhereInput
    data: XOR<CreativeSpecUpdateManyMutationInput, CreativeSpecUncheckedUpdateManyWithoutPartnerInput>
  }

  export type CreativeSpecScalarWhereInput = {
    AND?: CreativeSpecScalarWhereInput | CreativeSpecScalarWhereInput[]
    OR?: CreativeSpecScalarWhereInput[]
    NOT?: CreativeSpecScalarWhereInput | CreativeSpecScalarWhereInput[]
    id?: StringFilter<"CreativeSpec"> | string
    partnerId?: StringFilter<"CreativeSpec"> | string
    format?: StringFilter<"CreativeSpec"> | string
    dimensions?: JsonFilter<"CreativeSpec">
    fileType?: StringFilter<"CreativeSpec"> | string
    maxFileSize?: IntFilter<"CreativeSpec"> | number
    requirements?: JsonFilter<"CreativeSpec">
    examples?: JsonNullableFilter<"CreativeSpec">
    isActive?: BoolFilter<"CreativeSpec"> | boolean
    createdAt?: DateTimeFilter<"CreativeSpec"> | Date | string
    updatedAt?: DateTimeFilter<"CreativeSpec"> | Date | string
  }

  export type PartnerHealthMetricUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerHealthMetricWhereUniqueInput
    update: XOR<PartnerHealthMetricUpdateWithoutPartnerInput, PartnerHealthMetricUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerHealthMetricCreateWithoutPartnerInput, PartnerHealthMetricUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerHealthMetricUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerHealthMetricWhereUniqueInput
    data: XOR<PartnerHealthMetricUpdateWithoutPartnerInput, PartnerHealthMetricUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerHealthMetricUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerHealthMetricScalarWhereInput
    data: XOR<PartnerHealthMetricUpdateManyMutationInput, PartnerHealthMetricUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerHealthMetricScalarWhereInput = {
    AND?: PartnerHealthMetricScalarWhereInput | PartnerHealthMetricScalarWhereInput[]
    OR?: PartnerHealthMetricScalarWhereInput[]
    NOT?: PartnerHealthMetricScalarWhereInput | PartnerHealthMetricScalarWhereInput[]
    id?: StringFilter<"PartnerHealthMetric"> | string
    partnerId?: StringFilter<"PartnerHealthMetric"> | string
    timestamp?: DateTimeFilter<"PartnerHealthMetric"> | Date | string
    apiStatus?: EnumApiStatusFilter<"PartnerHealthMetric"> | $Enums.ApiStatus
    responseTime?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    errorRate?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    uptime?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    lastError?: StringNullableFilter<"PartnerHealthMetric"> | string | null
    healthScore?: FloatNullableFilter<"PartnerHealthMetric"> | number | null
    details?: JsonNullableFilter<"PartnerHealthMetric">
  }

  export type CampaignPartnerUpsertWithWhereUniqueWithoutPartnerInput = {
    where: CampaignPartnerWhereUniqueInput
    update: XOR<CampaignPartnerUpdateWithoutPartnerInput, CampaignPartnerUncheckedUpdateWithoutPartnerInput>
    create: XOR<CampaignPartnerCreateWithoutPartnerInput, CampaignPartnerUncheckedCreateWithoutPartnerInput>
  }

  export type CampaignPartnerUpdateWithWhereUniqueWithoutPartnerInput = {
    where: CampaignPartnerWhereUniqueInput
    data: XOR<CampaignPartnerUpdateWithoutPartnerInput, CampaignPartnerUncheckedUpdateWithoutPartnerInput>
  }

  export type CampaignPartnerUpdateManyWithWhereWithoutPartnerInput = {
    where: CampaignPartnerScalarWhereInput
    data: XOR<CampaignPartnerUpdateManyMutationInput, CampaignPartnerUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerCreateWithoutCapabilitiesInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creativeSpecs?: CreativeSpecCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutCapabilitiesInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creativeSpecs?: CreativeSpecUncheckedCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricUncheckedCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutCapabilitiesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutCapabilitiesInput, PartnerUncheckedCreateWithoutCapabilitiesInput>
  }

  export type PartnerUpsertWithoutCapabilitiesInput = {
    update: XOR<PartnerUpdateWithoutCapabilitiesInput, PartnerUncheckedUpdateWithoutCapabilitiesInput>
    create: XOR<PartnerCreateWithoutCapabilitiesInput, PartnerUncheckedCreateWithoutCapabilitiesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutCapabilitiesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutCapabilitiesInput, PartnerUncheckedUpdateWithoutCapabilitiesInput>
  }

  export type PartnerUpdateWithoutCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeSpecs?: CreativeSpecUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeSpecs?: CreativeSpecUncheckedUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUncheckedUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateWithoutCreativeSpecsInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutCreativeSpecsInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityUncheckedCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricUncheckedCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutCreativeSpecsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutCreativeSpecsInput, PartnerUncheckedCreateWithoutCreativeSpecsInput>
  }

  export type PartnerUpsertWithoutCreativeSpecsInput = {
    update: XOR<PartnerUpdateWithoutCreativeSpecsInput, PartnerUncheckedUpdateWithoutCreativeSpecsInput>
    create: XOR<PartnerCreateWithoutCreativeSpecsInput, PartnerUncheckedCreateWithoutCreativeSpecsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutCreativeSpecsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutCreativeSpecsInput, PartnerUncheckedUpdateWithoutCreativeSpecsInput>
  }

  export type PartnerUpdateWithoutCreativeSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutCreativeSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUncheckedUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUncheckedUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateWithoutHealthMetricsInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityCreateNestedManyWithoutPartnerInput
    creativeSpecs?: CreativeSpecCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutHealthMetricsInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityUncheckedCreateNestedManyWithoutPartnerInput
    creativeSpecs?: CreativeSpecUncheckedCreateNestedManyWithoutPartnerInput
    campaignAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutHealthMetricsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutHealthMetricsInput, PartnerUncheckedCreateWithoutHealthMetricsInput>
  }

  export type PartnerUpsertWithoutHealthMetricsInput = {
    update: XOR<PartnerUpdateWithoutHealthMetricsInput, PartnerUncheckedUpdateWithoutHealthMetricsInput>
    create: XOR<PartnerCreateWithoutHealthMetricsInput, PartnerUncheckedCreateWithoutHealthMetricsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutHealthMetricsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutHealthMetricsInput, PartnerUncheckedUpdateWithoutHealthMetricsInput>
  }

  export type PartnerUpdateWithoutHealthMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUpdateManyWithoutPartnerNestedInput
    creativeSpecs?: CreativeSpecUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutHealthMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUncheckedUpdateManyWithoutPartnerNestedInput
    creativeSpecs?: CreativeSpecUncheckedUpdateManyWithoutPartnerNestedInput
    campaignAssociations?: CampaignPartnerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type CampaignCreateWithoutPartnerAssociationsInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    rfps?: RFPCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutPartnerAssociationsInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rfps?: RFPUncheckedCreateNestedManyWithoutCampaignInput
    distributionSession?: DistributionSessionUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutPartnerAssociationsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutPartnerAssociationsInput, CampaignUncheckedCreateWithoutPartnerAssociationsInput>
  }

  export type PartnerCreateWithoutCampaignAssociationsInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityCreateNestedManyWithoutPartnerInput
    creativeSpecs?: CreativeSpecCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutCampaignAssociationsInput = {
    id?: string
    name: string
    displayName: string
    type: $Enums.PartnerType
    status?: $Enums.PartnerStatus
    companyInfo: JsonNullValueInput | InputJsonValue
    contactInfo: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions: JsonNullValueInput | InputJsonValue
    measurementCapabilities: JsonNullValueInput | InputJsonValue
    onboardingStatus?: $Enums.OnboardingStatus
    onboardingSteps: JsonNullValueInput | InputJsonValue
    pricingInfo: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: PartnerCapabilityUncheckedCreateNestedManyWithoutPartnerInput
    creativeSpecs?: CreativeSpecUncheckedCreateNestedManyWithoutPartnerInput
    healthMetrics?: PartnerHealthMetricUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutCampaignAssociationsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutCampaignAssociationsInput, PartnerUncheckedCreateWithoutCampaignAssociationsInput>
  }

  export type CampaignUpsertWithoutPartnerAssociationsInput = {
    update: XOR<CampaignUpdateWithoutPartnerAssociationsInput, CampaignUncheckedUpdateWithoutPartnerAssociationsInput>
    create: XOR<CampaignCreateWithoutPartnerAssociationsInput, CampaignUncheckedCreateWithoutPartnerAssociationsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutPartnerAssociationsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutPartnerAssociationsInput, CampaignUncheckedUpdateWithoutPartnerAssociationsInput>
  }

  export type CampaignUpdateWithoutPartnerAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    rfps?: RFPUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutPartnerAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfps?: RFPUncheckedUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type PartnerUpsertWithoutCampaignAssociationsInput = {
    update: XOR<PartnerUpdateWithoutCampaignAssociationsInput, PartnerUncheckedUpdateWithoutCampaignAssociationsInput>
    create: XOR<PartnerCreateWithoutCampaignAssociationsInput, PartnerUncheckedCreateWithoutCampaignAssociationsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutCampaignAssociationsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutCampaignAssociationsInput, PartnerUncheckedUpdateWithoutCampaignAssociationsInput>
  }

  export type PartnerUpdateWithoutCampaignAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUpdateManyWithoutPartnerNestedInput
    creativeSpecs?: CreativeSpecUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutCampaignAssociationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    companyInfo?: JsonNullValueInput | InputJsonValue
    contactInfo?: JsonNullValueInput | InputJsonValue
    apiCredentials?: NullableJsonNullValueInput | InputJsonValue
    targetingOptions?: JsonNullValueInput | InputJsonValue
    measurementCapabilities?: JsonNullValueInput | InputJsonValue
    onboardingStatus?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    onboardingSteps?: JsonNullValueInput | InputJsonValue
    pricingInfo?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: PartnerCapabilityUncheckedUpdateManyWithoutPartnerNestedInput
    creativeSpecs?: CreativeSpecUncheckedUpdateManyWithoutPartnerNestedInput
    healthMetrics?: PartnerHealthMetricUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type DatasetVersionCreateWithoutDatasetInput = {
    id?: string
    version: string
    description?: string | null
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    size?: bigint | number | null
    recordCount?: bigint | number | null
    checksums: JsonNullValueInput | InputJsonValue
    location: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type DatasetVersionUncheckedCreateWithoutDatasetInput = {
    id?: string
    version: string
    description?: string | null
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    size?: bigint | number | null
    recordCount?: bigint | number | null
    checksums: JsonNullValueInput | InputJsonValue
    location: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type DatasetVersionCreateOrConnectWithoutDatasetInput = {
    where: DatasetVersionWhereUniqueInput
    create: XOR<DatasetVersionCreateWithoutDatasetInput, DatasetVersionUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetVersionCreateManyDatasetInputEnvelope = {
    data: DatasetVersionCreateManyDatasetInput | DatasetVersionCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type DataQualityReportCreateWithoutDatasetInput = {
    id?: string
    reportDate?: Date | string
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    issues: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    processingTime?: number | null
    recordsProcessed?: bigint | number | null
    createdAt?: Date | string
  }

  export type DataQualityReportUncheckedCreateWithoutDatasetInput = {
    id?: string
    reportDate?: Date | string
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    issues: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    processingTime?: number | null
    recordsProcessed?: bigint | number | null
    createdAt?: Date | string
  }

  export type DataQualityReportCreateOrConnectWithoutDatasetInput = {
    where: DataQualityReportWhereUniqueInput
    create: XOR<DataQualityReportCreateWithoutDatasetInput, DataQualityReportUncheckedCreateWithoutDatasetInput>
  }

  export type DataQualityReportCreateManyDatasetInputEnvelope = {
    data: DataQualityReportCreateManyDatasetInput | DataQualityReportCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type IngestionJobCreateWithoutDatasetInput = {
    id?: string
    jobType: $Enums.IngestionJobType
    status?: $Enums.JobStatus
    config: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    logs?: string | null
    recordsProcessed?: bigint | number | null
    recordsSucceeded?: bigint | number | null
    recordsFailed?: bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngestionJobUncheckedCreateWithoutDatasetInput = {
    id?: string
    jobType: $Enums.IngestionJobType
    status?: $Enums.JobStatus
    config: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    logs?: string | null
    recordsProcessed?: bigint | number | null
    recordsSucceeded?: bigint | number | null
    recordsFailed?: bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngestionJobCreateOrConnectWithoutDatasetInput = {
    where: IngestionJobWhereUniqueInput
    create: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput>
  }

  export type IngestionJobCreateManyDatasetInputEnvelope = {
    data: IngestionJobCreateManyDatasetInput | IngestionJobCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type DatasetLineageCreateWithoutUpstreamInput = {
    id?: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
    downstream: DatasetCreateNestedOneWithoutLineageDownstreamInput
  }

  export type DatasetLineageUncheckedCreateWithoutUpstreamInput = {
    id?: string
    downstreamId: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
  }

  export type DatasetLineageCreateOrConnectWithoutUpstreamInput = {
    where: DatasetLineageWhereUniqueInput
    create: XOR<DatasetLineageCreateWithoutUpstreamInput, DatasetLineageUncheckedCreateWithoutUpstreamInput>
  }

  export type DatasetLineageCreateManyUpstreamInputEnvelope = {
    data: DatasetLineageCreateManyUpstreamInput | DatasetLineageCreateManyUpstreamInput[]
    skipDuplicates?: boolean
  }

  export type DatasetLineageCreateWithoutDownstreamInput = {
    id?: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
    upstream: DatasetCreateNestedOneWithoutLineageUpstreamInput
  }

  export type DatasetLineageUncheckedCreateWithoutDownstreamInput = {
    id?: string
    upstreamId: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
  }

  export type DatasetLineageCreateOrConnectWithoutDownstreamInput = {
    where: DatasetLineageWhereUniqueInput
    create: XOR<DatasetLineageCreateWithoutDownstreamInput, DatasetLineageUncheckedCreateWithoutDownstreamInput>
  }

  export type DatasetLineageCreateManyDownstreamInputEnvelope = {
    data: DatasetLineageCreateManyDownstreamInput | DatasetLineageCreateManyDownstreamInput[]
    skipDuplicates?: boolean
  }

  export type DatasetVersionUpsertWithWhereUniqueWithoutDatasetInput = {
    where: DatasetVersionWhereUniqueInput
    update: XOR<DatasetVersionUpdateWithoutDatasetInput, DatasetVersionUncheckedUpdateWithoutDatasetInput>
    create: XOR<DatasetVersionCreateWithoutDatasetInput, DatasetVersionUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetVersionUpdateWithWhereUniqueWithoutDatasetInput = {
    where: DatasetVersionWhereUniqueInput
    data: XOR<DatasetVersionUpdateWithoutDatasetInput, DatasetVersionUncheckedUpdateWithoutDatasetInput>
  }

  export type DatasetVersionUpdateManyWithWhereWithoutDatasetInput = {
    where: DatasetVersionScalarWhereInput
    data: XOR<DatasetVersionUpdateManyMutationInput, DatasetVersionUncheckedUpdateManyWithoutDatasetInput>
  }

  export type DatasetVersionScalarWhereInput = {
    AND?: DatasetVersionScalarWhereInput | DatasetVersionScalarWhereInput[]
    OR?: DatasetVersionScalarWhereInput[]
    NOT?: DatasetVersionScalarWhereInput | DatasetVersionScalarWhereInput[]
    id?: StringFilter<"DatasetVersion"> | string
    datasetId?: StringFilter<"DatasetVersion"> | string
    version?: StringFilter<"DatasetVersion"> | string
    description?: StringNullableFilter<"DatasetVersion"> | string | null
    schema?: JsonFilter<"DatasetVersion">
    metadata?: JsonFilter<"DatasetVersion">
    size?: BigIntNullableFilter<"DatasetVersion"> | bigint | number | null
    recordCount?: BigIntNullableFilter<"DatasetVersion"> | bigint | number | null
    checksums?: JsonFilter<"DatasetVersion">
    location?: StringFilter<"DatasetVersion"> | string
    isActive?: BoolFilter<"DatasetVersion"> | boolean
    createdAt?: DateTimeFilter<"DatasetVersion"> | Date | string
  }

  export type DataQualityReportUpsertWithWhereUniqueWithoutDatasetInput = {
    where: DataQualityReportWhereUniqueInput
    update: XOR<DataQualityReportUpdateWithoutDatasetInput, DataQualityReportUncheckedUpdateWithoutDatasetInput>
    create: XOR<DataQualityReportCreateWithoutDatasetInput, DataQualityReportUncheckedCreateWithoutDatasetInput>
  }

  export type DataQualityReportUpdateWithWhereUniqueWithoutDatasetInput = {
    where: DataQualityReportWhereUniqueInput
    data: XOR<DataQualityReportUpdateWithoutDatasetInput, DataQualityReportUncheckedUpdateWithoutDatasetInput>
  }

  export type DataQualityReportUpdateManyWithWhereWithoutDatasetInput = {
    where: DataQualityReportScalarWhereInput
    data: XOR<DataQualityReportUpdateManyMutationInput, DataQualityReportUncheckedUpdateManyWithoutDatasetInput>
  }

  export type DataQualityReportScalarWhereInput = {
    AND?: DataQualityReportScalarWhereInput | DataQualityReportScalarWhereInput[]
    OR?: DataQualityReportScalarWhereInput[]
    NOT?: DataQualityReportScalarWhereInput | DataQualityReportScalarWhereInput[]
    id?: StringFilter<"DataQualityReport"> | string
    datasetId?: StringFilter<"DataQualityReport"> | string
    reportDate?: DateTimeFilter<"DataQualityReport"> | Date | string
    overallScore?: FloatFilter<"DataQualityReport"> | number
    completeness?: FloatFilter<"DataQualityReport"> | number
    accuracy?: FloatFilter<"DataQualityReport"> | number
    consistency?: FloatFilter<"DataQualityReport"> | number
    validity?: FloatFilter<"DataQualityReport"> | number
    freshness?: FloatFilter<"DataQualityReport"> | number
    metrics?: JsonFilter<"DataQualityReport">
    anomalies?: JsonFilter<"DataQualityReport">
    issues?: JsonFilter<"DataQualityReport">
    recommendations?: JsonFilter<"DataQualityReport">
    processingTime?: IntNullableFilter<"DataQualityReport"> | number | null
    recordsProcessed?: BigIntNullableFilter<"DataQualityReport"> | bigint | number | null
    createdAt?: DateTimeFilter<"DataQualityReport"> | Date | string
  }

  export type IngestionJobUpsertWithWhereUniqueWithoutDatasetInput = {
    where: IngestionJobWhereUniqueInput
    update: XOR<IngestionJobUpdateWithoutDatasetInput, IngestionJobUncheckedUpdateWithoutDatasetInput>
    create: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput>
  }

  export type IngestionJobUpdateWithWhereUniqueWithoutDatasetInput = {
    where: IngestionJobWhereUniqueInput
    data: XOR<IngestionJobUpdateWithoutDatasetInput, IngestionJobUncheckedUpdateWithoutDatasetInput>
  }

  export type IngestionJobUpdateManyWithWhereWithoutDatasetInput = {
    where: IngestionJobScalarWhereInput
    data: XOR<IngestionJobUpdateManyMutationInput, IngestionJobUncheckedUpdateManyWithoutDatasetInput>
  }

  export type IngestionJobScalarWhereInput = {
    AND?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
    OR?: IngestionJobScalarWhereInput[]
    NOT?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
    id?: StringFilter<"IngestionJob"> | string
    datasetId?: StringFilter<"IngestionJob"> | string
    jobType?: EnumIngestionJobTypeFilter<"IngestionJob"> | $Enums.IngestionJobType
    status?: EnumJobStatusFilter<"IngestionJob"> | $Enums.JobStatus
    config?: JsonFilter<"IngestionJob">
    schedule?: StringNullableFilter<"IngestionJob"> | string | null
    startedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"IngestionJob"> | string | null
    logs?: StringNullableFilter<"IngestionJob"> | string | null
    recordsProcessed?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    recordsSucceeded?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    recordsFailed?: BigIntNullableFilter<"IngestionJob"> | bigint | number | null
    metrics?: JsonNullableFilter<"IngestionJob">
    retryCount?: IntFilter<"IngestionJob"> | number
    maxRetries?: IntFilter<"IngestionJob"> | number
    nextRetryAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    createdAt?: DateTimeFilter<"IngestionJob"> | Date | string
    updatedAt?: DateTimeFilter<"IngestionJob"> | Date | string
  }

  export type DatasetLineageUpsertWithWhereUniqueWithoutUpstreamInput = {
    where: DatasetLineageWhereUniqueInput
    update: XOR<DatasetLineageUpdateWithoutUpstreamInput, DatasetLineageUncheckedUpdateWithoutUpstreamInput>
    create: XOR<DatasetLineageCreateWithoutUpstreamInput, DatasetLineageUncheckedCreateWithoutUpstreamInput>
  }

  export type DatasetLineageUpdateWithWhereUniqueWithoutUpstreamInput = {
    where: DatasetLineageWhereUniqueInput
    data: XOR<DatasetLineageUpdateWithoutUpstreamInput, DatasetLineageUncheckedUpdateWithoutUpstreamInput>
  }

  export type DatasetLineageUpdateManyWithWhereWithoutUpstreamInput = {
    where: DatasetLineageScalarWhereInput
    data: XOR<DatasetLineageUpdateManyMutationInput, DatasetLineageUncheckedUpdateManyWithoutUpstreamInput>
  }

  export type DatasetLineageScalarWhereInput = {
    AND?: DatasetLineageScalarWhereInput | DatasetLineageScalarWhereInput[]
    OR?: DatasetLineageScalarWhereInput[]
    NOT?: DatasetLineageScalarWhereInput | DatasetLineageScalarWhereInput[]
    id?: StringFilter<"DatasetLineage"> | string
    upstreamId?: StringFilter<"DatasetLineage"> | string
    downstreamId?: StringFilter<"DatasetLineage"> | string
    transformationType?: StringFilter<"DatasetLineage"> | string
    transformationLogic?: JsonNullableFilter<"DatasetLineage">
    confidence?: FloatFilter<"DatasetLineage"> | number
    createdAt?: DateTimeFilter<"DatasetLineage"> | Date | string
  }

  export type DatasetLineageUpsertWithWhereUniqueWithoutDownstreamInput = {
    where: DatasetLineageWhereUniqueInput
    update: XOR<DatasetLineageUpdateWithoutDownstreamInput, DatasetLineageUncheckedUpdateWithoutDownstreamInput>
    create: XOR<DatasetLineageCreateWithoutDownstreamInput, DatasetLineageUncheckedCreateWithoutDownstreamInput>
  }

  export type DatasetLineageUpdateWithWhereUniqueWithoutDownstreamInput = {
    where: DatasetLineageWhereUniqueInput
    data: XOR<DatasetLineageUpdateWithoutDownstreamInput, DatasetLineageUncheckedUpdateWithoutDownstreamInput>
  }

  export type DatasetLineageUpdateManyWithWhereWithoutDownstreamInput = {
    where: DatasetLineageScalarWhereInput
    data: XOR<DatasetLineageUpdateManyMutationInput, DatasetLineageUncheckedUpdateManyWithoutDownstreamInput>
  }

  export type DatasetCreateWithoutVersionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityReports?: DataQualityReportCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetUncheckedCreateWithoutVersionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityReports?: DataQualityReportUncheckedCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageUncheckedCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageUncheckedCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetCreateOrConnectWithoutVersionsInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutVersionsInput, DatasetUncheckedCreateWithoutVersionsInput>
  }

  export type DatasetUpsertWithoutVersionsInput = {
    update: XOR<DatasetUpdateWithoutVersionsInput, DatasetUncheckedUpdateWithoutVersionsInput>
    create: XOR<DatasetCreateWithoutVersionsInput, DatasetUncheckedCreateWithoutVersionsInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutVersionsInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutVersionsInput, DatasetUncheckedUpdateWithoutVersionsInput>
  }

  export type DatasetUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityReports?: DataQualityReportUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityReports?: DataQualityReportUncheckedUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUncheckedUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUncheckedUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetCreateWithoutQualityReportsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetUncheckedCreateWithoutQualityReportsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionUncheckedCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageUncheckedCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageUncheckedCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetCreateOrConnectWithoutQualityReportsInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutQualityReportsInput, DatasetUncheckedCreateWithoutQualityReportsInput>
  }

  export type DatasetUpsertWithoutQualityReportsInput = {
    update: XOR<DatasetUpdateWithoutQualityReportsInput, DatasetUncheckedUpdateWithoutQualityReportsInput>
    create: XOR<DatasetCreateWithoutQualityReportsInput, DatasetUncheckedCreateWithoutQualityReportsInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutQualityReportsInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutQualityReportsInput, DatasetUncheckedUpdateWithoutQualityReportsInput>
  }

  export type DatasetUpdateWithoutQualityReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetUncheckedUpdateWithoutQualityReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUncheckedUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUncheckedUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUncheckedUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetCreateWithoutIngestionJobsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetUncheckedCreateWithoutIngestionJobsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionUncheckedCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportUncheckedCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageUncheckedCreateNestedManyWithoutUpstreamInput
    lineageDownstream?: DatasetLineageUncheckedCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetCreateOrConnectWithoutIngestionJobsInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutIngestionJobsInput, DatasetUncheckedCreateWithoutIngestionJobsInput>
  }

  export type DatasetUpsertWithoutIngestionJobsInput = {
    update: XOR<DatasetUpdateWithoutIngestionJobsInput, DatasetUncheckedUpdateWithoutIngestionJobsInput>
    create: XOR<DatasetCreateWithoutIngestionJobsInput, DatasetUncheckedCreateWithoutIngestionJobsInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutIngestionJobsInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutIngestionJobsInput, DatasetUncheckedUpdateWithoutIngestionJobsInput>
  }

  export type DatasetUpdateWithoutIngestionJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetUncheckedUpdateWithoutIngestionJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUncheckedUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUncheckedUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUncheckedUpdateManyWithoutUpstreamNestedInput
    lineageDownstream?: DatasetLineageUncheckedUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetCreateWithoutLineageUpstreamInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobCreateNestedManyWithoutDatasetInput
    lineageDownstream?: DatasetLineageCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetUncheckedCreateWithoutLineageUpstreamInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionUncheckedCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportUncheckedCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
    lineageDownstream?: DatasetLineageUncheckedCreateNestedManyWithoutDownstreamInput
  }

  export type DatasetCreateOrConnectWithoutLineageUpstreamInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutLineageUpstreamInput, DatasetUncheckedCreateWithoutLineageUpstreamInput>
  }

  export type DatasetCreateWithoutLineageDownstreamInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageCreateNestedManyWithoutUpstreamInput
  }

  export type DatasetUncheckedCreateWithoutLineageDownstreamInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    category: $Enums.DatasetCategory
    sourceType: $Enums.DatasetSourceType
    updateFrequency: $Enums.UpdateFrequency
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    status?: $Enums.DatasetStatus
    tags?: DatasetCreatetagsInput | string[]
    sourceConfig: JsonNullValueInput | InputJsonValue
    lastIngestion?: Date | string | null
    nextIngestion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DatasetVersionUncheckedCreateNestedManyWithoutDatasetInput
    qualityReports?: DataQualityReportUncheckedCreateNestedManyWithoutDatasetInput
    ingestionJobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
    lineageUpstream?: DatasetLineageUncheckedCreateNestedManyWithoutUpstreamInput
  }

  export type DatasetCreateOrConnectWithoutLineageDownstreamInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutLineageDownstreamInput, DatasetUncheckedCreateWithoutLineageDownstreamInput>
  }

  export type DatasetUpsertWithoutLineageUpstreamInput = {
    update: XOR<DatasetUpdateWithoutLineageUpstreamInput, DatasetUncheckedUpdateWithoutLineageUpstreamInput>
    create: XOR<DatasetCreateWithoutLineageUpstreamInput, DatasetUncheckedCreateWithoutLineageUpstreamInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutLineageUpstreamInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutLineageUpstreamInput, DatasetUncheckedUpdateWithoutLineageUpstreamInput>
  }

  export type DatasetUpdateWithoutLineageUpstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
    lineageDownstream?: DatasetLineageUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetUncheckedUpdateWithoutLineageUpstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUncheckedUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUncheckedUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
    lineageDownstream?: DatasetLineageUncheckedUpdateManyWithoutDownstreamNestedInput
  }

  export type DatasetUpsertWithoutLineageDownstreamInput = {
    update: XOR<DatasetUpdateWithoutLineageDownstreamInput, DatasetUncheckedUpdateWithoutLineageDownstreamInput>
    create: XOR<DatasetCreateWithoutLineageDownstreamInput, DatasetUncheckedCreateWithoutLineageDownstreamInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutLineageDownstreamInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutLineageDownstreamInput, DatasetUncheckedUpdateWithoutLineageDownstreamInput>
  }

  export type DatasetUpdateWithoutLineageDownstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUpdateManyWithoutUpstreamNestedInput
  }

  export type DatasetUncheckedUpdateWithoutLineageDownstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDatasetCategoryFieldUpdateOperationsInput | $Enums.DatasetCategory
    sourceType?: EnumDatasetSourceTypeFieldUpdateOperationsInput | $Enums.DatasetSourceType
    updateFrequency?: EnumUpdateFrequencyFieldUpdateOperationsInput | $Enums.UpdateFrequency
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    tags?: DatasetUpdatetagsInput | string[]
    sourceConfig?: JsonNullValueInput | InputJsonValue
    lastIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextIngestion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DatasetVersionUncheckedUpdateManyWithoutDatasetNestedInput
    qualityReports?: DataQualityReportUncheckedUpdateManyWithoutDatasetNestedInput
    ingestionJobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
    lineageUpstream?: DatasetLineageUncheckedUpdateManyWithoutUpstreamNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    distributionChanges?: DistributionChangeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    distributionChanges?: DistributionChangeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    distributionChanges?: DistributionChangeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    distributionChanges?: DistributionChangeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutDistributionSessionInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    rfps?: RFPCreateNestedManyWithoutCampaignInput
    partnerAssociations?: CampaignPartnerCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutDistributionSessionInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rfps?: RFPUncheckedCreateNestedManyWithoutCampaignInput
    partnerAssociations?: CampaignPartnerUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutDistributionSessionInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutDistributionSessionInput, CampaignUncheckedCreateWithoutDistributionSessionInput>
  }

  export type DistributionScenarioCreateWithoutSessionInput = {
    id?: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: DistributionChangeCreateNestedManyWithoutScenarioInput
  }

  export type DistributionScenarioUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: DistributionChangeUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type DistributionScenarioCreateOrConnectWithoutSessionInput = {
    where: DistributionScenarioWhereUniqueInput
    create: XOR<DistributionScenarioCreateWithoutSessionInput, DistributionScenarioUncheckedCreateWithoutSessionInput>
  }

  export type DistributionScenarioCreateManySessionInputEnvelope = {
    data: DistributionScenarioCreateManySessionInput | DistributionScenarioCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutDistributionSessionInput = {
    update: XOR<CampaignUpdateWithoutDistributionSessionInput, CampaignUncheckedUpdateWithoutDistributionSessionInput>
    create: XOR<CampaignCreateWithoutDistributionSessionInput, CampaignUncheckedCreateWithoutDistributionSessionInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutDistributionSessionInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutDistributionSessionInput, CampaignUncheckedUpdateWithoutDistributionSessionInput>
  }

  export type CampaignUpdateWithoutDistributionSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    rfps?: RFPUpdateManyWithoutCampaignNestedInput
    partnerAssociations?: CampaignPartnerUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutDistributionSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfps?: RFPUncheckedUpdateManyWithoutCampaignNestedInput
    partnerAssociations?: CampaignPartnerUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type DistributionScenarioUpsertWithWhereUniqueWithoutSessionInput = {
    where: DistributionScenarioWhereUniqueInput
    update: XOR<DistributionScenarioUpdateWithoutSessionInput, DistributionScenarioUncheckedUpdateWithoutSessionInput>
    create: XOR<DistributionScenarioCreateWithoutSessionInput, DistributionScenarioUncheckedCreateWithoutSessionInput>
  }

  export type DistributionScenarioUpdateWithWhereUniqueWithoutSessionInput = {
    where: DistributionScenarioWhereUniqueInput
    data: XOR<DistributionScenarioUpdateWithoutSessionInput, DistributionScenarioUncheckedUpdateWithoutSessionInput>
  }

  export type DistributionScenarioUpdateManyWithWhereWithoutSessionInput = {
    where: DistributionScenarioScalarWhereInput
    data: XOR<DistributionScenarioUpdateManyMutationInput, DistributionScenarioUncheckedUpdateManyWithoutSessionInput>
  }

  export type DistributionScenarioScalarWhereInput = {
    AND?: DistributionScenarioScalarWhereInput | DistributionScenarioScalarWhereInput[]
    OR?: DistributionScenarioScalarWhereInput[]
    NOT?: DistributionScenarioScalarWhereInput | DistributionScenarioScalarWhereInput[]
    id?: StringFilter<"DistributionScenario"> | string
    sessionId?: StringFilter<"DistributionScenario"> | string
    name?: StringFilter<"DistributionScenario"> | string
    description?: StringNullableFilter<"DistributionScenario"> | string | null
    isBaseline?: BoolFilter<"DistributionScenario"> | boolean
    parameters?: JsonFilter<"DistributionScenario">
    projections?: JsonFilter<"DistributionScenario">
    lastModified?: DateTimeFilter<"DistributionScenario"> | Date | string
    createdAt?: DateTimeFilter<"DistributionScenario"> | Date | string
    updatedAt?: DateTimeFilter<"DistributionScenario"> | Date | string
  }

  export type DistributionSessionCreateWithoutScenariosInput = {
    id?: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutDistributionSessionInput
  }

  export type DistributionSessionUncheckedCreateWithoutScenariosInput = {
    id?: string
    campaignId: string
    currentScenario?: string | null
    presentationMode?: boolean
    lastSaved?: Date | string
    hasUnsavedChanges?: boolean
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistributionSessionCreateOrConnectWithoutScenariosInput = {
    where: DistributionSessionWhereUniqueInput
    create: XOR<DistributionSessionCreateWithoutScenariosInput, DistributionSessionUncheckedCreateWithoutScenariosInput>
  }

  export type DistributionChangeCreateWithoutScenarioInput = {
    id?: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutDistributionChangesInput
  }

  export type DistributionChangeUncheckedCreateWithoutScenarioInput = {
    id?: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
  }

  export type DistributionChangeCreateOrConnectWithoutScenarioInput = {
    where: DistributionChangeWhereUniqueInput
    create: XOR<DistributionChangeCreateWithoutScenarioInput, DistributionChangeUncheckedCreateWithoutScenarioInput>
  }

  export type DistributionChangeCreateManyScenarioInputEnvelope = {
    data: DistributionChangeCreateManyScenarioInput | DistributionChangeCreateManyScenarioInput[]
    skipDuplicates?: boolean
  }

  export type DistributionSessionUpsertWithoutScenariosInput = {
    update: XOR<DistributionSessionUpdateWithoutScenariosInput, DistributionSessionUncheckedUpdateWithoutScenariosInput>
    create: XOR<DistributionSessionCreateWithoutScenariosInput, DistributionSessionUncheckedCreateWithoutScenariosInput>
    where?: DistributionSessionWhereInput
  }

  export type DistributionSessionUpdateToOneWithWhereWithoutScenariosInput = {
    where?: DistributionSessionWhereInput
    data: XOR<DistributionSessionUpdateWithoutScenariosInput, DistributionSessionUncheckedUpdateWithoutScenariosInput>
  }

  export type DistributionSessionUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutDistributionSessionNestedInput
  }

  export type DistributionSessionUncheckedUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    currentScenario?: NullableStringFieldUpdateOperationsInput | string | null
    presentationMode?: BoolFieldUpdateOperationsInput | boolean
    lastSaved?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUnsavedChanges?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeUpsertWithWhereUniqueWithoutScenarioInput = {
    where: DistributionChangeWhereUniqueInput
    update: XOR<DistributionChangeUpdateWithoutScenarioInput, DistributionChangeUncheckedUpdateWithoutScenarioInput>
    create: XOR<DistributionChangeCreateWithoutScenarioInput, DistributionChangeUncheckedCreateWithoutScenarioInput>
  }

  export type DistributionChangeUpdateWithWhereUniqueWithoutScenarioInput = {
    where: DistributionChangeWhereUniqueInput
    data: XOR<DistributionChangeUpdateWithoutScenarioInput, DistributionChangeUncheckedUpdateWithoutScenarioInput>
  }

  export type DistributionChangeUpdateManyWithWhereWithoutScenarioInput = {
    where: DistributionChangeScalarWhereInput
    data: XOR<DistributionChangeUpdateManyMutationInput, DistributionChangeUncheckedUpdateManyWithoutScenarioInput>
  }

  export type DistributionScenarioCreateWithoutChangesInput = {
    id?: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DistributionSessionCreateNestedOneWithoutScenariosInput
  }

  export type DistributionScenarioUncheckedCreateWithoutChangesInput = {
    id?: string
    sessionId: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistributionScenarioCreateOrConnectWithoutChangesInput = {
    where: DistributionScenarioWhereUniqueInput
    create: XOR<DistributionScenarioCreateWithoutChangesInput, DistributionScenarioUncheckedCreateWithoutChangesInput>
  }

  export type UserCreateWithoutDistributionChangesInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutDistributionChangesInput = {
    id?: string
    email: string
    name: string
    role: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutDistributionChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDistributionChangesInput, UserUncheckedCreateWithoutDistributionChangesInput>
  }

  export type DistributionScenarioUpsertWithoutChangesInput = {
    update: XOR<DistributionScenarioUpdateWithoutChangesInput, DistributionScenarioUncheckedUpdateWithoutChangesInput>
    create: XOR<DistributionScenarioCreateWithoutChangesInput, DistributionScenarioUncheckedCreateWithoutChangesInput>
    where?: DistributionScenarioWhereInput
  }

  export type DistributionScenarioUpdateToOneWithWhereWithoutChangesInput = {
    where?: DistributionScenarioWhereInput
    data: XOR<DistributionScenarioUpdateWithoutChangesInput, DistributionScenarioUncheckedUpdateWithoutChangesInput>
  }

  export type DistributionScenarioUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DistributionSessionUpdateOneRequiredWithoutScenariosNestedInput
  }

  export type DistributionScenarioUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDistributionChangesInput = {
    update: XOR<UserUpdateWithoutDistributionChangesInput, UserUncheckedUpdateWithoutDistributionChangesInput>
    create: XOR<UserCreateWithoutDistributionChangesInput, UserUncheckedCreateWithoutDistributionChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDistributionChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDistributionChangesInput, UserUncheckedUpdateWithoutDistributionChangesInput>
  }

  export type UserUpdateWithoutDistributionChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutDistributionChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    name: string
    brandId: string
    objectives: JsonNullValueInput | InputJsonValue
    budget: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type DistributionChangeCreateManyUserInput = {
    id?: string
    scenarioId: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfps?: RFPUpdateManyWithoutCampaignNestedInput
    partnerAssociations?: CampaignPartnerUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfps?: RFPUncheckedUpdateManyWithoutCampaignNestedInput
    partnerAssociations?: CampaignPartnerUncheckedUpdateManyWithoutCampaignNestedInput
    distributionSession?: DistributionSessionUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    objectives?: JsonNullValueInput | InputJsonValue
    budget?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    scenario?: DistributionScenarioUpdateOneRequiredWithoutChangesNestedInput
  }

  export type DistributionChangeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFPCreateManyCampaignInput = {
    id?: string
    partners: JsonNullValueInput | InputJsonValue
    status: string
    requestedAt: Date | string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignPartnerCreateManyCampaignInput = {
    id?: string
    partnerId: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RFPUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFPUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFPUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    partners?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPartnerUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutCampaignAssociationsNestedInput
  }

  export type CampaignPartnerUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPartnerUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCapabilityCreateManyPartnerInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    details: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastUpdated?: Date | string
    sourceType: $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeSpecCreateManyPartnerInput = {
    id?: string
    format: string
    dimensions: JsonNullValueInput | InputJsonValue
    fileType: string
    maxFileSize: number
    requirements: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerHealthMetricCreateManyPartnerInput = {
    id?: string
    timestamp?: Date | string
    apiStatus: $Enums.ApiStatus
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    lastError?: string | null
    healthScore?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignPartnerCreateManyPartnerInput = {
    id?: string
    campaignId: string
    status?: $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCapabilityUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCapabilityUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCapabilityUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: EnumCapabilitySourceTypeFieldUpdateOperationsInput | $Enums.CapabilitySourceType
    sourceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeSpecUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeSpecUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeSpecUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    dimensions?: JsonNullValueInput | InputJsonValue
    fileType?: StringFieldUpdateOperationsInput | string
    maxFileSize?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerHealthMetricUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PartnerHealthMetricUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    apiStatus?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: NullableFloatFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignPartnerUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutPartnerAssociationsNestedInput
  }

  export type CampaignPartnerUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignPartnerUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignPartnerStatusFieldUpdateOperationsInput | $Enums.CampaignPartnerStatus
    budget?: NullableJsonNullValueInput | InputJsonValue
    targeting?: NullableJsonNullValueInput | InputJsonValue
    creative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetVersionCreateManyDatasetInput = {
    id?: string
    version: string
    description?: string | null
    schema: JsonNullValueInput | InputJsonValue
    metadata: JsonNullValueInput | InputJsonValue
    size?: bigint | number | null
    recordCount?: bigint | number | null
    checksums: JsonNullValueInput | InputJsonValue
    location: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type DataQualityReportCreateManyDatasetInput = {
    id?: string
    reportDate?: Date | string
    overallScore: number
    completeness: number
    accuracy: number
    consistency: number
    validity: number
    freshness: number
    metrics: JsonNullValueInput | InputJsonValue
    anomalies: JsonNullValueInput | InputJsonValue
    issues: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    processingTime?: number | null
    recordsProcessed?: bigint | number | null
    createdAt?: Date | string
  }

  export type IngestionJobCreateManyDatasetInput = {
    id?: string
    jobType: $Enums.IngestionJobType
    status?: $Enums.JobStatus
    config: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    logs?: string | null
    recordsProcessed?: bigint | number | null
    recordsSucceeded?: bigint | number | null
    recordsFailed?: bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetLineageCreateManyUpstreamInput = {
    id?: string
    downstreamId: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
  }

  export type DatasetLineageCreateManyDownstreamInput = {
    id?: string
    upstreamId: string
    transformationType: string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    createdAt?: Date | string
  }

  export type DatasetVersionUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetVersionUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetVersionUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schema?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    checksums?: JsonNullValueInput | InputJsonValue
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityReportUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityReportUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityReportUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    consistency?: FloatFieldUpdateOperationsInput | number
    validity?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    anomalies?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumIngestionJobTypeFieldUpdateOperationsInput | $Enums.IngestionJobType
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    config?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    recordsProcessed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsSucceeded?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recordsFailed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageUpdateWithoutUpstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downstream?: DatasetUpdateOneRequiredWithoutLineageDownstreamNestedInput
  }

  export type DatasetLineageUncheckedUpdateWithoutUpstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    downstreamId?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageUncheckedUpdateManyWithoutUpstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    downstreamId?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageUpdateWithoutDownstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upstream?: DatasetUpdateOneRequiredWithoutLineageUpstreamNestedInput
  }

  export type DatasetLineageUncheckedUpdateWithoutDownstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    upstreamId?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetLineageUncheckedUpdateManyWithoutDownstreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    upstreamId?: StringFieldUpdateOperationsInput | string
    transformationType?: StringFieldUpdateOperationsInput | string
    transformationLogic?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionScenarioCreateManySessionInput = {
    id?: string
    name: string
    description?: string | null
    isBaseline?: boolean
    parameters: JsonNullValueInput | InputJsonValue
    projections: JsonNullValueInput | InputJsonValue
    lastModified?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistributionScenarioUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: DistributionChangeUpdateManyWithoutScenarioNestedInput
  }

  export type DistributionScenarioUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: DistributionChangeUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type DistributionScenarioUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    projections?: JsonNullValueInput | InputJsonValue
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeCreateManyScenarioInput = {
    id?: string
    field: string
    oldValue: JsonNullValueInput | InputJsonValue
    newValue: JsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
  }

  export type DistributionChangeUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDistributionChangesNestedInput
  }

  export type DistributionChangeUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistributionChangeUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    oldValue?: JsonNullValueInput | InputJsonValue
    newValue?: JsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerCountOutputTypeDefaultArgs instead
     */
    export type PartnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetCountOutputTypeDefaultArgs instead
     */
    export type DatasetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributionSessionCountOutputTypeDefaultArgs instead
     */
    export type DistributionSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributionSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributionScenarioCountOutputTypeDefaultArgs instead
     */
    export type DistributionScenarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributionScenarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RFPDefaultArgs instead
     */
    export type RFPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RFPDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerDefaultArgs instead
     */
    export type PartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerCapabilityDefaultArgs instead
     */
    export type PartnerCapabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerCapabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreativeSpecDefaultArgs instead
     */
    export type CreativeSpecArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreativeSpecDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerHealthMetricDefaultArgs instead
     */
    export type PartnerHealthMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerHealthMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignPartnerDefaultArgs instead
     */
    export type CampaignPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignPartnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CapabilityMatrixDefaultArgs instead
     */
    export type CapabilityMatrixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CapabilityMatrixDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetDefaultArgs instead
     */
    export type DatasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetVersionDefaultArgs instead
     */
    export type DatasetVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataQualityReportDefaultArgs instead
     */
    export type DataQualityReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataQualityReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngestionJobDefaultArgs instead
     */
    export type IngestionJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngestionJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatasetLineageDefaultArgs instead
     */
    export type DatasetLineageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatasetLineageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataConnectorDefaultArgs instead
     */
    export type DataConnectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataConnectorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchemaMappingDefaultArgs instead
     */
    export type SchemaMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchemaMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributionSessionDefaultArgs instead
     */
    export type DistributionSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributionSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributionScenarioDefaultArgs instead
     */
    export type DistributionScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributionScenarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributionChangeDefaultArgs instead
     */
    export type DistributionChangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributionChangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistributionCacheDefaultArgs instead
     */
    export type DistributionCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistributionCacheDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}